
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model WidgetConfig
 * 
 */
export type WidgetConfig = $Result.DefaultSelection<Prisma.$WidgetConfigPayload>
/**
 * Model RoomType
 * 
 */
export type RoomType = $Result.DefaultSelection<Prisma.$RoomTypePayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Guest
 * 
 */
export type Guest = $Result.DefaultSelection<Prisma.$GuestPayload>
/**
 * Model RatePlan
 * 
 */
export type RatePlan = $Result.DefaultSelection<Prisma.$RatePlanPayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model DailyPrice
 * 
 */
export type DailyPrice = $Result.DefaultSelection<Prisma.$DailyPricePayload>
/**
 * Model Restriction
 * 
 */
export type Restriction = $Result.DefaultSelection<Prisma.$RestrictionPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingRoom
 * 
 */
export type BookingRoom = $Result.DefaultSelection<Prisma.$BookingRoomPayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model ChannelMapping
 * 
 */
export type ChannelMapping = $Result.DefaultSelection<Prisma.$ChannelMappingPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ICalFeed
 * 
 */
export type ICalFeed = $Result.DefaultSelection<Prisma.$ICalFeedPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Restaurant
 * 
 */
export type Restaurant = $Result.DefaultSelection<Prisma.$RestaurantPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model ResBooking
 * 
 */
export type ResBooking = $Result.DefaultSelection<Prisma.$ResBookingPayload>
/**
 * Model RestaurantChannel
 * 
 */
export type RestaurantChannel = $Result.DefaultSelection<Prisma.$RestaurantChannelPayload>
/**
 * Model ResPolicy
 * 
 */
export type ResPolicy = $Result.DefaultSelection<Prisma.$ResPolicyPayload>
/**
 * Model TableHold
 * 
 */
export type TableHold = $Result.DefaultSelection<Prisma.$TableHoldPayload>
/**
 * Model RestaurantWaitlist
 * 
 */
export type RestaurantWaitlist = $Result.DefaultSelection<Prisma.$RestaurantWaitlistPayload>
/**
 * Model HotelWaitlist
 * 
 */
export type HotelWaitlist = $Result.DefaultSelection<Prisma.$HotelWaitlistPayload>
/**
 * Model CustomerProfile
 * 
 */
export type CustomerProfile = $Result.DefaultSelection<Prisma.$CustomerProfilePayload>
/**
 * Model IdentityLink
 * 
 */
export type IdentityLink = $Result.DefaultSelection<Prisma.$IdentityLinkPayload>
/**
 * Model WebVisit
 * 
 */
export type WebVisit = $Result.DefaultSelection<Prisma.$WebVisitPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Hotels
 * const hotels = await prisma.hotel.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Hotels
   * const hotels = await prisma.hotel.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs>;

  /**
   * `prisma.widgetConfig`: Exposes CRUD operations for the **WidgetConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WidgetConfigs
    * const widgetConfigs = await prisma.widgetConfig.findMany()
    * ```
    */
  get widgetConfig(): Prisma.WidgetConfigDelegate<ExtArgs>;

  /**
   * `prisma.roomType`: Exposes CRUD operations for the **RoomType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypes
    * const roomTypes = await prisma.roomType.findMany()
    * ```
    */
  get roomType(): Prisma.RoomTypeDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **Guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): Prisma.GuestDelegate<ExtArgs>;

  /**
   * `prisma.ratePlan`: Exposes CRUD operations for the **RatePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RatePlans
    * const ratePlans = await prisma.ratePlan.findMany()
    * ```
    */
  get ratePlan(): Prisma.RatePlanDelegate<ExtArgs>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs>;

  /**
   * `prisma.dailyPrice`: Exposes CRUD operations for the **DailyPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyPrices
    * const dailyPrices = await prisma.dailyPrice.findMany()
    * ```
    */
  get dailyPrice(): Prisma.DailyPriceDelegate<ExtArgs>;

  /**
   * `prisma.restriction`: Exposes CRUD operations for the **Restriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restrictions
    * const restrictions = await prisma.restriction.findMany()
    * ```
    */
  get restriction(): Prisma.RestrictionDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.bookingRoom`: Exposes CRUD operations for the **BookingRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingRooms
    * const bookingRooms = await prisma.bookingRoom.findMany()
    * ```
    */
  get bookingRoom(): Prisma.BookingRoomDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.channelMapping`: Exposes CRUD operations for the **ChannelMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelMappings
    * const channelMappings = await prisma.channelMapping.findMany()
    * ```
    */
  get channelMapping(): Prisma.ChannelMappingDelegate<ExtArgs>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.iCalFeed`: Exposes CRUD operations for the **ICalFeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ICalFeeds
    * const iCalFeeds = await prisma.iCalFeed.findMany()
    * ```
    */
  get iCalFeed(): Prisma.ICalFeedDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs>;

  /**
   * `prisma.resBooking`: Exposes CRUD operations for the **ResBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResBookings
    * const resBookings = await prisma.resBooking.findMany()
    * ```
    */
  get resBooking(): Prisma.ResBookingDelegate<ExtArgs>;

  /**
   * `prisma.restaurantChannel`: Exposes CRUD operations for the **RestaurantChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantChannels
    * const restaurantChannels = await prisma.restaurantChannel.findMany()
    * ```
    */
  get restaurantChannel(): Prisma.RestaurantChannelDelegate<ExtArgs>;

  /**
   * `prisma.resPolicy`: Exposes CRUD operations for the **ResPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResPolicies
    * const resPolicies = await prisma.resPolicy.findMany()
    * ```
    */
  get resPolicy(): Prisma.ResPolicyDelegate<ExtArgs>;

  /**
   * `prisma.tableHold`: Exposes CRUD operations for the **TableHold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableHolds
    * const tableHolds = await prisma.tableHold.findMany()
    * ```
    */
  get tableHold(): Prisma.TableHoldDelegate<ExtArgs>;

  /**
   * `prisma.restaurantWaitlist`: Exposes CRUD operations for the **RestaurantWaitlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantWaitlists
    * const restaurantWaitlists = await prisma.restaurantWaitlist.findMany()
    * ```
    */
  get restaurantWaitlist(): Prisma.RestaurantWaitlistDelegate<ExtArgs>;

  /**
   * `prisma.hotelWaitlist`: Exposes CRUD operations for the **HotelWaitlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelWaitlists
    * const hotelWaitlists = await prisma.hotelWaitlist.findMany()
    * ```
    */
  get hotelWaitlist(): Prisma.HotelWaitlistDelegate<ExtArgs>;

  /**
   * `prisma.customerProfile`: Exposes CRUD operations for the **CustomerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerProfiles
    * const customerProfiles = await prisma.customerProfile.findMany()
    * ```
    */
  get customerProfile(): Prisma.CustomerProfileDelegate<ExtArgs>;

  /**
   * `prisma.identityLink`: Exposes CRUD operations for the **IdentityLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdentityLinks
    * const identityLinks = await prisma.identityLink.findMany()
    * ```
    */
  get identityLink(): Prisma.IdentityLinkDelegate<ExtArgs>;

  /**
   * `prisma.webVisit`: Exposes CRUD operations for the **WebVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebVisits
    * const webVisits = await prisma.webVisit.findMany()
    * ```
    */
  get webVisit(): Prisma.WebVisitDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Hotel: 'Hotel',
    WidgetConfig: 'WidgetConfig',
    RoomType: 'RoomType',
    Room: 'Room',
    Guest: 'Guest',
    RatePlan: 'RatePlan',
    Season: 'Season',
    DailyPrice: 'DailyPrice',
    Restriction: 'Restriction',
    Booking: 'Booking',
    BookingRoom: 'BookingRoom',
    Channel: 'Channel',
    ChannelMapping: 'ChannelMapping',
    SyncLog: 'SyncLog',
    AuditLog: 'AuditLog',
    ICalFeed: 'ICalFeed',
    Payment: 'Payment',
    User: 'User',
    Restaurant: 'Restaurant',
    Zone: 'Zone',
    Table: 'Table',
    ResBooking: 'ResBooking',
    RestaurantChannel: 'RestaurantChannel',
    ResPolicy: 'ResPolicy',
    TableHold: 'TableHold',
    RestaurantWaitlist: 'RestaurantWaitlist',
    HotelWaitlist: 'HotelWaitlist',
    CustomerProfile: 'CustomerProfile',
    IdentityLink: 'IdentityLink',
    WebVisit: 'WebVisit',
    Campaign: 'Campaign',
    Workflow: 'Workflow'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "hotel" | "widgetConfig" | "roomType" | "room" | "guest" | "ratePlan" | "season" | "dailyPrice" | "restriction" | "booking" | "bookingRoom" | "channel" | "channelMapping" | "syncLog" | "auditLog" | "iCalFeed" | "payment" | "user" | "restaurant" | "zone" | "table" | "resBooking" | "restaurantChannel" | "resPolicy" | "tableHold" | "restaurantWaitlist" | "hotelWaitlist" | "customerProfile" | "identityLink" | "webVisit" | "campaign" | "workflow"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      WidgetConfig: {
        payload: Prisma.$WidgetConfigPayload<ExtArgs>
        fields: Prisma.WidgetConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WidgetConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WidgetConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          findFirst: {
            args: Prisma.WidgetConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WidgetConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          findMany: {
            args: Prisma.WidgetConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>[]
          }
          create: {
            args: Prisma.WidgetConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          createMany: {
            args: Prisma.WidgetConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WidgetConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>[]
          }
          delete: {
            args: Prisma.WidgetConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          update: {
            args: Prisma.WidgetConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          deleteMany: {
            args: Prisma.WidgetConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WidgetConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WidgetConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetConfigPayload>
          }
          aggregate: {
            args: Prisma.WidgetConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWidgetConfig>
          }
          groupBy: {
            args: Prisma.WidgetConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WidgetConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WidgetConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WidgetConfigCountAggregateOutputType> | number
          }
        }
      }
      RoomType: {
        payload: Prisma.$RoomTypePayload<ExtArgs>
        fields: Prisma.RoomTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findFirst: {
            args: Prisma.RoomTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findMany: {
            args: Prisma.RoomTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          create: {
            args: Prisma.RoomTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          createMany: {
            args: Prisma.RoomTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          delete: {
            args: Prisma.RoomTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          update: {
            args: Prisma.RoomTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          deleteMany: {
            args: Prisma.RoomTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          aggregate: {
            args: Prisma.RoomTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomType>
          }
          groupBy: {
            args: Prisma.RoomTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Guest: {
        payload: Prisma.$GuestPayload<ExtArgs>
        fields: Prisma.GuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findFirst: {
            args: Prisma.GuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findMany: {
            args: Prisma.GuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          create: {
            args: Prisma.GuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          createMany: {
            args: Prisma.GuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          delete: {
            args: Prisma.GuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          update: {
            args: Prisma.GuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          deleteMany: {
            args: Prisma.GuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          aggregate: {
            args: Prisma.GuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuest>
          }
          groupBy: {
            args: Prisma.GuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuestCountArgs<ExtArgs>
            result: $Utils.Optional<GuestCountAggregateOutputType> | number
          }
        }
      }
      RatePlan: {
        payload: Prisma.$RatePlanPayload<ExtArgs>
        fields: Prisma.RatePlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatePlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatePlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          findFirst: {
            args: Prisma.RatePlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatePlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          findMany: {
            args: Prisma.RatePlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>[]
          }
          create: {
            args: Prisma.RatePlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          createMany: {
            args: Prisma.RatePlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatePlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>[]
          }
          delete: {
            args: Prisma.RatePlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          update: {
            args: Prisma.RatePlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          deleteMany: {
            args: Prisma.RatePlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatePlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RatePlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatePlanPayload>
          }
          aggregate: {
            args: Prisma.RatePlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRatePlan>
          }
          groupBy: {
            args: Prisma.RatePlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatePlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatePlanCountArgs<ExtArgs>
            result: $Utils.Optional<RatePlanCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      DailyPrice: {
        payload: Prisma.$DailyPricePayload<ExtArgs>
        fields: Prisma.DailyPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          findFirst: {
            args: Prisma.DailyPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          findMany: {
            args: Prisma.DailyPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>[]
          }
          create: {
            args: Prisma.DailyPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          createMany: {
            args: Prisma.DailyPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>[]
          }
          delete: {
            args: Prisma.DailyPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          update: {
            args: Prisma.DailyPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          deleteMany: {
            args: Prisma.DailyPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyPricePayload>
          }
          aggregate: {
            args: Prisma.DailyPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyPrice>
          }
          groupBy: {
            args: Prisma.DailyPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyPriceCountArgs<ExtArgs>
            result: $Utils.Optional<DailyPriceCountAggregateOutputType> | number
          }
        }
      }
      Restriction: {
        payload: Prisma.$RestrictionPayload<ExtArgs>
        fields: Prisma.RestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestrictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestrictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          findFirst: {
            args: Prisma.RestrictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestrictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          findMany: {
            args: Prisma.RestrictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>[]
          }
          create: {
            args: Prisma.RestrictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          createMany: {
            args: Prisma.RestrictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestrictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>[]
          }
          delete: {
            args: Prisma.RestrictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          update: {
            args: Prisma.RestrictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          deleteMany: {
            args: Prisma.RestrictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestrictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestrictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          aggregate: {
            args: Prisma.RestrictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestriction>
          }
          groupBy: {
            args: Prisma.RestrictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestrictionCountArgs<ExtArgs>
            result: $Utils.Optional<RestrictionCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingRoom: {
        payload: Prisma.$BookingRoomPayload<ExtArgs>
        fields: Prisma.BookingRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          findFirst: {
            args: Prisma.BookingRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          findMany: {
            args: Prisma.BookingRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>[]
          }
          create: {
            args: Prisma.BookingRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          createMany: {
            args: Prisma.BookingRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>[]
          }
          delete: {
            args: Prisma.BookingRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          update: {
            args: Prisma.BookingRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          deleteMany: {
            args: Prisma.BookingRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRoomPayload>
          }
          aggregate: {
            args: Prisma.BookingRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingRoom>
          }
          groupBy: {
            args: Prisma.BookingRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingRoomCountArgs<ExtArgs>
            result: $Utils.Optional<BookingRoomCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      ChannelMapping: {
        payload: Prisma.$ChannelMappingPayload<ExtArgs>
        fields: Prisma.ChannelMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          findFirst: {
            args: Prisma.ChannelMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          findMany: {
            args: Prisma.ChannelMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>[]
          }
          create: {
            args: Prisma.ChannelMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          createMany: {
            args: Prisma.ChannelMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>[]
          }
          delete: {
            args: Prisma.ChannelMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          update: {
            args: Prisma.ChannelMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          deleteMany: {
            args: Prisma.ChannelMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMappingPayload>
          }
          aggregate: {
            args: Prisma.ChannelMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelMapping>
          }
          groupBy: {
            args: Prisma.ChannelMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelMappingCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ICalFeed: {
        payload: Prisma.$ICalFeedPayload<ExtArgs>
        fields: Prisma.ICalFeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ICalFeedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ICalFeedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          findFirst: {
            args: Prisma.ICalFeedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ICalFeedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          findMany: {
            args: Prisma.ICalFeedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>[]
          }
          create: {
            args: Prisma.ICalFeedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          createMany: {
            args: Prisma.ICalFeedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ICalFeedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>[]
          }
          delete: {
            args: Prisma.ICalFeedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          update: {
            args: Prisma.ICalFeedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          deleteMany: {
            args: Prisma.ICalFeedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ICalFeedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ICalFeedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICalFeedPayload>
          }
          aggregate: {
            args: Prisma.ICalFeedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateICalFeed>
          }
          groupBy: {
            args: Prisma.ICalFeedGroupByArgs<ExtArgs>
            result: $Utils.Optional<ICalFeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.ICalFeedCountArgs<ExtArgs>
            result: $Utils.Optional<ICalFeedCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Restaurant: {
        payload: Prisma.$RestaurantPayload<ExtArgs>
        fields: Prisma.RestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findFirst: {
            args: Prisma.RestaurantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findMany: {
            args: Prisma.RestaurantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          create: {
            args: Prisma.RestaurantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          createMany: {
            args: Prisma.RestaurantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          delete: {
            args: Prisma.RestaurantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          update: {
            args: Prisma.RestaurantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          aggregate: {
            args: Prisma.RestaurantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurant>
          }
          groupBy: {
            args: Prisma.RestaurantGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      ResBooking: {
        payload: Prisma.$ResBookingPayload<ExtArgs>
        fields: Prisma.ResBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          findFirst: {
            args: Prisma.ResBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          findMany: {
            args: Prisma.ResBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>[]
          }
          create: {
            args: Prisma.ResBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          createMany: {
            args: Prisma.ResBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>[]
          }
          delete: {
            args: Prisma.ResBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          update: {
            args: Prisma.ResBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          deleteMany: {
            args: Prisma.ResBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResBookingPayload>
          }
          aggregate: {
            args: Prisma.ResBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResBooking>
          }
          groupBy: {
            args: Prisma.ResBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ResBookingCountAggregateOutputType> | number
          }
        }
      }
      RestaurantChannel: {
        payload: Prisma.$RestaurantChannelPayload<ExtArgs>
        fields: Prisma.RestaurantChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          findFirst: {
            args: Prisma.RestaurantChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          findMany: {
            args: Prisma.RestaurantChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>[]
          }
          create: {
            args: Prisma.RestaurantChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          createMany: {
            args: Prisma.RestaurantChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>[]
          }
          delete: {
            args: Prisma.RestaurantChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          update: {
            args: Prisma.RestaurantChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantChannelPayload>
          }
          aggregate: {
            args: Prisma.RestaurantChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantChannel>
          }
          groupBy: {
            args: Prisma.RestaurantChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantChannelCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantChannelCountAggregateOutputType> | number
          }
        }
      }
      ResPolicy: {
        payload: Prisma.$ResPolicyPayload<ExtArgs>
        fields: Prisma.ResPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          findFirst: {
            args: Prisma.ResPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          findMany: {
            args: Prisma.ResPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>[]
          }
          create: {
            args: Prisma.ResPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          createMany: {
            args: Prisma.ResPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>[]
          }
          delete: {
            args: Prisma.ResPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          update: {
            args: Prisma.ResPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          deleteMany: {
            args: Prisma.ResPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResPolicyPayload>
          }
          aggregate: {
            args: Prisma.ResPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResPolicy>
          }
          groupBy: {
            args: Prisma.ResPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<ResPolicyCountAggregateOutputType> | number
          }
        }
      }
      TableHold: {
        payload: Prisma.$TableHoldPayload<ExtArgs>
        fields: Prisma.TableHoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableHoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableHoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          findFirst: {
            args: Prisma.TableHoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableHoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          findMany: {
            args: Prisma.TableHoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>[]
          }
          create: {
            args: Prisma.TableHoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          createMany: {
            args: Prisma.TableHoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableHoldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>[]
          }
          delete: {
            args: Prisma.TableHoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          update: {
            args: Prisma.TableHoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          deleteMany: {
            args: Prisma.TableHoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableHoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableHoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableHoldPayload>
          }
          aggregate: {
            args: Prisma.TableHoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTableHold>
          }
          groupBy: {
            args: Prisma.TableHoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableHoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableHoldCountArgs<ExtArgs>
            result: $Utils.Optional<TableHoldCountAggregateOutputType> | number
          }
        }
      }
      RestaurantWaitlist: {
        payload: Prisma.$RestaurantWaitlistPayload<ExtArgs>
        fields: Prisma.RestaurantWaitlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantWaitlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantWaitlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          findFirst: {
            args: Prisma.RestaurantWaitlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantWaitlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          findMany: {
            args: Prisma.RestaurantWaitlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>[]
          }
          create: {
            args: Prisma.RestaurantWaitlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          createMany: {
            args: Prisma.RestaurantWaitlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantWaitlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>[]
          }
          delete: {
            args: Prisma.RestaurantWaitlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          update: {
            args: Prisma.RestaurantWaitlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantWaitlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantWaitlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantWaitlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantWaitlistPayload>
          }
          aggregate: {
            args: Prisma.RestaurantWaitlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantWaitlist>
          }
          groupBy: {
            args: Prisma.RestaurantWaitlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantWaitlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantWaitlistCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantWaitlistCountAggregateOutputType> | number
          }
        }
      }
      HotelWaitlist: {
        payload: Prisma.$HotelWaitlistPayload<ExtArgs>
        fields: Prisma.HotelWaitlistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelWaitlistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelWaitlistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          findFirst: {
            args: Prisma.HotelWaitlistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelWaitlistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          findMany: {
            args: Prisma.HotelWaitlistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>[]
          }
          create: {
            args: Prisma.HotelWaitlistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          createMany: {
            args: Prisma.HotelWaitlistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelWaitlistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>[]
          }
          delete: {
            args: Prisma.HotelWaitlistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          update: {
            args: Prisma.HotelWaitlistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          deleteMany: {
            args: Prisma.HotelWaitlistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelWaitlistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelWaitlistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelWaitlistPayload>
          }
          aggregate: {
            args: Prisma.HotelWaitlistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelWaitlist>
          }
          groupBy: {
            args: Prisma.HotelWaitlistGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelWaitlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelWaitlistCountArgs<ExtArgs>
            result: $Utils.Optional<HotelWaitlistCountAggregateOutputType> | number
          }
        }
      }
      CustomerProfile: {
        payload: Prisma.$CustomerProfilePayload<ExtArgs>
        fields: Prisma.CustomerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          findFirst: {
            args: Prisma.CustomerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          findMany: {
            args: Prisma.CustomerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>[]
          }
          create: {
            args: Prisma.CustomerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          createMany: {
            args: Prisma.CustomerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>[]
          }
          delete: {
            args: Prisma.CustomerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          update: {
            args: Prisma.CustomerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          deleteMany: {
            args: Prisma.CustomerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>
          }
          aggregate: {
            args: Prisma.CustomerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerProfile>
          }
          groupBy: {
            args: Prisma.CustomerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerProfileCountAggregateOutputType> | number
          }
        }
      }
      IdentityLink: {
        payload: Prisma.$IdentityLinkPayload<ExtArgs>
        fields: Prisma.IdentityLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentityLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentityLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          findFirst: {
            args: Prisma.IdentityLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentityLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          findMany: {
            args: Prisma.IdentityLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>[]
          }
          create: {
            args: Prisma.IdentityLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          createMany: {
            args: Prisma.IdentityLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentityLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>[]
          }
          delete: {
            args: Prisma.IdentityLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          update: {
            args: Prisma.IdentityLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          deleteMany: {
            args: Prisma.IdentityLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentityLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IdentityLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityLinkPayload>
          }
          aggregate: {
            args: Prisma.IdentityLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentityLink>
          }
          groupBy: {
            args: Prisma.IdentityLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentityLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentityLinkCountArgs<ExtArgs>
            result: $Utils.Optional<IdentityLinkCountAggregateOutputType> | number
          }
        }
      }
      WebVisit: {
        payload: Prisma.$WebVisitPayload<ExtArgs>
        fields: Prisma.WebVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          findFirst: {
            args: Prisma.WebVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          findMany: {
            args: Prisma.WebVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>[]
          }
          create: {
            args: Prisma.WebVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          createMany: {
            args: Prisma.WebVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>[]
          }
          delete: {
            args: Prisma.WebVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          update: {
            args: Prisma.WebVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          deleteMany: {
            args: Prisma.WebVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebVisitPayload>
          }
          aggregate: {
            args: Prisma.WebVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebVisit>
          }
          groupBy: {
            args: Prisma.WebVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebVisitCountArgs<ExtArgs>
            result: $Utils.Optional<WebVisitCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    roomTypes: number
    bookings: number
    ratePlans: number
    seasons: number
    users: number
    restrictions: number
    waitlistEntries: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomTypes?: boolean | HotelCountOutputTypeCountRoomTypesArgs
    bookings?: boolean | HotelCountOutputTypeCountBookingsArgs
    ratePlans?: boolean | HotelCountOutputTypeCountRatePlansArgs
    seasons?: boolean | HotelCountOutputTypeCountSeasonsArgs
    users?: boolean | HotelCountOutputTypeCountUsersArgs
    restrictions?: boolean | HotelCountOutputTypeCountRestrictionsArgs
    waitlistEntries?: boolean | HotelCountOutputTypeCountWaitlistEntriesArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatePlanWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountWaitlistEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWaitlistWhereInput
  }


  /**
   * Count Type RoomTypeCountOutputType
   */

  export type RoomTypeCountOutputType = {
    rooms: number
    icalFeeds: number
    dailyPrices: number
    restrictions: number
    channelMappings: number
    waitlistEntries: number
  }

  export type RoomTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | RoomTypeCountOutputTypeCountRoomsArgs
    icalFeeds?: boolean | RoomTypeCountOutputTypeCountIcalFeedsArgs
    dailyPrices?: boolean | RoomTypeCountOutputTypeCountDailyPricesArgs
    restrictions?: boolean | RoomTypeCountOutputTypeCountRestrictionsArgs
    channelMappings?: boolean | RoomTypeCountOutputTypeCountChannelMappingsArgs
    waitlistEntries?: boolean | RoomTypeCountOutputTypeCountWaitlistEntriesArgs
  }

  // Custom InputTypes
  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeCountOutputType
     */
    select?: RoomTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountIcalFeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ICalFeedWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountDailyPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyPriceWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountChannelMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMappingWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountWaitlistEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWaitlistWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    bookingRooms: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRooms?: boolean | RoomCountOutputTypeCountBookingRoomsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountBookingRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRoomWhereInput
  }


  /**
   * Count Type GuestCountOutputType
   */

  export type GuestCountOutputType = {
    bookings: number
  }

  export type GuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | GuestCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestCountOutputType
     */
    select?: GuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type RatePlanCountOutputType
   */

  export type RatePlanCountOutputType = {
    dailyPrices: number
    restrictions: number
    channelMappings: number
  }

  export type RatePlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyPrices?: boolean | RatePlanCountOutputTypeCountDailyPricesArgs
    restrictions?: boolean | RatePlanCountOutputTypeCountRestrictionsArgs
    channelMappings?: boolean | RatePlanCountOutputTypeCountChannelMappingsArgs
  }

  // Custom InputTypes
  /**
   * RatePlanCountOutputType without action
   */
  export type RatePlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlanCountOutputType
     */
    select?: RatePlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RatePlanCountOutputType without action
   */
  export type RatePlanCountOutputTypeCountDailyPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyPriceWhereInput
  }

  /**
   * RatePlanCountOutputType without action
   */
  export type RatePlanCountOutputTypeCountRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
  }

  /**
   * RatePlanCountOutputType without action
   */
  export type RatePlanCountOutputTypeCountChannelMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMappingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    bookingRooms: number
    payments: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRooms?: boolean | BookingCountOutputTypeCountBookingRoomsArgs
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBookingRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRoomWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    mappings: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mappings?: boolean | ChannelCountOutputTypeCountMappingsArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMappingWhereInput
  }


  /**
   * Count Type RestaurantCountOutputType
   */

  export type RestaurantCountOutputType = {
    zones: number
    bookings: number
    waitlist: number
  }

  export type RestaurantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | RestaurantCountOutputTypeCountZonesArgs
    bookings?: boolean | RestaurantCountOutputTypeCountBookingsArgs
    waitlist?: boolean | RestaurantCountOutputTypeCountWaitlistArgs
  }

  // Custom InputTypes
  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCountOutputType
     */
    select?: RestaurantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResBookingWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountWaitlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWaitlistWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    tables: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | ZoneCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    resBookings: number
    tableHolds: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resBookings?: boolean | TableCountOutputTypeCountResBookingsArgs
    tableHolds?: boolean | TableCountOutputTypeCountTableHoldsArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountResBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResBookingWhereInput
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountTableHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableHoldWhereInput
  }


  /**
   * Count Type RestaurantChannelCountOutputType
   */

  export type RestaurantChannelCountOutputType = {
    resBookings: number
  }

  export type RestaurantChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resBookings?: boolean | RestaurantChannelCountOutputTypeCountResBookingsArgs
  }

  // Custom InputTypes
  /**
   * RestaurantChannelCountOutputType without action
   */
  export type RestaurantChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannelCountOutputType
     */
    select?: RestaurantChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantChannelCountOutputType without action
   */
  export type RestaurantChannelCountOutputTypeCountResBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResBookingWhereInput
  }


  /**
   * Count Type CustomerProfileCountOutputType
   */

  export type CustomerProfileCountOutputType = {
    identityLinks: number
    webVisits: number
  }

  export type CustomerProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identityLinks?: boolean | CustomerProfileCountOutputTypeCountIdentityLinksArgs
    webVisits?: boolean | CustomerProfileCountOutputTypeCountWebVisitsArgs
  }

  // Custom InputTypes
  /**
   * CustomerProfileCountOutputType without action
   */
  export type CustomerProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfileCountOutputType
     */
    select?: CustomerProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerProfileCountOutputType without action
   */
  export type CustomerProfileCountOutputTypeCountIdentityLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityLinkWhereInput
  }

  /**
   * CustomerProfileCountOutputType without action
   */
  export type CustomerProfileCountOutputTypeCountWebVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebVisitWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    timezone: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    timezone: string | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    timezone: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    timezone?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    timezone?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    timezone?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    timezone: string
    currency: string
    createdAt: Date
    updatedAt: Date
    _count: HotelCountAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    timezone?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roomTypes?: boolean | Hotel$roomTypesArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    ratePlans?: boolean | Hotel$ratePlansArgs<ExtArgs>
    seasons?: boolean | Hotel$seasonsArgs<ExtArgs>
    users?: boolean | Hotel$usersArgs<ExtArgs>
    widgetConfig?: boolean | Hotel$widgetConfigArgs<ExtArgs>
    restrictions?: boolean | Hotel$restrictionsArgs<ExtArgs>
    waitlistEntries?: boolean | Hotel$waitlistEntriesArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    timezone?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    timezone?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomTypes?: boolean | Hotel$roomTypesArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    ratePlans?: boolean | Hotel$ratePlansArgs<ExtArgs>
    seasons?: boolean | Hotel$seasonsArgs<ExtArgs>
    users?: boolean | Hotel$usersArgs<ExtArgs>
    widgetConfig?: boolean | Hotel$widgetConfigArgs<ExtArgs>
    restrictions?: boolean | Hotel$restrictionsArgs<ExtArgs>
    waitlistEntries?: boolean | Hotel$waitlistEntriesArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      roomTypes: Prisma.$RoomTypePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      ratePlans: Prisma.$RatePlanPayload<ExtArgs>[]
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      widgetConfig: Prisma.$WidgetConfigPayload<ExtArgs> | null
      restrictions: Prisma.$RestrictionPayload<ExtArgs>[]
      waitlistEntries: Prisma.$HotelWaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      timezone: string
      currency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roomTypes<T extends Hotel$roomTypesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Hotel$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    ratePlans<T extends Hotel$ratePlansArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$ratePlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findMany"> | Null>
    seasons<T extends Hotel$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Hotel$usersArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    widgetConfig<T extends Hotel$widgetConfigArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$widgetConfigArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    restrictions<T extends Hotel$restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$restrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany"> | Null>
    waitlistEntries<T extends Hotel$waitlistEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$waitlistEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */ 
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'String'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly domain: FieldRef<"Hotel", 'String'>
    readonly timezone: FieldRef<"Hotel", 'String'>
    readonly currency: FieldRef<"Hotel", 'String'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
    readonly updatedAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel.roomTypes
   */
  export type Hotel$roomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    cursor?: RoomTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * Hotel.bookings
   */
  export type Hotel$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Hotel.ratePlans
   */
  export type Hotel$ratePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    where?: RatePlanWhereInput
    orderBy?: RatePlanOrderByWithRelationInput | RatePlanOrderByWithRelationInput[]
    cursor?: RatePlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatePlanScalarFieldEnum | RatePlanScalarFieldEnum[]
  }

  /**
   * Hotel.seasons
   */
  export type Hotel$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Hotel.users
   */
  export type Hotel$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Hotel.widgetConfig
   */
  export type Hotel$widgetConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    where?: WidgetConfigWhereInput
  }

  /**
   * Hotel.restrictions
   */
  export type Hotel$restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    cursor?: RestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Hotel.waitlistEntries
   */
  export type Hotel$waitlistEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    where?: HotelWaitlistWhereInput
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    cursor?: HotelWaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelWaitlistScalarFieldEnum | HotelWaitlistScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model WidgetConfig
   */

  export type AggregateWidgetConfig = {
    _count: WidgetConfigCountAggregateOutputType | null
    _min: WidgetConfigMinAggregateOutputType | null
    _max: WidgetConfigMaxAggregateOutputType | null
  }

  export type WidgetConfigMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    primaryColor: string | null
    secondaryColor: string | null
    customCss: string | null
    showLogo: boolean | null
    title: string | null
  }

  export type WidgetConfigMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    primaryColor: string | null
    secondaryColor: string | null
    customCss: string | null
    showLogo: boolean | null
    title: string | null
  }

  export type WidgetConfigCountAggregateOutputType = {
    id: number
    hotelId: number
    primaryColor: number
    secondaryColor: number
    customCss: number
    showLogo: number
    title: number
    _all: number
  }


  export type WidgetConfigMinAggregateInputType = {
    id?: true
    hotelId?: true
    primaryColor?: true
    secondaryColor?: true
    customCss?: true
    showLogo?: true
    title?: true
  }

  export type WidgetConfigMaxAggregateInputType = {
    id?: true
    hotelId?: true
    primaryColor?: true
    secondaryColor?: true
    customCss?: true
    showLogo?: true
    title?: true
  }

  export type WidgetConfigCountAggregateInputType = {
    id?: true
    hotelId?: true
    primaryColor?: true
    secondaryColor?: true
    customCss?: true
    showLogo?: true
    title?: true
    _all?: true
  }

  export type WidgetConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WidgetConfig to aggregate.
     */
    where?: WidgetConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WidgetConfigs to fetch.
     */
    orderBy?: WidgetConfigOrderByWithRelationInput | WidgetConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WidgetConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WidgetConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WidgetConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WidgetConfigs
    **/
    _count?: true | WidgetConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WidgetConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WidgetConfigMaxAggregateInputType
  }

  export type GetWidgetConfigAggregateType<T extends WidgetConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWidgetConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWidgetConfig[P]>
      : GetScalarType<T[P], AggregateWidgetConfig[P]>
  }




  export type WidgetConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WidgetConfigWhereInput
    orderBy?: WidgetConfigOrderByWithAggregationInput | WidgetConfigOrderByWithAggregationInput[]
    by: WidgetConfigScalarFieldEnum[] | WidgetConfigScalarFieldEnum
    having?: WidgetConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WidgetConfigCountAggregateInputType | true
    _min?: WidgetConfigMinAggregateInputType
    _max?: WidgetConfigMaxAggregateInputType
  }

  export type WidgetConfigGroupByOutputType = {
    id: string
    hotelId: string
    primaryColor: string
    secondaryColor: string
    customCss: string | null
    showLogo: boolean
    title: string | null
    _count: WidgetConfigCountAggregateOutputType | null
    _min: WidgetConfigMinAggregateOutputType | null
    _max: WidgetConfigMaxAggregateOutputType | null
  }

  type GetWidgetConfigGroupByPayload<T extends WidgetConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WidgetConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WidgetConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WidgetConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WidgetConfigGroupByOutputType[P]>
        }
      >
    >


  export type WidgetConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    customCss?: boolean
    showLogo?: boolean
    title?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["widgetConfig"]>

  export type WidgetConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    customCss?: boolean
    showLogo?: boolean
    title?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["widgetConfig"]>

  export type WidgetConfigSelectScalar = {
    id?: boolean
    hotelId?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    customCss?: boolean
    showLogo?: boolean
    title?: boolean
  }

  export type WidgetConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type WidgetConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $WidgetConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WidgetConfig"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      primaryColor: string
      secondaryColor: string
      customCss: string | null
      showLogo: boolean
      title: string | null
    }, ExtArgs["result"]["widgetConfig"]>
    composites: {}
  }

  type WidgetConfigGetPayload<S extends boolean | null | undefined | WidgetConfigDefaultArgs> = $Result.GetResult<Prisma.$WidgetConfigPayload, S>

  type WidgetConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WidgetConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WidgetConfigCountAggregateInputType | true
    }

  export interface WidgetConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WidgetConfig'], meta: { name: 'WidgetConfig' } }
    /**
     * Find zero or one WidgetConfig that matches the filter.
     * @param {WidgetConfigFindUniqueArgs} args - Arguments to find a WidgetConfig
     * @example
     * // Get one WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WidgetConfigFindUniqueArgs>(args: SelectSubset<T, WidgetConfigFindUniqueArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WidgetConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WidgetConfigFindUniqueOrThrowArgs} args - Arguments to find a WidgetConfig
     * @example
     * // Get one WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WidgetConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WidgetConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WidgetConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigFindFirstArgs} args - Arguments to find a WidgetConfig
     * @example
     * // Get one WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WidgetConfigFindFirstArgs>(args?: SelectSubset<T, WidgetConfigFindFirstArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WidgetConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigFindFirstOrThrowArgs} args - Arguments to find a WidgetConfig
     * @example
     * // Get one WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WidgetConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WidgetConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WidgetConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WidgetConfigs
     * const widgetConfigs = await prisma.widgetConfig.findMany()
     * 
     * // Get first 10 WidgetConfigs
     * const widgetConfigs = await prisma.widgetConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const widgetConfigWithIdOnly = await prisma.widgetConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WidgetConfigFindManyArgs>(args?: SelectSubset<T, WidgetConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WidgetConfig.
     * @param {WidgetConfigCreateArgs} args - Arguments to create a WidgetConfig.
     * @example
     * // Create one WidgetConfig
     * const WidgetConfig = await prisma.widgetConfig.create({
     *   data: {
     *     // ... data to create a WidgetConfig
     *   }
     * })
     * 
     */
    create<T extends WidgetConfigCreateArgs>(args: SelectSubset<T, WidgetConfigCreateArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WidgetConfigs.
     * @param {WidgetConfigCreateManyArgs} args - Arguments to create many WidgetConfigs.
     * @example
     * // Create many WidgetConfigs
     * const widgetConfig = await prisma.widgetConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WidgetConfigCreateManyArgs>(args?: SelectSubset<T, WidgetConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WidgetConfigs and returns the data saved in the database.
     * @param {WidgetConfigCreateManyAndReturnArgs} args - Arguments to create many WidgetConfigs.
     * @example
     * // Create many WidgetConfigs
     * const widgetConfig = await prisma.widgetConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WidgetConfigs and only return the `id`
     * const widgetConfigWithIdOnly = await prisma.widgetConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WidgetConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WidgetConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WidgetConfig.
     * @param {WidgetConfigDeleteArgs} args - Arguments to delete one WidgetConfig.
     * @example
     * // Delete one WidgetConfig
     * const WidgetConfig = await prisma.widgetConfig.delete({
     *   where: {
     *     // ... filter to delete one WidgetConfig
     *   }
     * })
     * 
     */
    delete<T extends WidgetConfigDeleteArgs>(args: SelectSubset<T, WidgetConfigDeleteArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WidgetConfig.
     * @param {WidgetConfigUpdateArgs} args - Arguments to update one WidgetConfig.
     * @example
     * // Update one WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WidgetConfigUpdateArgs>(args: SelectSubset<T, WidgetConfigUpdateArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WidgetConfigs.
     * @param {WidgetConfigDeleteManyArgs} args - Arguments to filter WidgetConfigs to delete.
     * @example
     * // Delete a few WidgetConfigs
     * const { count } = await prisma.widgetConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WidgetConfigDeleteManyArgs>(args?: SelectSubset<T, WidgetConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WidgetConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WidgetConfigs
     * const widgetConfig = await prisma.widgetConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WidgetConfigUpdateManyArgs>(args: SelectSubset<T, WidgetConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WidgetConfig.
     * @param {WidgetConfigUpsertArgs} args - Arguments to update or create a WidgetConfig.
     * @example
     * // Update or create a WidgetConfig
     * const widgetConfig = await prisma.widgetConfig.upsert({
     *   create: {
     *     // ... data to create a WidgetConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WidgetConfig we want to update
     *   }
     * })
     */
    upsert<T extends WidgetConfigUpsertArgs>(args: SelectSubset<T, WidgetConfigUpsertArgs<ExtArgs>>): Prisma__WidgetConfigClient<$Result.GetResult<Prisma.$WidgetConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WidgetConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigCountArgs} args - Arguments to filter WidgetConfigs to count.
     * @example
     * // Count the number of WidgetConfigs
     * const count = await prisma.widgetConfig.count({
     *   where: {
     *     // ... the filter for the WidgetConfigs we want to count
     *   }
     * })
    **/
    count<T extends WidgetConfigCountArgs>(
      args?: Subset<T, WidgetConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WidgetConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WidgetConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WidgetConfigAggregateArgs>(args: Subset<T, WidgetConfigAggregateArgs>): Prisma.PrismaPromise<GetWidgetConfigAggregateType<T>>

    /**
     * Group by WidgetConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WidgetConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WidgetConfigGroupByArgs['orderBy'] }
        : { orderBy?: WidgetConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WidgetConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWidgetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WidgetConfig model
   */
  readonly fields: WidgetConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WidgetConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WidgetConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WidgetConfig model
   */ 
  interface WidgetConfigFieldRefs {
    readonly id: FieldRef<"WidgetConfig", 'String'>
    readonly hotelId: FieldRef<"WidgetConfig", 'String'>
    readonly primaryColor: FieldRef<"WidgetConfig", 'String'>
    readonly secondaryColor: FieldRef<"WidgetConfig", 'String'>
    readonly customCss: FieldRef<"WidgetConfig", 'String'>
    readonly showLogo: FieldRef<"WidgetConfig", 'Boolean'>
    readonly title: FieldRef<"WidgetConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WidgetConfig findUnique
   */
  export type WidgetConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter, which WidgetConfig to fetch.
     */
    where: WidgetConfigWhereUniqueInput
  }

  /**
   * WidgetConfig findUniqueOrThrow
   */
  export type WidgetConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter, which WidgetConfig to fetch.
     */
    where: WidgetConfigWhereUniqueInput
  }

  /**
   * WidgetConfig findFirst
   */
  export type WidgetConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter, which WidgetConfig to fetch.
     */
    where?: WidgetConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WidgetConfigs to fetch.
     */
    orderBy?: WidgetConfigOrderByWithRelationInput | WidgetConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WidgetConfigs.
     */
    cursor?: WidgetConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WidgetConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WidgetConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WidgetConfigs.
     */
    distinct?: WidgetConfigScalarFieldEnum | WidgetConfigScalarFieldEnum[]
  }

  /**
   * WidgetConfig findFirstOrThrow
   */
  export type WidgetConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter, which WidgetConfig to fetch.
     */
    where?: WidgetConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WidgetConfigs to fetch.
     */
    orderBy?: WidgetConfigOrderByWithRelationInput | WidgetConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WidgetConfigs.
     */
    cursor?: WidgetConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WidgetConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WidgetConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WidgetConfigs.
     */
    distinct?: WidgetConfigScalarFieldEnum | WidgetConfigScalarFieldEnum[]
  }

  /**
   * WidgetConfig findMany
   */
  export type WidgetConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter, which WidgetConfigs to fetch.
     */
    where?: WidgetConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WidgetConfigs to fetch.
     */
    orderBy?: WidgetConfigOrderByWithRelationInput | WidgetConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WidgetConfigs.
     */
    cursor?: WidgetConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WidgetConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WidgetConfigs.
     */
    skip?: number
    distinct?: WidgetConfigScalarFieldEnum | WidgetConfigScalarFieldEnum[]
  }

  /**
   * WidgetConfig create
   */
  export type WidgetConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WidgetConfig.
     */
    data: XOR<WidgetConfigCreateInput, WidgetConfigUncheckedCreateInput>
  }

  /**
   * WidgetConfig createMany
   */
  export type WidgetConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WidgetConfigs.
     */
    data: WidgetConfigCreateManyInput | WidgetConfigCreateManyInput[]
  }

  /**
   * WidgetConfig createManyAndReturn
   */
  export type WidgetConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WidgetConfigs.
     */
    data: WidgetConfigCreateManyInput | WidgetConfigCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WidgetConfig update
   */
  export type WidgetConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WidgetConfig.
     */
    data: XOR<WidgetConfigUpdateInput, WidgetConfigUncheckedUpdateInput>
    /**
     * Choose, which WidgetConfig to update.
     */
    where: WidgetConfigWhereUniqueInput
  }

  /**
   * WidgetConfig updateMany
   */
  export type WidgetConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WidgetConfigs.
     */
    data: XOR<WidgetConfigUpdateManyMutationInput, WidgetConfigUncheckedUpdateManyInput>
    /**
     * Filter which WidgetConfigs to update
     */
    where?: WidgetConfigWhereInput
  }

  /**
   * WidgetConfig upsert
   */
  export type WidgetConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WidgetConfig to update in case it exists.
     */
    where: WidgetConfigWhereUniqueInput
    /**
     * In case the WidgetConfig found by the `where` argument doesn't exist, create a new WidgetConfig with this data.
     */
    create: XOR<WidgetConfigCreateInput, WidgetConfigUncheckedCreateInput>
    /**
     * In case the WidgetConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WidgetConfigUpdateInput, WidgetConfigUncheckedUpdateInput>
  }

  /**
   * WidgetConfig delete
   */
  export type WidgetConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
    /**
     * Filter which WidgetConfig to delete.
     */
    where: WidgetConfigWhereUniqueInput
  }

  /**
   * WidgetConfig deleteMany
   */
  export type WidgetConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WidgetConfigs to delete
     */
    where?: WidgetConfigWhereInput
  }

  /**
   * WidgetConfig without action
   */
  export type WidgetConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WidgetConfig
     */
    select?: WidgetConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetConfigInclude<ExtArgs> | null
  }


  /**
   * Model RoomType
   */

  export type AggregateRoomType = {
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  export type RoomTypeAvgAggregateOutputType = {
    basePrice: Decimal | null
    capacity: number | null
  }

  export type RoomTypeSumAggregateOutputType = {
    basePrice: Decimal | null
    capacity: number | null
  }

  export type RoomTypeMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    description: string | null
    basePrice: Decimal | null
    capacity: number | null
    amenities: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTypeMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    description: string | null
    basePrice: Decimal | null
    capacity: number | null
    amenities: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTypeCountAggregateOutputType = {
    id: number
    hotelId: number
    name: number
    description: number
    basePrice: number
    capacity: number
    amenities: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomTypeAvgAggregateInputType = {
    basePrice?: true
    capacity?: true
  }

  export type RoomTypeSumAggregateInputType = {
    basePrice?: true
    capacity?: true
  }

  export type RoomTypeMinAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    basePrice?: true
    capacity?: true
    amenities?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTypeMaxAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    basePrice?: true
    capacity?: true
    amenities?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTypeCountAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    basePrice?: true
    capacity?: true
    amenities?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomType to aggregate.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypes
    **/
    _count?: true | RoomTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypeMaxAggregateInputType
  }

  export type GetRoomTypeAggregateType<T extends RoomTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomType[P]>
      : GetScalarType<T[P], AggregateRoomType[P]>
  }




  export type RoomTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithAggregationInput | RoomTypeOrderByWithAggregationInput[]
    by: RoomTypeScalarFieldEnum[] | RoomTypeScalarFieldEnum
    having?: RoomTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypeCountAggregateInputType | true
    _avg?: RoomTypeAvgAggregateInputType
    _sum?: RoomTypeSumAggregateInputType
    _min?: RoomTypeMinAggregateInputType
    _max?: RoomTypeMaxAggregateInputType
  }

  export type RoomTypeGroupByOutputType = {
    id: string
    hotelId: string
    name: string
    description: string | null
    basePrice: Decimal
    capacity: number
    amenities: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  type GetRoomTypeGroupByPayload<T extends RoomTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    capacity?: boolean
    amenities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    icalFeeds?: boolean | RoomType$icalFeedsArgs<ExtArgs>
    dailyPrices?: boolean | RoomType$dailyPricesArgs<ExtArgs>
    restrictions?: boolean | RoomType$restrictionsArgs<ExtArgs>
    channelMappings?: boolean | RoomType$channelMappingsArgs<ExtArgs>
    waitlistEntries?: boolean | RoomType$waitlistEntriesArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    capacity?: boolean
    amenities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectScalar = {
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    basePrice?: boolean
    capacity?: boolean
    amenities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    icalFeeds?: boolean | RoomType$icalFeedsArgs<ExtArgs>
    dailyPrices?: boolean | RoomType$dailyPricesArgs<ExtArgs>
    restrictions?: boolean | RoomType$restrictionsArgs<ExtArgs>
    channelMappings?: boolean | RoomType$channelMappingsArgs<ExtArgs>
    waitlistEntries?: boolean | RoomType$waitlistEntriesArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $RoomTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomType"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      icalFeeds: Prisma.$ICalFeedPayload<ExtArgs>[]
      dailyPrices: Prisma.$DailyPricePayload<ExtArgs>[]
      restrictions: Prisma.$RestrictionPayload<ExtArgs>[]
      channelMappings: Prisma.$ChannelMappingPayload<ExtArgs>[]
      waitlistEntries: Prisma.$HotelWaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      name: string
      description: string | null
      basePrice: Prisma.Decimal
      capacity: number
      amenities: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomType"]>
    composites: {}
  }

  type RoomTypeGetPayload<S extends boolean | null | undefined | RoomTypeDefaultArgs> = $Result.GetResult<Prisma.$RoomTypePayload, S>

  type RoomTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomTypeCountAggregateInputType | true
    }

  export interface RoomTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomType'], meta: { name: 'RoomType' } }
    /**
     * Find zero or one RoomType that matches the filter.
     * @param {RoomTypeFindUniqueArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomTypeFindUniqueArgs>(args: SelectSubset<T, RoomTypeFindUniqueArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoomType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomTypeFindUniqueOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoomType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomTypeFindFirstArgs>(args?: SelectSubset<T, RoomTypeFindFirstArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoomType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypes
     * const roomTypes = await prisma.roomType.findMany()
     * 
     * // Get first 10 RoomTypes
     * const roomTypes = await prisma.roomType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomTypeFindManyArgs>(args?: SelectSubset<T, RoomTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoomType.
     * @param {RoomTypeCreateArgs} args - Arguments to create a RoomType.
     * @example
     * // Create one RoomType
     * const RoomType = await prisma.roomType.create({
     *   data: {
     *     // ... data to create a RoomType
     *   }
     * })
     * 
     */
    create<T extends RoomTypeCreateArgs>(args: SelectSubset<T, RoomTypeCreateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoomTypes.
     * @param {RoomTypeCreateManyArgs} args - Arguments to create many RoomTypes.
     * @example
     * // Create many RoomTypes
     * const roomType = await prisma.roomType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomTypeCreateManyArgs>(args?: SelectSubset<T, RoomTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomTypes and returns the data saved in the database.
     * @param {RoomTypeCreateManyAndReturnArgs} args - Arguments to create many RoomTypes.
     * @example
     * // Create many RoomTypes
     * const roomType = await prisma.roomType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomTypes and only return the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoomType.
     * @param {RoomTypeDeleteArgs} args - Arguments to delete one RoomType.
     * @example
     * // Delete one RoomType
     * const RoomType = await prisma.roomType.delete({
     *   where: {
     *     // ... filter to delete one RoomType
     *   }
     * })
     * 
     */
    delete<T extends RoomTypeDeleteArgs>(args: SelectSubset<T, RoomTypeDeleteArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoomType.
     * @param {RoomTypeUpdateArgs} args - Arguments to update one RoomType.
     * @example
     * // Update one RoomType
     * const roomType = await prisma.roomType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomTypeUpdateArgs>(args: SelectSubset<T, RoomTypeUpdateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoomTypes.
     * @param {RoomTypeDeleteManyArgs} args - Arguments to filter RoomTypes to delete.
     * @example
     * // Delete a few RoomTypes
     * const { count } = await prisma.roomType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomTypeDeleteManyArgs>(args?: SelectSubset<T, RoomTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypes
     * const roomType = await prisma.roomType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomTypeUpdateManyArgs>(args: SelectSubset<T, RoomTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomType.
     * @param {RoomTypeUpsertArgs} args - Arguments to update or create a RoomType.
     * @example
     * // Update or create a RoomType
     * const roomType = await prisma.roomType.upsert({
     *   create: {
     *     // ... data to create a RoomType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomType we want to update
     *   }
     * })
     */
    upsert<T extends RoomTypeUpsertArgs>(args: SelectSubset<T, RoomTypeUpsertArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeCountArgs} args - Arguments to filter RoomTypes to count.
     * @example
     * // Count the number of RoomTypes
     * const count = await prisma.roomType.count({
     *   where: {
     *     // ... the filter for the RoomTypes we want to count
     *   }
     * })
    **/
    count<T extends RoomTypeCountArgs>(
      args?: Subset<T, RoomTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypeAggregateArgs>(args: Subset<T, RoomTypeAggregateArgs>): Prisma.PrismaPromise<GetRoomTypeAggregateType<T>>

    /**
     * Group by RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypeGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomType model
   */
  readonly fields: RoomTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rooms<T extends RoomType$roomsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    icalFeeds<T extends RoomType$icalFeedsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$icalFeedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findMany"> | Null>
    dailyPrices<T extends RoomType$dailyPricesArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$dailyPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findMany"> | Null>
    restrictions<T extends RoomType$restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$restrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany"> | Null>
    channelMappings<T extends RoomType$channelMappingsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$channelMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findMany"> | Null>
    waitlistEntries<T extends RoomType$waitlistEntriesArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$waitlistEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomType model
   */ 
  interface RoomTypeFieldRefs {
    readonly id: FieldRef<"RoomType", 'String'>
    readonly hotelId: FieldRef<"RoomType", 'String'>
    readonly name: FieldRef<"RoomType", 'String'>
    readonly description: FieldRef<"RoomType", 'String'>
    readonly basePrice: FieldRef<"RoomType", 'Decimal'>
    readonly capacity: FieldRef<"RoomType", 'Int'>
    readonly amenities: FieldRef<"RoomType", 'String'>
    readonly createdAt: FieldRef<"RoomType", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomType findUnique
   */
  export type RoomTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findUniqueOrThrow
   */
  export type RoomTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findFirst
   */
  export type RoomTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findFirstOrThrow
   */
  export type RoomTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findMany
   */
  export type RoomTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType create
   */
  export type RoomTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomType.
     */
    data: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
  }

  /**
   * RoomType createMany
   */
  export type RoomTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
  }

  /**
   * RoomType createManyAndReturn
   */
  export type RoomTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomType update
   */
  export type RoomTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomType.
     */
    data: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
    /**
     * Choose, which RoomType to update.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType updateMany
   */
  export type RoomTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypeWhereInput
  }

  /**
   * RoomType upsert
   */
  export type RoomTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomType to update in case it exists.
     */
    where: RoomTypeWhereUniqueInput
    /**
     * In case the RoomType found by the `where` argument doesn't exist, create a new RoomType with this data.
     */
    create: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
    /**
     * In case the RoomType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
  }

  /**
   * RoomType delete
   */
  export type RoomTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter which RoomType to delete.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType deleteMany
   */
  export type RoomTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to delete
     */
    where?: RoomTypeWhereInput
  }

  /**
   * RoomType.rooms
   */
  export type RoomType$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * RoomType.icalFeeds
   */
  export type RoomType$icalFeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    where?: ICalFeedWhereInput
    orderBy?: ICalFeedOrderByWithRelationInput | ICalFeedOrderByWithRelationInput[]
    cursor?: ICalFeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ICalFeedScalarFieldEnum | ICalFeedScalarFieldEnum[]
  }

  /**
   * RoomType.dailyPrices
   */
  export type RoomType$dailyPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    where?: DailyPriceWhereInput
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    cursor?: DailyPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyPriceScalarFieldEnum | DailyPriceScalarFieldEnum[]
  }

  /**
   * RoomType.restrictions
   */
  export type RoomType$restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    cursor?: RestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * RoomType.channelMappings
   */
  export type RoomType$channelMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    where?: ChannelMappingWhereInput
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    cursor?: ChannelMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * RoomType.waitlistEntries
   */
  export type RoomType$waitlistEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    where?: HotelWaitlistWhereInput
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    cursor?: HotelWaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelWaitlistScalarFieldEnum | HotelWaitlistScalarFieldEnum[]
  }

  /**
   * RoomType without action
   */
  export type RoomTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    name: string | null
    isActive: boolean | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    name: string | null
    isActive: boolean | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomTypeId: number
    name: number
    isActive: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    name?: true
    isActive?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    name?: true
    isActive?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    name?: true
    isActive?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    roomTypeId: string
    name: string
    isActive: boolean
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    name?: boolean
    isActive?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    bookingRooms?: boolean | Room$bookingRoomsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    name?: boolean
    isActive?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    name?: boolean
    isActive?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    bookingRooms?: boolean | Room$bookingRoomsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      roomType: Prisma.$RoomTypePayload<ExtArgs>
      bookingRooms: Prisma.$BookingRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomTypeId: string
      name: string
      isActive: boolean
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookingRooms<T extends Room$bookingRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Room$bookingRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly roomTypeId: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly isActive: FieldRef<"Room", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.bookingRooms
   */
  export type Room$bookingRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    where?: BookingRoomWhereInput
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    cursor?: BookingRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRoomScalarFieldEnum | BookingRoomScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Guest
   */

  export type AggregateGuest = {
    _count: GuestCountAggregateOutputType | null
    _avg: GuestAvgAggregateOutputType | null
    _sum: GuestSumAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  export type GuestAvgAggregateOutputType = {
    score: number | null
  }

  export type GuestSumAggregateOutputType = {
    score: number | null
  }

  export type GuestMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    docType: string | null
    docNumber: string | null
    country: string | null
    notes: string | null
    score: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    docType: string | null
    docNumber: string | null
    country: string | null
    notes: string | null
    score: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuestCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    docType: number
    docNumber: number
    country: number
    notes: number
    score: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuestAvgAggregateInputType = {
    score?: true
  }

  export type GuestSumAggregateInputType = {
    score?: true
  }

  export type GuestMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    docType?: true
    docNumber?: true
    country?: true
    notes?: true
    score?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    docType?: true
    docNumber?: true
    country?: true
    notes?: true
    score?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuestCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    docType?: true
    docNumber?: true
    country?: true
    notes?: true
    score?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guest to aggregate.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guests
    **/
    _count?: true | GuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestMaxAggregateInputType
  }

  export type GetGuestAggregateType<T extends GuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuest[P]>
      : GetScalarType<T[P], AggregateGuest[P]>
  }




  export type GuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestWhereInput
    orderBy?: GuestOrderByWithAggregationInput | GuestOrderByWithAggregationInput[]
    by: GuestScalarFieldEnum[] | GuestScalarFieldEnum
    having?: GuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestCountAggregateInputType | true
    _avg?: GuestAvgAggregateInputType
    _sum?: GuestSumAggregateInputType
    _min?: GuestMinAggregateInputType
    _max?: GuestMaxAggregateInputType
  }

  export type GuestGroupByOutputType = {
    id: string
    firstName: string
    lastName: string | null
    email: string | null
    phone: string | null
    docType: string | null
    docNumber: string | null
    country: string | null
    notes: string | null
    score: number
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: GuestCountAggregateOutputType | null
    _avg: GuestAvgAggregateOutputType | null
    _sum: GuestSumAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  type GetGuestGroupByPayload<T extends GuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuestGroupByOutputType[P]>
        }
      >
    >


  export type GuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    docType?: boolean
    docNumber?: boolean
    country?: boolean
    notes?: boolean
    score?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Guest$bookingsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    docType?: boolean
    docNumber?: boolean
    country?: boolean
    notes?: boolean
    score?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["guest"]>

  export type GuestSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    docType?: boolean
    docNumber?: boolean
    country?: boolean
    notes?: boolean
    score?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Guest$bookingsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guest"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string | null
      email: string | null
      phone: string | null
      docType: string | null
      docNumber: string | null
      country: string | null
      notes: string | null
      score: number
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guest"]>
    composites: {}
  }

  type GuestGetPayload<S extends boolean | null | undefined | GuestDefaultArgs> = $Result.GetResult<Prisma.$GuestPayload, S>

  type GuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GuestCountAggregateInputType | true
    }

  export interface GuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guest'], meta: { name: 'Guest' } }
    /**
     * Find zero or one Guest that matches the filter.
     * @param {GuestFindUniqueArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestFindUniqueArgs>(args: SelectSubset<T, GuestFindUniqueArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Guest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GuestFindUniqueOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Guest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestFindFirstArgs>(args?: SelectSubset<T, GuestFindFirstArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Guest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Guests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guests
     * const guests = await prisma.guest.findMany()
     * 
     * // Get first 10 Guests
     * const guests = await prisma.guest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestFindManyArgs>(args?: SelectSubset<T, GuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Guest.
     * @param {GuestCreateArgs} args - Arguments to create a Guest.
     * @example
     * // Create one Guest
     * const Guest = await prisma.guest.create({
     *   data: {
     *     // ... data to create a Guest
     *   }
     * })
     * 
     */
    create<T extends GuestCreateArgs>(args: SelectSubset<T, GuestCreateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Guests.
     * @param {GuestCreateManyArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestCreateManyArgs>(args?: SelectSubset<T, GuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guests and returns the data saved in the database.
     * @param {GuestCreateManyAndReturnArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuestCreateManyAndReturnArgs>(args?: SelectSubset<T, GuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Guest.
     * @param {GuestDeleteArgs} args - Arguments to delete one Guest.
     * @example
     * // Delete one Guest
     * const Guest = await prisma.guest.delete({
     *   where: {
     *     // ... filter to delete one Guest
     *   }
     * })
     * 
     */
    delete<T extends GuestDeleteArgs>(args: SelectSubset<T, GuestDeleteArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Guest.
     * @param {GuestUpdateArgs} args - Arguments to update one Guest.
     * @example
     * // Update one Guest
     * const guest = await prisma.guest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestUpdateArgs>(args: SelectSubset<T, GuestUpdateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Guests.
     * @param {GuestDeleteManyArgs} args - Arguments to filter Guests to delete.
     * @example
     * // Delete a few Guests
     * const { count } = await prisma.guest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestDeleteManyArgs>(args?: SelectSubset<T, GuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestUpdateManyArgs>(args: SelectSubset<T, GuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guest.
     * @param {GuestUpsertArgs} args - Arguments to update or create a Guest.
     * @example
     * // Update or create a Guest
     * const guest = await prisma.guest.upsert({
     *   create: {
     *     // ... data to create a Guest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guest we want to update
     *   }
     * })
     */
    upsert<T extends GuestUpsertArgs>(args: SelectSubset<T, GuestUpsertArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestCountArgs} args - Arguments to filter Guests to count.
     * @example
     * // Count the number of Guests
     * const count = await prisma.guest.count({
     *   where: {
     *     // ... the filter for the Guests we want to count
     *   }
     * })
    **/
    count<T extends GuestCountArgs>(
      args?: Subset<T, GuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestAggregateArgs>(args: Subset<T, GuestAggregateArgs>): Prisma.PrismaPromise<GetGuestAggregateType<T>>

    /**
     * Group by Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestGroupByArgs['orderBy'] }
        : { orderBy?: GuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guest model
   */
  readonly fields: GuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Guest$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Guest$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guest model
   */ 
  interface GuestFieldRefs {
    readonly id: FieldRef<"Guest", 'String'>
    readonly firstName: FieldRef<"Guest", 'String'>
    readonly lastName: FieldRef<"Guest", 'String'>
    readonly email: FieldRef<"Guest", 'String'>
    readonly phone: FieldRef<"Guest", 'String'>
    readonly docType: FieldRef<"Guest", 'String'>
    readonly docNumber: FieldRef<"Guest", 'String'>
    readonly country: FieldRef<"Guest", 'String'>
    readonly notes: FieldRef<"Guest", 'String'>
    readonly score: FieldRef<"Guest", 'Int'>
    readonly tags: FieldRef<"Guest", 'String'>
    readonly createdAt: FieldRef<"Guest", 'DateTime'>
    readonly updatedAt: FieldRef<"Guest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guest findUnique
   */
  export type GuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findUniqueOrThrow
   */
  export type GuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findFirst
   */
  export type GuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findFirstOrThrow
   */
  export type GuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findMany
   */
  export type GuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guests to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest create
   */
  export type GuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Guest.
     */
    data: XOR<GuestCreateInput, GuestUncheckedCreateInput>
  }

  /**
   * Guest createMany
   */
  export type GuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
  }

  /**
   * Guest createManyAndReturn
   */
  export type GuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
  }

  /**
   * Guest update
   */
  export type GuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Guest.
     */
    data: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
    /**
     * Choose, which Guest to update.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest updateMany
   */
  export type GuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
  }

  /**
   * Guest upsert
   */
  export type GuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Guest to update in case it exists.
     */
    where: GuestWhereUniqueInput
    /**
     * In case the Guest found by the `where` argument doesn't exist, create a new Guest with this data.
     */
    create: XOR<GuestCreateInput, GuestUncheckedCreateInput>
    /**
     * In case the Guest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
  }

  /**
   * Guest delete
   */
  export type GuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter which Guest to delete.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest deleteMany
   */
  export type GuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guests to delete
     */
    where?: GuestWhereInput
  }

  /**
   * Guest.bookings
   */
  export type Guest$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Guest without action
   */
  export type GuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
  }


  /**
   * Model RatePlan
   */

  export type AggregateRatePlan = {
    _count: RatePlanCountAggregateOutputType | null
    _avg: RatePlanAvgAggregateOutputType | null
    _sum: RatePlanSumAggregateOutputType | null
    _min: RatePlanMinAggregateOutputType | null
    _max: RatePlanMaxAggregateOutputType | null
  }

  export type RatePlanAvgAggregateOutputType = {
    noShowFee: Decimal | null
  }

  export type RatePlanSumAggregateOutputType = {
    noShowFee: Decimal | null
  }

  export type RatePlanMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    cancellationPolicy: string | null
    mealsIncluded: string | null
    requireCreditCard: boolean | null
    noShowFee: Decimal | null
  }

  export type RatePlanMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    description: string | null
    isDefault: boolean | null
    cancellationPolicy: string | null
    mealsIncluded: string | null
    requireCreditCard: boolean | null
    noShowFee: Decimal | null
  }

  export type RatePlanCountAggregateOutputType = {
    id: number
    hotelId: number
    name: number
    description: number
    isDefault: number
    cancellationPolicy: number
    mealsIncluded: number
    requireCreditCard: number
    noShowFee: number
    _all: number
  }


  export type RatePlanAvgAggregateInputType = {
    noShowFee?: true
  }

  export type RatePlanSumAggregateInputType = {
    noShowFee?: true
  }

  export type RatePlanMinAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    isDefault?: true
    cancellationPolicy?: true
    mealsIncluded?: true
    requireCreditCard?: true
    noShowFee?: true
  }

  export type RatePlanMaxAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    isDefault?: true
    cancellationPolicy?: true
    mealsIncluded?: true
    requireCreditCard?: true
    noShowFee?: true
  }

  export type RatePlanCountAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    isDefault?: true
    cancellationPolicy?: true
    mealsIncluded?: true
    requireCreditCard?: true
    noShowFee?: true
    _all?: true
  }

  export type RatePlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RatePlan to aggregate.
     */
    where?: RatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RatePlans to fetch.
     */
    orderBy?: RatePlanOrderByWithRelationInput | RatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RatePlans
    **/
    _count?: true | RatePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatePlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatePlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatePlanMaxAggregateInputType
  }

  export type GetRatePlanAggregateType<T extends RatePlanAggregateArgs> = {
        [P in keyof T & keyof AggregateRatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRatePlan[P]>
      : GetScalarType<T[P], AggregateRatePlan[P]>
  }




  export type RatePlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatePlanWhereInput
    orderBy?: RatePlanOrderByWithAggregationInput | RatePlanOrderByWithAggregationInput[]
    by: RatePlanScalarFieldEnum[] | RatePlanScalarFieldEnum
    having?: RatePlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatePlanCountAggregateInputType | true
    _avg?: RatePlanAvgAggregateInputType
    _sum?: RatePlanSumAggregateInputType
    _min?: RatePlanMinAggregateInputType
    _max?: RatePlanMaxAggregateInputType
  }

  export type RatePlanGroupByOutputType = {
    id: string
    hotelId: string
    name: string
    description: string | null
    isDefault: boolean
    cancellationPolicy: string | null
    mealsIncluded: string | null
    requireCreditCard: boolean
    noShowFee: Decimal
    _count: RatePlanCountAggregateOutputType | null
    _avg: RatePlanAvgAggregateOutputType | null
    _sum: RatePlanSumAggregateOutputType | null
    _min: RatePlanMinAggregateOutputType | null
    _max: RatePlanMaxAggregateOutputType | null
  }

  type GetRatePlanGroupByPayload<T extends RatePlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatePlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatePlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatePlanGroupByOutputType[P]>
            : GetScalarType<T[P], RatePlanGroupByOutputType[P]>
        }
      >
    >


  export type RatePlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    cancellationPolicy?: boolean
    mealsIncluded?: boolean
    requireCreditCard?: boolean
    noShowFee?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    dailyPrices?: boolean | RatePlan$dailyPricesArgs<ExtArgs>
    restrictions?: boolean | RatePlan$restrictionsArgs<ExtArgs>
    channelMappings?: boolean | RatePlan$channelMappingsArgs<ExtArgs>
    _count?: boolean | RatePlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ratePlan"]>

  export type RatePlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    cancellationPolicy?: boolean
    mealsIncluded?: boolean
    requireCreditCard?: boolean
    noShowFee?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ratePlan"]>

  export type RatePlanSelectScalar = {
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    isDefault?: boolean
    cancellationPolicy?: boolean
    mealsIncluded?: boolean
    requireCreditCard?: boolean
    noShowFee?: boolean
  }

  export type RatePlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    dailyPrices?: boolean | RatePlan$dailyPricesArgs<ExtArgs>
    restrictions?: boolean | RatePlan$restrictionsArgs<ExtArgs>
    channelMappings?: boolean | RatePlan$channelMappingsArgs<ExtArgs>
    _count?: boolean | RatePlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RatePlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $RatePlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RatePlan"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      dailyPrices: Prisma.$DailyPricePayload<ExtArgs>[]
      restrictions: Prisma.$RestrictionPayload<ExtArgs>[]
      channelMappings: Prisma.$ChannelMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      name: string
      description: string | null
      isDefault: boolean
      cancellationPolicy: string | null
      mealsIncluded: string | null
      requireCreditCard: boolean
      noShowFee: Prisma.Decimal
    }, ExtArgs["result"]["ratePlan"]>
    composites: {}
  }

  type RatePlanGetPayload<S extends boolean | null | undefined | RatePlanDefaultArgs> = $Result.GetResult<Prisma.$RatePlanPayload, S>

  type RatePlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RatePlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatePlanCountAggregateInputType | true
    }

  export interface RatePlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RatePlan'], meta: { name: 'RatePlan' } }
    /**
     * Find zero or one RatePlan that matches the filter.
     * @param {RatePlanFindUniqueArgs} args - Arguments to find a RatePlan
     * @example
     * // Get one RatePlan
     * const ratePlan = await prisma.ratePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatePlanFindUniqueArgs>(args: SelectSubset<T, RatePlanFindUniqueArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RatePlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RatePlanFindUniqueOrThrowArgs} args - Arguments to find a RatePlan
     * @example
     * // Get one RatePlan
     * const ratePlan = await prisma.ratePlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatePlanFindUniqueOrThrowArgs>(args: SelectSubset<T, RatePlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RatePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanFindFirstArgs} args - Arguments to find a RatePlan
     * @example
     * // Get one RatePlan
     * const ratePlan = await prisma.ratePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatePlanFindFirstArgs>(args?: SelectSubset<T, RatePlanFindFirstArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RatePlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanFindFirstOrThrowArgs} args - Arguments to find a RatePlan
     * @example
     * // Get one RatePlan
     * const ratePlan = await prisma.ratePlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatePlanFindFirstOrThrowArgs>(args?: SelectSubset<T, RatePlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RatePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RatePlans
     * const ratePlans = await prisma.ratePlan.findMany()
     * 
     * // Get first 10 RatePlans
     * const ratePlans = await prisma.ratePlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratePlanWithIdOnly = await prisma.ratePlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatePlanFindManyArgs>(args?: SelectSubset<T, RatePlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RatePlan.
     * @param {RatePlanCreateArgs} args - Arguments to create a RatePlan.
     * @example
     * // Create one RatePlan
     * const RatePlan = await prisma.ratePlan.create({
     *   data: {
     *     // ... data to create a RatePlan
     *   }
     * })
     * 
     */
    create<T extends RatePlanCreateArgs>(args: SelectSubset<T, RatePlanCreateArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RatePlans.
     * @param {RatePlanCreateManyArgs} args - Arguments to create many RatePlans.
     * @example
     * // Create many RatePlans
     * const ratePlan = await prisma.ratePlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatePlanCreateManyArgs>(args?: SelectSubset<T, RatePlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RatePlans and returns the data saved in the database.
     * @param {RatePlanCreateManyAndReturnArgs} args - Arguments to create many RatePlans.
     * @example
     * // Create many RatePlans
     * const ratePlan = await prisma.ratePlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RatePlans and only return the `id`
     * const ratePlanWithIdOnly = await prisma.ratePlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatePlanCreateManyAndReturnArgs>(args?: SelectSubset<T, RatePlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RatePlan.
     * @param {RatePlanDeleteArgs} args - Arguments to delete one RatePlan.
     * @example
     * // Delete one RatePlan
     * const RatePlan = await prisma.ratePlan.delete({
     *   where: {
     *     // ... filter to delete one RatePlan
     *   }
     * })
     * 
     */
    delete<T extends RatePlanDeleteArgs>(args: SelectSubset<T, RatePlanDeleteArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RatePlan.
     * @param {RatePlanUpdateArgs} args - Arguments to update one RatePlan.
     * @example
     * // Update one RatePlan
     * const ratePlan = await prisma.ratePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatePlanUpdateArgs>(args: SelectSubset<T, RatePlanUpdateArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RatePlans.
     * @param {RatePlanDeleteManyArgs} args - Arguments to filter RatePlans to delete.
     * @example
     * // Delete a few RatePlans
     * const { count } = await prisma.ratePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatePlanDeleteManyArgs>(args?: SelectSubset<T, RatePlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RatePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RatePlans
     * const ratePlan = await prisma.ratePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatePlanUpdateManyArgs>(args: SelectSubset<T, RatePlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RatePlan.
     * @param {RatePlanUpsertArgs} args - Arguments to update or create a RatePlan.
     * @example
     * // Update or create a RatePlan
     * const ratePlan = await prisma.ratePlan.upsert({
     *   create: {
     *     // ... data to create a RatePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RatePlan we want to update
     *   }
     * })
     */
    upsert<T extends RatePlanUpsertArgs>(args: SelectSubset<T, RatePlanUpsertArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RatePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanCountArgs} args - Arguments to filter RatePlans to count.
     * @example
     * // Count the number of RatePlans
     * const count = await prisma.ratePlan.count({
     *   where: {
     *     // ... the filter for the RatePlans we want to count
     *   }
     * })
    **/
    count<T extends RatePlanCountArgs>(
      args?: Subset<T, RatePlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RatePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatePlanAggregateArgs>(args: Subset<T, RatePlanAggregateArgs>): Prisma.PrismaPromise<GetRatePlanAggregateType<T>>

    /**
     * Group by RatePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatePlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatePlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatePlanGroupByArgs['orderBy'] }
        : { orderBy?: RatePlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatePlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatePlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RatePlan model
   */
  readonly fields: RatePlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RatePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatePlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dailyPrices<T extends RatePlan$dailyPricesArgs<ExtArgs> = {}>(args?: Subset<T, RatePlan$dailyPricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findMany"> | Null>
    restrictions<T extends RatePlan$restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, RatePlan$restrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany"> | Null>
    channelMappings<T extends RatePlan$channelMappingsArgs<ExtArgs> = {}>(args?: Subset<T, RatePlan$channelMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RatePlan model
   */ 
  interface RatePlanFieldRefs {
    readonly id: FieldRef<"RatePlan", 'String'>
    readonly hotelId: FieldRef<"RatePlan", 'String'>
    readonly name: FieldRef<"RatePlan", 'String'>
    readonly description: FieldRef<"RatePlan", 'String'>
    readonly isDefault: FieldRef<"RatePlan", 'Boolean'>
    readonly cancellationPolicy: FieldRef<"RatePlan", 'String'>
    readonly mealsIncluded: FieldRef<"RatePlan", 'String'>
    readonly requireCreditCard: FieldRef<"RatePlan", 'Boolean'>
    readonly noShowFee: FieldRef<"RatePlan", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * RatePlan findUnique
   */
  export type RatePlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter, which RatePlan to fetch.
     */
    where: RatePlanWhereUniqueInput
  }

  /**
   * RatePlan findUniqueOrThrow
   */
  export type RatePlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter, which RatePlan to fetch.
     */
    where: RatePlanWhereUniqueInput
  }

  /**
   * RatePlan findFirst
   */
  export type RatePlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter, which RatePlan to fetch.
     */
    where?: RatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RatePlans to fetch.
     */
    orderBy?: RatePlanOrderByWithRelationInput | RatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RatePlans.
     */
    cursor?: RatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RatePlans.
     */
    distinct?: RatePlanScalarFieldEnum | RatePlanScalarFieldEnum[]
  }

  /**
   * RatePlan findFirstOrThrow
   */
  export type RatePlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter, which RatePlan to fetch.
     */
    where?: RatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RatePlans to fetch.
     */
    orderBy?: RatePlanOrderByWithRelationInput | RatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RatePlans.
     */
    cursor?: RatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RatePlans.
     */
    distinct?: RatePlanScalarFieldEnum | RatePlanScalarFieldEnum[]
  }

  /**
   * RatePlan findMany
   */
  export type RatePlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter, which RatePlans to fetch.
     */
    where?: RatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RatePlans to fetch.
     */
    orderBy?: RatePlanOrderByWithRelationInput | RatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RatePlans.
     */
    cursor?: RatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RatePlans.
     */
    skip?: number
    distinct?: RatePlanScalarFieldEnum | RatePlanScalarFieldEnum[]
  }

  /**
   * RatePlan create
   */
  export type RatePlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * The data needed to create a RatePlan.
     */
    data: XOR<RatePlanCreateInput, RatePlanUncheckedCreateInput>
  }

  /**
   * RatePlan createMany
   */
  export type RatePlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RatePlans.
     */
    data: RatePlanCreateManyInput | RatePlanCreateManyInput[]
  }

  /**
   * RatePlan createManyAndReturn
   */
  export type RatePlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RatePlans.
     */
    data: RatePlanCreateManyInput | RatePlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RatePlan update
   */
  export type RatePlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * The data needed to update a RatePlan.
     */
    data: XOR<RatePlanUpdateInput, RatePlanUncheckedUpdateInput>
    /**
     * Choose, which RatePlan to update.
     */
    where: RatePlanWhereUniqueInput
  }

  /**
   * RatePlan updateMany
   */
  export type RatePlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RatePlans.
     */
    data: XOR<RatePlanUpdateManyMutationInput, RatePlanUncheckedUpdateManyInput>
    /**
     * Filter which RatePlans to update
     */
    where?: RatePlanWhereInput
  }

  /**
   * RatePlan upsert
   */
  export type RatePlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * The filter to search for the RatePlan to update in case it exists.
     */
    where: RatePlanWhereUniqueInput
    /**
     * In case the RatePlan found by the `where` argument doesn't exist, create a new RatePlan with this data.
     */
    create: XOR<RatePlanCreateInput, RatePlanUncheckedCreateInput>
    /**
     * In case the RatePlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatePlanUpdateInput, RatePlanUncheckedUpdateInput>
  }

  /**
   * RatePlan delete
   */
  export type RatePlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    /**
     * Filter which RatePlan to delete.
     */
    where: RatePlanWhereUniqueInput
  }

  /**
   * RatePlan deleteMany
   */
  export type RatePlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RatePlans to delete
     */
    where?: RatePlanWhereInput
  }

  /**
   * RatePlan.dailyPrices
   */
  export type RatePlan$dailyPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    where?: DailyPriceWhereInput
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    cursor?: DailyPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyPriceScalarFieldEnum | DailyPriceScalarFieldEnum[]
  }

  /**
   * RatePlan.restrictions
   */
  export type RatePlan$restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    cursor?: RestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * RatePlan.channelMappings
   */
  export type RatePlan$channelMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    where?: ChannelMappingWhereInput
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    cursor?: ChannelMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * RatePlan without action
   */
  export type RatePlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    priceMultiplier: Decimal | null
  }

  export type SeasonSumAggregateOutputType = {
    priceMultiplier: Decimal | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    priceMultiplier: Decimal | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    priceMultiplier: Decimal | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    hotelId: number
    name: number
    startDate: number
    endDate: number
    priceMultiplier: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    priceMultiplier?: true
  }

  export type SeasonSumAggregateInputType = {
    priceMultiplier?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    startDate?: true
    endDate?: true
    priceMultiplier?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    startDate?: true
    endDate?: true
    priceMultiplier?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    startDate?: true
    endDate?: true
    priceMultiplier?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    hotelId: string
    name: string
    startDate: Date
    endDate: Date
    priceMultiplier: Decimal
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    priceMultiplier?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    priceMultiplier?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    hotelId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    priceMultiplier?: boolean
  }

  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      name: string
      startDate: Date
      endDate: Date
      priceMultiplier: Prisma.Decimal
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */ 
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly hotelId: FieldRef<"Season", 'String'>
    readonly name: FieldRef<"Season", 'String'>
    readonly startDate: FieldRef<"Season", 'DateTime'>
    readonly endDate: FieldRef<"Season", 'DateTime'>
    readonly priceMultiplier: FieldRef<"Season", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model DailyPrice
   */

  export type AggregateDailyPrice = {
    _count: DailyPriceCountAggregateOutputType | null
    _avg: DailyPriceAvgAggregateOutputType | null
    _sum: DailyPriceSumAggregateOutputType | null
    _min: DailyPriceMinAggregateOutputType | null
    _max: DailyPriceMaxAggregateOutputType | null
  }

  export type DailyPriceAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type DailyPriceSumAggregateOutputType = {
    price: Decimal | null
  }

  export type DailyPriceMinAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    date: Date | null
    price: Decimal | null
  }

  export type DailyPriceMaxAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    date: Date | null
    price: Decimal | null
  }

  export type DailyPriceCountAggregateOutputType = {
    id: number
    roomTypeId: number
    ratePlanId: number
    date: number
    price: number
    _all: number
  }


  export type DailyPriceAvgAggregateInputType = {
    price?: true
  }

  export type DailyPriceSumAggregateInputType = {
    price?: true
  }

  export type DailyPriceMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    price?: true
  }

  export type DailyPriceMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    price?: true
  }

  export type DailyPriceCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    price?: true
    _all?: true
  }

  export type DailyPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyPrice to aggregate.
     */
    where?: DailyPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyPrices to fetch.
     */
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyPrices
    **/
    _count?: true | DailyPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyPriceMaxAggregateInputType
  }

  export type GetDailyPriceAggregateType<T extends DailyPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyPrice[P]>
      : GetScalarType<T[P], AggregateDailyPrice[P]>
  }




  export type DailyPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyPriceWhereInput
    orderBy?: DailyPriceOrderByWithAggregationInput | DailyPriceOrderByWithAggregationInput[]
    by: DailyPriceScalarFieldEnum[] | DailyPriceScalarFieldEnum
    having?: DailyPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyPriceCountAggregateInputType | true
    _avg?: DailyPriceAvgAggregateInputType
    _sum?: DailyPriceSumAggregateInputType
    _min?: DailyPriceMinAggregateInputType
    _max?: DailyPriceMaxAggregateInputType
  }

  export type DailyPriceGroupByOutputType = {
    id: string
    roomTypeId: string
    ratePlanId: string
    date: Date
    price: Decimal
    _count: DailyPriceCountAggregateOutputType | null
    _avg: DailyPriceAvgAggregateOutputType | null
    _sum: DailyPriceSumAggregateOutputType | null
    _min: DailyPriceMinAggregateOutputType | null
    _max: DailyPriceMaxAggregateOutputType | null
  }

  type GetDailyPriceGroupByPayload<T extends DailyPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyPriceGroupByOutputType[P]>
            : GetScalarType<T[P], DailyPriceGroupByOutputType[P]>
        }
      >
    >


  export type DailyPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    price?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | RatePlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyPrice"]>

  export type DailyPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    price?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | RatePlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyPrice"]>

  export type DailyPriceSelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    price?: boolean
  }

  export type DailyPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | RatePlanDefaultArgs<ExtArgs>
  }
  export type DailyPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | RatePlanDefaultArgs<ExtArgs>
  }

  export type $DailyPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyPrice"
    objects: {
      roomType: Prisma.$RoomTypePayload<ExtArgs>
      ratePlan: Prisma.$RatePlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomTypeId: string
      ratePlanId: string
      date: Date
      price: Prisma.Decimal
    }, ExtArgs["result"]["dailyPrice"]>
    composites: {}
  }

  type DailyPriceGetPayload<S extends boolean | null | undefined | DailyPriceDefaultArgs> = $Result.GetResult<Prisma.$DailyPricePayload, S>

  type DailyPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyPriceCountAggregateInputType | true
    }

  export interface DailyPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyPrice'], meta: { name: 'DailyPrice' } }
    /**
     * Find zero or one DailyPrice that matches the filter.
     * @param {DailyPriceFindUniqueArgs} args - Arguments to find a DailyPrice
     * @example
     * // Get one DailyPrice
     * const dailyPrice = await prisma.dailyPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyPriceFindUniqueArgs>(args: SelectSubset<T, DailyPriceFindUniqueArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyPriceFindUniqueOrThrowArgs} args - Arguments to find a DailyPrice
     * @example
     * // Get one DailyPrice
     * const dailyPrice = await prisma.dailyPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceFindFirstArgs} args - Arguments to find a DailyPrice
     * @example
     * // Get one DailyPrice
     * const dailyPrice = await prisma.dailyPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyPriceFindFirstArgs>(args?: SelectSubset<T, DailyPriceFindFirstArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceFindFirstOrThrowArgs} args - Arguments to find a DailyPrice
     * @example
     * // Get one DailyPrice
     * const dailyPrice = await prisma.dailyPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyPrices
     * const dailyPrices = await prisma.dailyPrice.findMany()
     * 
     * // Get first 10 DailyPrices
     * const dailyPrices = await prisma.dailyPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyPriceWithIdOnly = await prisma.dailyPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyPriceFindManyArgs>(args?: SelectSubset<T, DailyPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyPrice.
     * @param {DailyPriceCreateArgs} args - Arguments to create a DailyPrice.
     * @example
     * // Create one DailyPrice
     * const DailyPrice = await prisma.dailyPrice.create({
     *   data: {
     *     // ... data to create a DailyPrice
     *   }
     * })
     * 
     */
    create<T extends DailyPriceCreateArgs>(args: SelectSubset<T, DailyPriceCreateArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyPrices.
     * @param {DailyPriceCreateManyArgs} args - Arguments to create many DailyPrices.
     * @example
     * // Create many DailyPrices
     * const dailyPrice = await prisma.dailyPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyPriceCreateManyArgs>(args?: SelectSubset<T, DailyPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyPrices and returns the data saved in the database.
     * @param {DailyPriceCreateManyAndReturnArgs} args - Arguments to create many DailyPrices.
     * @example
     * // Create many DailyPrices
     * const dailyPrice = await prisma.dailyPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyPrices and only return the `id`
     * const dailyPriceWithIdOnly = await prisma.dailyPrice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyPrice.
     * @param {DailyPriceDeleteArgs} args - Arguments to delete one DailyPrice.
     * @example
     * // Delete one DailyPrice
     * const DailyPrice = await prisma.dailyPrice.delete({
     *   where: {
     *     // ... filter to delete one DailyPrice
     *   }
     * })
     * 
     */
    delete<T extends DailyPriceDeleteArgs>(args: SelectSubset<T, DailyPriceDeleteArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyPrice.
     * @param {DailyPriceUpdateArgs} args - Arguments to update one DailyPrice.
     * @example
     * // Update one DailyPrice
     * const dailyPrice = await prisma.dailyPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyPriceUpdateArgs>(args: SelectSubset<T, DailyPriceUpdateArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyPrices.
     * @param {DailyPriceDeleteManyArgs} args - Arguments to filter DailyPrices to delete.
     * @example
     * // Delete a few DailyPrices
     * const { count } = await prisma.dailyPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyPriceDeleteManyArgs>(args?: SelectSubset<T, DailyPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyPrices
     * const dailyPrice = await prisma.dailyPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyPriceUpdateManyArgs>(args: SelectSubset<T, DailyPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyPrice.
     * @param {DailyPriceUpsertArgs} args - Arguments to update or create a DailyPrice.
     * @example
     * // Update or create a DailyPrice
     * const dailyPrice = await prisma.dailyPrice.upsert({
     *   create: {
     *     // ... data to create a DailyPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyPrice we want to update
     *   }
     * })
     */
    upsert<T extends DailyPriceUpsertArgs>(args: SelectSubset<T, DailyPriceUpsertArgs<ExtArgs>>): Prisma__DailyPriceClient<$Result.GetResult<Prisma.$DailyPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceCountArgs} args - Arguments to filter DailyPrices to count.
     * @example
     * // Count the number of DailyPrices
     * const count = await prisma.dailyPrice.count({
     *   where: {
     *     // ... the filter for the DailyPrices we want to count
     *   }
     * })
    **/
    count<T extends DailyPriceCountArgs>(
      args?: Subset<T, DailyPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyPriceAggregateArgs>(args: Subset<T, DailyPriceAggregateArgs>): Prisma.PrismaPromise<GetDailyPriceAggregateType<T>>

    /**
     * Group by DailyPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyPriceGroupByArgs['orderBy'] }
        : { orderBy?: DailyPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyPrice model
   */
  readonly fields: DailyPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ratePlan<T extends RatePlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RatePlanDefaultArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyPrice model
   */ 
  interface DailyPriceFieldRefs {
    readonly id: FieldRef<"DailyPrice", 'String'>
    readonly roomTypeId: FieldRef<"DailyPrice", 'String'>
    readonly ratePlanId: FieldRef<"DailyPrice", 'String'>
    readonly date: FieldRef<"DailyPrice", 'DateTime'>
    readonly price: FieldRef<"DailyPrice", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * DailyPrice findUnique
   */
  export type DailyPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter, which DailyPrice to fetch.
     */
    where: DailyPriceWhereUniqueInput
  }

  /**
   * DailyPrice findUniqueOrThrow
   */
  export type DailyPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter, which DailyPrice to fetch.
     */
    where: DailyPriceWhereUniqueInput
  }

  /**
   * DailyPrice findFirst
   */
  export type DailyPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter, which DailyPrice to fetch.
     */
    where?: DailyPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyPrices to fetch.
     */
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyPrices.
     */
    cursor?: DailyPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyPrices.
     */
    distinct?: DailyPriceScalarFieldEnum | DailyPriceScalarFieldEnum[]
  }

  /**
   * DailyPrice findFirstOrThrow
   */
  export type DailyPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter, which DailyPrice to fetch.
     */
    where?: DailyPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyPrices to fetch.
     */
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyPrices.
     */
    cursor?: DailyPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyPrices.
     */
    distinct?: DailyPriceScalarFieldEnum | DailyPriceScalarFieldEnum[]
  }

  /**
   * DailyPrice findMany
   */
  export type DailyPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter, which DailyPrices to fetch.
     */
    where?: DailyPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyPrices to fetch.
     */
    orderBy?: DailyPriceOrderByWithRelationInput | DailyPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyPrices.
     */
    cursor?: DailyPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyPrices.
     */
    skip?: number
    distinct?: DailyPriceScalarFieldEnum | DailyPriceScalarFieldEnum[]
  }

  /**
   * DailyPrice create
   */
  export type DailyPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyPrice.
     */
    data: XOR<DailyPriceCreateInput, DailyPriceUncheckedCreateInput>
  }

  /**
   * DailyPrice createMany
   */
  export type DailyPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyPrices.
     */
    data: DailyPriceCreateManyInput | DailyPriceCreateManyInput[]
  }

  /**
   * DailyPrice createManyAndReturn
   */
  export type DailyPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyPrices.
     */
    data: DailyPriceCreateManyInput | DailyPriceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyPrice update
   */
  export type DailyPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyPrice.
     */
    data: XOR<DailyPriceUpdateInput, DailyPriceUncheckedUpdateInput>
    /**
     * Choose, which DailyPrice to update.
     */
    where: DailyPriceWhereUniqueInput
  }

  /**
   * DailyPrice updateMany
   */
  export type DailyPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyPrices.
     */
    data: XOR<DailyPriceUpdateManyMutationInput, DailyPriceUncheckedUpdateManyInput>
    /**
     * Filter which DailyPrices to update
     */
    where?: DailyPriceWhereInput
  }

  /**
   * DailyPrice upsert
   */
  export type DailyPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyPrice to update in case it exists.
     */
    where: DailyPriceWhereUniqueInput
    /**
     * In case the DailyPrice found by the `where` argument doesn't exist, create a new DailyPrice with this data.
     */
    create: XOR<DailyPriceCreateInput, DailyPriceUncheckedCreateInput>
    /**
     * In case the DailyPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyPriceUpdateInput, DailyPriceUncheckedUpdateInput>
  }

  /**
   * DailyPrice delete
   */
  export type DailyPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
    /**
     * Filter which DailyPrice to delete.
     */
    where: DailyPriceWhereUniqueInput
  }

  /**
   * DailyPrice deleteMany
   */
  export type DailyPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyPrices to delete
     */
    where?: DailyPriceWhereInput
  }

  /**
   * DailyPrice without action
   */
  export type DailyPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyPrice
     */
    select?: DailyPriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyPriceInclude<ExtArgs> | null
  }


  /**
   * Model Restriction
   */

  export type AggregateRestriction = {
    _count: RestrictionCountAggregateOutputType | null
    _avg: RestrictionAvgAggregateOutputType | null
    _sum: RestrictionSumAggregateOutputType | null
    _min: RestrictionMinAggregateOutputType | null
    _max: RestrictionMaxAggregateOutputType | null
  }

  export type RestrictionAvgAggregateOutputType = {
    minStay: number | null
    maxStay: number | null
  }

  export type RestrictionSumAggregateOutputType = {
    minStay: number | null
    maxStay: number | null
  }

  export type RestrictionMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    date: Date | null
    minStay: number | null
    maxStay: number | null
    closedToArrival: boolean | null
    closedToDeparture: boolean | null
    stopSell: boolean | null
  }

  export type RestrictionMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    date: Date | null
    minStay: number | null
    maxStay: number | null
    closedToArrival: boolean | null
    closedToDeparture: boolean | null
    stopSell: boolean | null
  }

  export type RestrictionCountAggregateOutputType = {
    id: number
    hotelId: number
    roomTypeId: number
    ratePlanId: number
    date: number
    minStay: number
    maxStay: number
    closedToArrival: number
    closedToDeparture: number
    stopSell: number
    _all: number
  }


  export type RestrictionAvgAggregateInputType = {
    minStay?: true
    maxStay?: true
  }

  export type RestrictionSumAggregateInputType = {
    minStay?: true
    maxStay?: true
  }

  export type RestrictionMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    minStay?: true
    maxStay?: true
    closedToArrival?: true
    closedToDeparture?: true
    stopSell?: true
  }

  export type RestrictionMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    minStay?: true
    maxStay?: true
    closedToArrival?: true
    closedToDeparture?: true
    stopSell?: true
  }

  export type RestrictionCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    ratePlanId?: true
    date?: true
    minStay?: true
    maxStay?: true
    closedToArrival?: true
    closedToDeparture?: true
    stopSell?: true
    _all?: true
  }

  export type RestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restriction to aggregate.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restrictions
    **/
    _count?: true | RestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestrictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestrictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestrictionMaxAggregateInputType
  }

  export type GetRestrictionAggregateType<T extends RestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestriction[P]>
      : GetScalarType<T[P], AggregateRestriction[P]>
  }




  export type RestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithAggregationInput | RestrictionOrderByWithAggregationInput[]
    by: RestrictionScalarFieldEnum[] | RestrictionScalarFieldEnum
    having?: RestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestrictionCountAggregateInputType | true
    _avg?: RestrictionAvgAggregateInputType
    _sum?: RestrictionSumAggregateInputType
    _min?: RestrictionMinAggregateInputType
    _max?: RestrictionMaxAggregateInputType
  }

  export type RestrictionGroupByOutputType = {
    id: string
    hotelId: string
    roomTypeId: string | null
    ratePlanId: string | null
    date: Date
    minStay: number | null
    maxStay: number | null
    closedToArrival: boolean
    closedToDeparture: boolean
    stopSell: boolean
    _count: RestrictionCountAggregateOutputType | null
    _avg: RestrictionAvgAggregateOutputType | null
    _sum: RestrictionSumAggregateOutputType | null
    _min: RestrictionMinAggregateOutputType | null
    _max: RestrictionMaxAggregateOutputType | null
  }

  type GetRestrictionGroupByPayload<T extends RestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], RestrictionGroupByOutputType[P]>
        }
      >
    >


  export type RestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    minStay?: boolean
    maxStay?: boolean
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | Restriction$roomTypeArgs<ExtArgs>
    ratePlan?: boolean | Restriction$ratePlanArgs<ExtArgs>
  }, ExtArgs["result"]["restriction"]>

  export type RestrictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    minStay?: boolean
    maxStay?: boolean
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | Restriction$roomTypeArgs<ExtArgs>
    ratePlan?: boolean | Restriction$ratePlanArgs<ExtArgs>
  }, ExtArgs["result"]["restriction"]>

  export type RestrictionSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    date?: boolean
    minStay?: boolean
    maxStay?: boolean
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | Restriction$roomTypeArgs<ExtArgs>
    ratePlan?: boolean | Restriction$ratePlanArgs<ExtArgs>
  }
  export type RestrictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | Restriction$roomTypeArgs<ExtArgs>
    ratePlan?: boolean | Restriction$ratePlanArgs<ExtArgs>
  }

  export type $RestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restriction"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      roomType: Prisma.$RoomTypePayload<ExtArgs> | null
      ratePlan: Prisma.$RatePlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      roomTypeId: string | null
      ratePlanId: string | null
      date: Date
      minStay: number | null
      maxStay: number | null
      closedToArrival: boolean
      closedToDeparture: boolean
      stopSell: boolean
    }, ExtArgs["result"]["restriction"]>
    composites: {}
  }

  type RestrictionGetPayload<S extends boolean | null | undefined | RestrictionDefaultArgs> = $Result.GetResult<Prisma.$RestrictionPayload, S>

  type RestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestrictionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestrictionCountAggregateInputType | true
    }

  export interface RestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restriction'], meta: { name: 'Restriction' } }
    /**
     * Find zero or one Restriction that matches the filter.
     * @param {RestrictionFindUniqueArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestrictionFindUniqueArgs>(args: SelectSubset<T, RestrictionFindUniqueArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Restriction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RestrictionFindUniqueOrThrowArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestrictionFindUniqueOrThrowArgs>(args: SelectSubset<T, RestrictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Restriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindFirstArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestrictionFindFirstArgs>(args?: SelectSubset<T, RestrictionFindFirstArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Restriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindFirstOrThrowArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestrictionFindFirstOrThrowArgs>(args?: SelectSubset<T, RestrictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Restrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restrictions
     * const restrictions = await prisma.restriction.findMany()
     * 
     * // Get first 10 Restrictions
     * const restrictions = await prisma.restriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restrictionWithIdOnly = await prisma.restriction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestrictionFindManyArgs>(args?: SelectSubset<T, RestrictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Restriction.
     * @param {RestrictionCreateArgs} args - Arguments to create a Restriction.
     * @example
     * // Create one Restriction
     * const Restriction = await prisma.restriction.create({
     *   data: {
     *     // ... data to create a Restriction
     *   }
     * })
     * 
     */
    create<T extends RestrictionCreateArgs>(args: SelectSubset<T, RestrictionCreateArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Restrictions.
     * @param {RestrictionCreateManyArgs} args - Arguments to create many Restrictions.
     * @example
     * // Create many Restrictions
     * const restriction = await prisma.restriction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestrictionCreateManyArgs>(args?: SelectSubset<T, RestrictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Restrictions and returns the data saved in the database.
     * @param {RestrictionCreateManyAndReturnArgs} args - Arguments to create many Restrictions.
     * @example
     * // Create many Restrictions
     * const restriction = await prisma.restriction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Restrictions and only return the `id`
     * const restrictionWithIdOnly = await prisma.restriction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestrictionCreateManyAndReturnArgs>(args?: SelectSubset<T, RestrictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Restriction.
     * @param {RestrictionDeleteArgs} args - Arguments to delete one Restriction.
     * @example
     * // Delete one Restriction
     * const Restriction = await prisma.restriction.delete({
     *   where: {
     *     // ... filter to delete one Restriction
     *   }
     * })
     * 
     */
    delete<T extends RestrictionDeleteArgs>(args: SelectSubset<T, RestrictionDeleteArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Restriction.
     * @param {RestrictionUpdateArgs} args - Arguments to update one Restriction.
     * @example
     * // Update one Restriction
     * const restriction = await prisma.restriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestrictionUpdateArgs>(args: SelectSubset<T, RestrictionUpdateArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Restrictions.
     * @param {RestrictionDeleteManyArgs} args - Arguments to filter Restrictions to delete.
     * @example
     * // Delete a few Restrictions
     * const { count } = await prisma.restriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestrictionDeleteManyArgs>(args?: SelectSubset<T, RestrictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restrictions
     * const restriction = await prisma.restriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestrictionUpdateManyArgs>(args: SelectSubset<T, RestrictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restriction.
     * @param {RestrictionUpsertArgs} args - Arguments to update or create a Restriction.
     * @example
     * // Update or create a Restriction
     * const restriction = await prisma.restriction.upsert({
     *   create: {
     *     // ... data to create a Restriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restriction we want to update
     *   }
     * })
     */
    upsert<T extends RestrictionUpsertArgs>(args: SelectSubset<T, RestrictionUpsertArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionCountArgs} args - Arguments to filter Restrictions to count.
     * @example
     * // Count the number of Restrictions
     * const count = await prisma.restriction.count({
     *   where: {
     *     // ... the filter for the Restrictions we want to count
     *   }
     * })
    **/
    count<T extends RestrictionCountArgs>(
      args?: Subset<T, RestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestrictionAggregateArgs>(args: Subset<T, RestrictionAggregateArgs>): Prisma.PrismaPromise<GetRestrictionAggregateType<T>>

    /**
     * Group by Restriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestrictionGroupByArgs['orderBy'] }
        : { orderBy?: RestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restriction model
   */
  readonly fields: RestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roomType<T extends Restriction$roomTypeArgs<ExtArgs> = {}>(args?: Subset<T, Restriction$roomTypeArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ratePlan<T extends Restriction$ratePlanArgs<ExtArgs> = {}>(args?: Subset<T, Restriction$ratePlanArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restriction model
   */ 
  interface RestrictionFieldRefs {
    readonly id: FieldRef<"Restriction", 'String'>
    readonly hotelId: FieldRef<"Restriction", 'String'>
    readonly roomTypeId: FieldRef<"Restriction", 'String'>
    readonly ratePlanId: FieldRef<"Restriction", 'String'>
    readonly date: FieldRef<"Restriction", 'DateTime'>
    readonly minStay: FieldRef<"Restriction", 'Int'>
    readonly maxStay: FieldRef<"Restriction", 'Int'>
    readonly closedToArrival: FieldRef<"Restriction", 'Boolean'>
    readonly closedToDeparture: FieldRef<"Restriction", 'Boolean'>
    readonly stopSell: FieldRef<"Restriction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Restriction findUnique
   */
  export type RestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction findUniqueOrThrow
   */
  export type RestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction findFirst
   */
  export type RestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restrictions.
     */
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction findFirstOrThrow
   */
  export type RestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restrictions.
     */
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction findMany
   */
  export type RestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restrictions to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction create
   */
  export type RestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a Restriction.
     */
    data: XOR<RestrictionCreateInput, RestrictionUncheckedCreateInput>
  }

  /**
   * Restriction createMany
   */
  export type RestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restrictions.
     */
    data: RestrictionCreateManyInput | RestrictionCreateManyInput[]
  }

  /**
   * Restriction createManyAndReturn
   */
  export type RestrictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Restrictions.
     */
    data: RestrictionCreateManyInput | RestrictionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Restriction update
   */
  export type RestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a Restriction.
     */
    data: XOR<RestrictionUpdateInput, RestrictionUncheckedUpdateInput>
    /**
     * Choose, which Restriction to update.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction updateMany
   */
  export type RestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restrictions.
     */
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyInput>
    /**
     * Filter which Restrictions to update
     */
    where?: RestrictionWhereInput
  }

  /**
   * Restriction upsert
   */
  export type RestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the Restriction to update in case it exists.
     */
    where: RestrictionWhereUniqueInput
    /**
     * In case the Restriction found by the `where` argument doesn't exist, create a new Restriction with this data.
     */
    create: XOR<RestrictionCreateInput, RestrictionUncheckedCreateInput>
    /**
     * In case the Restriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestrictionUpdateInput, RestrictionUncheckedUpdateInput>
  }

  /**
   * Restriction delete
   */
  export type RestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter which Restriction to delete.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction deleteMany
   */
  export type RestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restrictions to delete
     */
    where?: RestrictionWhereInput
  }

  /**
   * Restriction.roomType
   */
  export type Restriction$roomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
  }

  /**
   * Restriction.ratePlan
   */
  export type Restriction$ratePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    where?: RatePlanWhereInput
  }

  /**
   * Restriction without action
   */
  export type RestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalPrice: Decimal | null
    nights: number | null
  }

  export type BookingSumAggregateOutputType = {
    totalPrice: Decimal | null
    nights: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    referenceCode: string | null
    guestId: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    status: string | null
    source: string | null
    totalPrice: Decimal | null
    currency: string | null
    isPaid: boolean | null
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    stripePaymentIntentId: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    nights: number | null
    createdAt: Date | null
    updatedAt: Date | null
    otaId: string | null
    otaRawData: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    referenceCode: string | null
    guestId: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    status: string | null
    source: string | null
    totalPrice: Decimal | null
    currency: string | null
    isPaid: boolean | null
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    stripePaymentIntentId: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    nights: number | null
    createdAt: Date | null
    updatedAt: Date | null
    otaId: string | null
    otaRawData: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    hotelId: number
    referenceCode: number
    guestId: number
    guestName: number
    guestEmail: number
    guestPhone: number
    status: number
    source: number
    totalPrice: number
    currency: number
    isPaid: number
    stripeCustomerId: number
    stripePaymentMethodId: number
    stripePaymentIntentId: number
    checkInDate: number
    checkOutDate: number
    nights: number
    createdAt: number
    updatedAt: number
    otaId: number
    otaRawData: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalPrice?: true
    nights?: true
  }

  export type BookingSumAggregateInputType = {
    totalPrice?: true
    nights?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    hotelId?: true
    referenceCode?: true
    guestId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    status?: true
    source?: true
    totalPrice?: true
    currency?: true
    isPaid?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    stripePaymentIntentId?: true
    checkInDate?: true
    checkOutDate?: true
    nights?: true
    createdAt?: true
    updatedAt?: true
    otaId?: true
    otaRawData?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    hotelId?: true
    referenceCode?: true
    guestId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    status?: true
    source?: true
    totalPrice?: true
    currency?: true
    isPaid?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    stripePaymentIntentId?: true
    checkInDate?: true
    checkOutDate?: true
    nights?: true
    createdAt?: true
    updatedAt?: true
    otaId?: true
    otaRawData?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    hotelId?: true
    referenceCode?: true
    guestId?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    status?: true
    source?: true
    totalPrice?: true
    currency?: true
    isPaid?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    stripePaymentIntentId?: true
    checkInDate?: true
    checkOutDate?: true
    nights?: true
    createdAt?: true
    updatedAt?: true
    otaId?: true
    otaRawData?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    hotelId: string
    referenceCode: string
    guestId: string | null
    guestName: string
    guestEmail: string | null
    guestPhone: string | null
    status: string
    source: string
    totalPrice: Decimal
    currency: string
    isPaid: boolean
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    stripePaymentIntentId: string | null
    checkInDate: Date
    checkOutDate: Date
    nights: number
    createdAt: Date
    updatedAt: Date
    otaId: string | null
    otaRawData: string | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    referenceCode?: boolean
    guestId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    status?: boolean
    source?: boolean
    totalPrice?: boolean
    currency?: boolean
    isPaid?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    stripePaymentIntentId?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    nights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otaId?: boolean
    otaRawData?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    guest?: boolean | Booking$guestArgs<ExtArgs>
    bookingRooms?: boolean | Booking$bookingRoomsArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    referenceCode?: boolean
    guestId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    status?: boolean
    source?: boolean
    totalPrice?: boolean
    currency?: boolean
    isPaid?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    stripePaymentIntentId?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    nights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otaId?: boolean
    otaRawData?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    guest?: boolean | Booking$guestArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    hotelId?: boolean
    referenceCode?: boolean
    guestId?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    status?: boolean
    source?: boolean
    totalPrice?: boolean
    currency?: boolean
    isPaid?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    stripePaymentIntentId?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    nights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otaId?: boolean
    otaRawData?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    guest?: boolean | Booking$guestArgs<ExtArgs>
    bookingRooms?: boolean | Booking$bookingRoomsArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    guest?: boolean | Booking$guestArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      guest: Prisma.$GuestPayload<ExtArgs> | null
      bookingRooms: Prisma.$BookingRoomPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      referenceCode: string
      guestId: string | null
      guestName: string
      guestEmail: string | null
      guestPhone: string | null
      status: string
      source: string
      totalPrice: Prisma.Decimal
      currency: string
      isPaid: boolean
      stripeCustomerId: string | null
      stripePaymentMethodId: string | null
      stripePaymentIntentId: string | null
      checkInDate: Date
      checkOutDate: Date
      nights: number
      createdAt: Date
      updatedAt: Date
      otaId: string | null
      otaRawData: string | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    guest<T extends Booking$guestArgs<ExtArgs> = {}>(args?: Subset<T, Booking$guestArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bookingRooms<T extends Booking$bookingRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$bookingRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly hotelId: FieldRef<"Booking", 'String'>
    readonly referenceCode: FieldRef<"Booking", 'String'>
    readonly guestId: FieldRef<"Booking", 'String'>
    readonly guestName: FieldRef<"Booking", 'String'>
    readonly guestEmail: FieldRef<"Booking", 'String'>
    readonly guestPhone: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly source: FieldRef<"Booking", 'String'>
    readonly totalPrice: FieldRef<"Booking", 'Decimal'>
    readonly currency: FieldRef<"Booking", 'String'>
    readonly isPaid: FieldRef<"Booking", 'Boolean'>
    readonly stripeCustomerId: FieldRef<"Booking", 'String'>
    readonly stripePaymentMethodId: FieldRef<"Booking", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Booking", 'String'>
    readonly checkInDate: FieldRef<"Booking", 'DateTime'>
    readonly checkOutDate: FieldRef<"Booking", 'DateTime'>
    readonly nights: FieldRef<"Booking", 'Int'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly otaId: FieldRef<"Booking", 'String'>
    readonly otaRawData: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.guest
   */
  export type Booking$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    where?: GuestWhereInput
  }

  /**
   * Booking.bookingRooms
   */
  export type Booking$bookingRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    where?: BookingRoomWhereInput
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    cursor?: BookingRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRoomScalarFieldEnum | BookingRoomScalarFieldEnum[]
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingRoom
   */

  export type AggregateBookingRoom = {
    _count: BookingRoomCountAggregateOutputType | null
    _avg: BookingRoomAvgAggregateOutputType | null
    _sum: BookingRoomSumAggregateOutputType | null
    _min: BookingRoomMinAggregateOutputType | null
    _max: BookingRoomMaxAggregateOutputType | null
  }

  export type BookingRoomAvgAggregateOutputType = {
    priceSnapshot: Decimal | null
  }

  export type BookingRoomSumAggregateOutputType = {
    priceSnapshot: Decimal | null
  }

  export type BookingRoomMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    roomId: string | null
    priceSnapshot: Decimal | null
    date: Date | null
  }

  export type BookingRoomMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    roomId: string | null
    priceSnapshot: Decimal | null
    date: Date | null
  }

  export type BookingRoomCountAggregateOutputType = {
    id: number
    bookingId: number
    roomId: number
    priceSnapshot: number
    date: number
    _all: number
  }


  export type BookingRoomAvgAggregateInputType = {
    priceSnapshot?: true
  }

  export type BookingRoomSumAggregateInputType = {
    priceSnapshot?: true
  }

  export type BookingRoomMinAggregateInputType = {
    id?: true
    bookingId?: true
    roomId?: true
    priceSnapshot?: true
    date?: true
  }

  export type BookingRoomMaxAggregateInputType = {
    id?: true
    bookingId?: true
    roomId?: true
    priceSnapshot?: true
    date?: true
  }

  export type BookingRoomCountAggregateInputType = {
    id?: true
    bookingId?: true
    roomId?: true
    priceSnapshot?: true
    date?: true
    _all?: true
  }

  export type BookingRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRoom to aggregate.
     */
    where?: BookingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRooms to fetch.
     */
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingRooms
    **/
    _count?: true | BookingRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingRoomMaxAggregateInputType
  }

  export type GetBookingRoomAggregateType<T extends BookingRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingRoom[P]>
      : GetScalarType<T[P], AggregateBookingRoom[P]>
  }




  export type BookingRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRoomWhereInput
    orderBy?: BookingRoomOrderByWithAggregationInput | BookingRoomOrderByWithAggregationInput[]
    by: BookingRoomScalarFieldEnum[] | BookingRoomScalarFieldEnum
    having?: BookingRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingRoomCountAggregateInputType | true
    _avg?: BookingRoomAvgAggregateInputType
    _sum?: BookingRoomSumAggregateInputType
    _min?: BookingRoomMinAggregateInputType
    _max?: BookingRoomMaxAggregateInputType
  }

  export type BookingRoomGroupByOutputType = {
    id: string
    bookingId: string
    roomId: string
    priceSnapshot: Decimal
    date: Date
    _count: BookingRoomCountAggregateOutputType | null
    _avg: BookingRoomAvgAggregateOutputType | null
    _sum: BookingRoomSumAggregateOutputType | null
    _min: BookingRoomMinAggregateOutputType | null
    _max: BookingRoomMaxAggregateOutputType | null
  }

  type GetBookingRoomGroupByPayload<T extends BookingRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingRoomGroupByOutputType[P]>
            : GetScalarType<T[P], BookingRoomGroupByOutputType[P]>
        }
      >
    >


  export type BookingRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    roomId?: boolean
    priceSnapshot?: boolean
    date?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRoom"]>

  export type BookingRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    roomId?: boolean
    priceSnapshot?: boolean
    date?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRoom"]>

  export type BookingRoomSelectScalar = {
    id?: boolean
    bookingId?: boolean
    roomId?: boolean
    priceSnapshot?: boolean
    date?: boolean
  }

  export type BookingRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type BookingRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $BookingRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingRoom"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      roomId: string
      priceSnapshot: Prisma.Decimal
      date: Date
    }, ExtArgs["result"]["bookingRoom"]>
    composites: {}
  }

  type BookingRoomGetPayload<S extends boolean | null | undefined | BookingRoomDefaultArgs> = $Result.GetResult<Prisma.$BookingRoomPayload, S>

  type BookingRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingRoomCountAggregateInputType | true
    }

  export interface BookingRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingRoom'], meta: { name: 'BookingRoom' } }
    /**
     * Find zero or one BookingRoom that matches the filter.
     * @param {BookingRoomFindUniqueArgs} args - Arguments to find a BookingRoom
     * @example
     * // Get one BookingRoom
     * const bookingRoom = await prisma.bookingRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingRoomFindUniqueArgs>(args: SelectSubset<T, BookingRoomFindUniqueArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingRoomFindUniqueOrThrowArgs} args - Arguments to find a BookingRoom
     * @example
     * // Get one BookingRoom
     * const bookingRoom = await prisma.bookingRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomFindFirstArgs} args - Arguments to find a BookingRoom
     * @example
     * // Get one BookingRoom
     * const bookingRoom = await prisma.bookingRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingRoomFindFirstArgs>(args?: SelectSubset<T, BookingRoomFindFirstArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomFindFirstOrThrowArgs} args - Arguments to find a BookingRoom
     * @example
     * // Get one BookingRoom
     * const bookingRoom = await prisma.bookingRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingRooms
     * const bookingRooms = await prisma.bookingRoom.findMany()
     * 
     * // Get first 10 BookingRooms
     * const bookingRooms = await prisma.bookingRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingRoomWithIdOnly = await prisma.bookingRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingRoomFindManyArgs>(args?: SelectSubset<T, BookingRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingRoom.
     * @param {BookingRoomCreateArgs} args - Arguments to create a BookingRoom.
     * @example
     * // Create one BookingRoom
     * const BookingRoom = await prisma.bookingRoom.create({
     *   data: {
     *     // ... data to create a BookingRoom
     *   }
     * })
     * 
     */
    create<T extends BookingRoomCreateArgs>(args: SelectSubset<T, BookingRoomCreateArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingRooms.
     * @param {BookingRoomCreateManyArgs} args - Arguments to create many BookingRooms.
     * @example
     * // Create many BookingRooms
     * const bookingRoom = await prisma.bookingRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingRoomCreateManyArgs>(args?: SelectSubset<T, BookingRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingRooms and returns the data saved in the database.
     * @param {BookingRoomCreateManyAndReturnArgs} args - Arguments to create many BookingRooms.
     * @example
     * // Create many BookingRooms
     * const bookingRoom = await prisma.bookingRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingRooms and only return the `id`
     * const bookingRoomWithIdOnly = await prisma.bookingRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BookingRoom.
     * @param {BookingRoomDeleteArgs} args - Arguments to delete one BookingRoom.
     * @example
     * // Delete one BookingRoom
     * const BookingRoom = await prisma.bookingRoom.delete({
     *   where: {
     *     // ... filter to delete one BookingRoom
     *   }
     * })
     * 
     */
    delete<T extends BookingRoomDeleteArgs>(args: SelectSubset<T, BookingRoomDeleteArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingRoom.
     * @param {BookingRoomUpdateArgs} args - Arguments to update one BookingRoom.
     * @example
     * // Update one BookingRoom
     * const bookingRoom = await prisma.bookingRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingRoomUpdateArgs>(args: SelectSubset<T, BookingRoomUpdateArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingRooms.
     * @param {BookingRoomDeleteManyArgs} args - Arguments to filter BookingRooms to delete.
     * @example
     * // Delete a few BookingRooms
     * const { count } = await prisma.bookingRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingRoomDeleteManyArgs>(args?: SelectSubset<T, BookingRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingRooms
     * const bookingRoom = await prisma.bookingRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingRoomUpdateManyArgs>(args: SelectSubset<T, BookingRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingRoom.
     * @param {BookingRoomUpsertArgs} args - Arguments to update or create a BookingRoom.
     * @example
     * // Update or create a BookingRoom
     * const bookingRoom = await prisma.bookingRoom.upsert({
     *   create: {
     *     // ... data to create a BookingRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingRoom we want to update
     *   }
     * })
     */
    upsert<T extends BookingRoomUpsertArgs>(args: SelectSubset<T, BookingRoomUpsertArgs<ExtArgs>>): Prisma__BookingRoomClient<$Result.GetResult<Prisma.$BookingRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomCountArgs} args - Arguments to filter BookingRooms to count.
     * @example
     * // Count the number of BookingRooms
     * const count = await prisma.bookingRoom.count({
     *   where: {
     *     // ... the filter for the BookingRooms we want to count
     *   }
     * })
    **/
    count<T extends BookingRoomCountArgs>(
      args?: Subset<T, BookingRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingRoomAggregateArgs>(args: Subset<T, BookingRoomAggregateArgs>): Prisma.PrismaPromise<GetBookingRoomAggregateType<T>>

    /**
     * Group by BookingRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingRoomGroupByArgs['orderBy'] }
        : { orderBy?: BookingRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingRoom model
   */
  readonly fields: BookingRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingRoom model
   */ 
  interface BookingRoomFieldRefs {
    readonly id: FieldRef<"BookingRoom", 'String'>
    readonly bookingId: FieldRef<"BookingRoom", 'String'>
    readonly roomId: FieldRef<"BookingRoom", 'String'>
    readonly priceSnapshot: FieldRef<"BookingRoom", 'Decimal'>
    readonly date: FieldRef<"BookingRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingRoom findUnique
   */
  export type BookingRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter, which BookingRoom to fetch.
     */
    where: BookingRoomWhereUniqueInput
  }

  /**
   * BookingRoom findUniqueOrThrow
   */
  export type BookingRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter, which BookingRoom to fetch.
     */
    where: BookingRoomWhereUniqueInput
  }

  /**
   * BookingRoom findFirst
   */
  export type BookingRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter, which BookingRoom to fetch.
     */
    where?: BookingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRooms to fetch.
     */
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRooms.
     */
    cursor?: BookingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRooms.
     */
    distinct?: BookingRoomScalarFieldEnum | BookingRoomScalarFieldEnum[]
  }

  /**
   * BookingRoom findFirstOrThrow
   */
  export type BookingRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter, which BookingRoom to fetch.
     */
    where?: BookingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRooms to fetch.
     */
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRooms.
     */
    cursor?: BookingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRooms.
     */
    distinct?: BookingRoomScalarFieldEnum | BookingRoomScalarFieldEnum[]
  }

  /**
   * BookingRoom findMany
   */
  export type BookingRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter, which BookingRooms to fetch.
     */
    where?: BookingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRooms to fetch.
     */
    orderBy?: BookingRoomOrderByWithRelationInput | BookingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingRooms.
     */
    cursor?: BookingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRooms.
     */
    skip?: number
    distinct?: BookingRoomScalarFieldEnum | BookingRoomScalarFieldEnum[]
  }

  /**
   * BookingRoom create
   */
  export type BookingRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingRoom.
     */
    data: XOR<BookingRoomCreateInput, BookingRoomUncheckedCreateInput>
  }

  /**
   * BookingRoom createMany
   */
  export type BookingRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingRooms.
     */
    data: BookingRoomCreateManyInput | BookingRoomCreateManyInput[]
  }

  /**
   * BookingRoom createManyAndReturn
   */
  export type BookingRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BookingRooms.
     */
    data: BookingRoomCreateManyInput | BookingRoomCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRoom update
   */
  export type BookingRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingRoom.
     */
    data: XOR<BookingRoomUpdateInput, BookingRoomUncheckedUpdateInput>
    /**
     * Choose, which BookingRoom to update.
     */
    where: BookingRoomWhereUniqueInput
  }

  /**
   * BookingRoom updateMany
   */
  export type BookingRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingRooms.
     */
    data: XOR<BookingRoomUpdateManyMutationInput, BookingRoomUncheckedUpdateManyInput>
    /**
     * Filter which BookingRooms to update
     */
    where?: BookingRoomWhereInput
  }

  /**
   * BookingRoom upsert
   */
  export type BookingRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingRoom to update in case it exists.
     */
    where: BookingRoomWhereUniqueInput
    /**
     * In case the BookingRoom found by the `where` argument doesn't exist, create a new BookingRoom with this data.
     */
    create: XOR<BookingRoomCreateInput, BookingRoomUncheckedCreateInput>
    /**
     * In case the BookingRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingRoomUpdateInput, BookingRoomUncheckedUpdateInput>
  }

  /**
   * BookingRoom delete
   */
  export type BookingRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
    /**
     * Filter which BookingRoom to delete.
     */
    where: BookingRoomWhereUniqueInput
  }

  /**
   * BookingRoom deleteMany
   */
  export type BookingRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRooms to delete
     */
    where?: BookingRoomWhereInput
  }

  /**
   * BookingRoom without action
   */
  export type BookingRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRoom
     */
    select?: BookingRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRoomInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    isEnabled: boolean | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    isEnabled: boolean | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    type: number
    isEnabled: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    isEnabled?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    isEnabled?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    isEnabled?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    type: string
    isEnabled: boolean
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    isEnabled?: boolean
    mappings?: boolean | Channel$mappingsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    isEnabled?: boolean
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    isEnabled?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mappings?: boolean | Channel$mappingsArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      mappings: Prisma.$ChannelMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      isEnabled: boolean
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mappings<T extends Channel$mappingsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly type: FieldRef<"Channel", 'String'>
    readonly isEnabled: FieldRef<"Channel", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel.mappings
   */
  export type Channel$mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    where?: ChannelMappingWhereInput
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    cursor?: ChannelMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model ChannelMapping
   */

  export type AggregateChannelMapping = {
    _count: ChannelMappingCountAggregateOutputType | null
    _min: ChannelMappingMinAggregateOutputType | null
    _max: ChannelMappingMaxAggregateOutputType | null
  }

  export type ChannelMappingMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    externalId: string | null
    externalName: string | null
    syncEnabled: boolean | null
  }

  export type ChannelMappingMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    roomTypeId: string | null
    ratePlanId: string | null
    externalId: string | null
    externalName: string | null
    syncEnabled: boolean | null
  }

  export type ChannelMappingCountAggregateOutputType = {
    id: number
    channelId: number
    roomTypeId: number
    ratePlanId: number
    externalId: number
    externalName: number
    syncEnabled: number
    _all: number
  }


  export type ChannelMappingMinAggregateInputType = {
    id?: true
    channelId?: true
    roomTypeId?: true
    ratePlanId?: true
    externalId?: true
    externalName?: true
    syncEnabled?: true
  }

  export type ChannelMappingMaxAggregateInputType = {
    id?: true
    channelId?: true
    roomTypeId?: true
    ratePlanId?: true
    externalId?: true
    externalName?: true
    syncEnabled?: true
  }

  export type ChannelMappingCountAggregateInputType = {
    id?: true
    channelId?: true
    roomTypeId?: true
    ratePlanId?: true
    externalId?: true
    externalName?: true
    syncEnabled?: true
    _all?: true
  }

  export type ChannelMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMapping to aggregate.
     */
    where?: ChannelMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMappings to fetch.
     */
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelMappings
    **/
    _count?: true | ChannelMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMappingMaxAggregateInputType
  }

  export type GetChannelMappingAggregateType<T extends ChannelMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelMapping[P]>
      : GetScalarType<T[P], AggregateChannelMapping[P]>
  }




  export type ChannelMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMappingWhereInput
    orderBy?: ChannelMappingOrderByWithAggregationInput | ChannelMappingOrderByWithAggregationInput[]
    by: ChannelMappingScalarFieldEnum[] | ChannelMappingScalarFieldEnum
    having?: ChannelMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelMappingCountAggregateInputType | true
    _min?: ChannelMappingMinAggregateInputType
    _max?: ChannelMappingMaxAggregateInputType
  }

  export type ChannelMappingGroupByOutputType = {
    id: string
    channelId: string
    roomTypeId: string
    ratePlanId: string | null
    externalId: string
    externalName: string | null
    syncEnabled: boolean
    _count: ChannelMappingCountAggregateOutputType | null
    _min: ChannelMappingMinAggregateOutputType | null
    _max: ChannelMappingMaxAggregateOutputType | null
  }

  type GetChannelMappingGroupByPayload<T extends ChannelMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelMappingGroupByOutputType[P]>
        }
      >
    >


  export type ChannelMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    externalId?: boolean
    externalName?: boolean
    syncEnabled?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | ChannelMapping$ratePlanArgs<ExtArgs>
  }, ExtArgs["result"]["channelMapping"]>

  export type ChannelMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    externalId?: boolean
    externalName?: boolean
    syncEnabled?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | ChannelMapping$ratePlanArgs<ExtArgs>
  }, ExtArgs["result"]["channelMapping"]>

  export type ChannelMappingSelectScalar = {
    id?: boolean
    channelId?: boolean
    roomTypeId?: boolean
    ratePlanId?: boolean
    externalId?: boolean
    externalName?: boolean
    syncEnabled?: boolean
  }

  export type ChannelMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | ChannelMapping$ratePlanArgs<ExtArgs>
  }
  export type ChannelMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    ratePlan?: boolean | ChannelMapping$ratePlanArgs<ExtArgs>
  }

  export type $ChannelMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelMapping"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
      roomType: Prisma.$RoomTypePayload<ExtArgs>
      ratePlan: Prisma.$RatePlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      roomTypeId: string
      ratePlanId: string | null
      externalId: string
      externalName: string | null
      syncEnabled: boolean
    }, ExtArgs["result"]["channelMapping"]>
    composites: {}
  }

  type ChannelMappingGetPayload<S extends boolean | null | undefined | ChannelMappingDefaultArgs> = $Result.GetResult<Prisma.$ChannelMappingPayload, S>

  type ChannelMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelMappingCountAggregateInputType | true
    }

  export interface ChannelMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelMapping'], meta: { name: 'ChannelMapping' } }
    /**
     * Find zero or one ChannelMapping that matches the filter.
     * @param {ChannelMappingFindUniqueArgs} args - Arguments to find a ChannelMapping
     * @example
     * // Get one ChannelMapping
     * const channelMapping = await prisma.channelMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelMappingFindUniqueArgs>(args: SelectSubset<T, ChannelMappingFindUniqueArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelMappingFindUniqueOrThrowArgs} args - Arguments to find a ChannelMapping
     * @example
     * // Get one ChannelMapping
     * const channelMapping = await prisma.channelMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingFindFirstArgs} args - Arguments to find a ChannelMapping
     * @example
     * // Get one ChannelMapping
     * const channelMapping = await prisma.channelMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelMappingFindFirstArgs>(args?: SelectSubset<T, ChannelMappingFindFirstArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingFindFirstOrThrowArgs} args - Arguments to find a ChannelMapping
     * @example
     * // Get one ChannelMapping
     * const channelMapping = await prisma.channelMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelMappings
     * const channelMappings = await prisma.channelMapping.findMany()
     * 
     * // Get first 10 ChannelMappings
     * const channelMappings = await prisma.channelMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelMappingWithIdOnly = await prisma.channelMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelMappingFindManyArgs>(args?: SelectSubset<T, ChannelMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelMapping.
     * @param {ChannelMappingCreateArgs} args - Arguments to create a ChannelMapping.
     * @example
     * // Create one ChannelMapping
     * const ChannelMapping = await prisma.channelMapping.create({
     *   data: {
     *     // ... data to create a ChannelMapping
     *   }
     * })
     * 
     */
    create<T extends ChannelMappingCreateArgs>(args: SelectSubset<T, ChannelMappingCreateArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelMappings.
     * @param {ChannelMappingCreateManyArgs} args - Arguments to create many ChannelMappings.
     * @example
     * // Create many ChannelMappings
     * const channelMapping = await prisma.channelMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelMappingCreateManyArgs>(args?: SelectSubset<T, ChannelMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelMappings and returns the data saved in the database.
     * @param {ChannelMappingCreateManyAndReturnArgs} args - Arguments to create many ChannelMappings.
     * @example
     * // Create many ChannelMappings
     * const channelMapping = await prisma.channelMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelMappings and only return the `id`
     * const channelMappingWithIdOnly = await prisma.channelMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChannelMapping.
     * @param {ChannelMappingDeleteArgs} args - Arguments to delete one ChannelMapping.
     * @example
     * // Delete one ChannelMapping
     * const ChannelMapping = await prisma.channelMapping.delete({
     *   where: {
     *     // ... filter to delete one ChannelMapping
     *   }
     * })
     * 
     */
    delete<T extends ChannelMappingDeleteArgs>(args: SelectSubset<T, ChannelMappingDeleteArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelMapping.
     * @param {ChannelMappingUpdateArgs} args - Arguments to update one ChannelMapping.
     * @example
     * // Update one ChannelMapping
     * const channelMapping = await prisma.channelMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelMappingUpdateArgs>(args: SelectSubset<T, ChannelMappingUpdateArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelMappings.
     * @param {ChannelMappingDeleteManyArgs} args - Arguments to filter ChannelMappings to delete.
     * @example
     * // Delete a few ChannelMappings
     * const { count } = await prisma.channelMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelMappingDeleteManyArgs>(args?: SelectSubset<T, ChannelMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelMappings
     * const channelMapping = await prisma.channelMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelMappingUpdateManyArgs>(args: SelectSubset<T, ChannelMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelMapping.
     * @param {ChannelMappingUpsertArgs} args - Arguments to update or create a ChannelMapping.
     * @example
     * // Update or create a ChannelMapping
     * const channelMapping = await prisma.channelMapping.upsert({
     *   create: {
     *     // ... data to create a ChannelMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelMapping we want to update
     *   }
     * })
     */
    upsert<T extends ChannelMappingUpsertArgs>(args: SelectSubset<T, ChannelMappingUpsertArgs<ExtArgs>>): Prisma__ChannelMappingClient<$Result.GetResult<Prisma.$ChannelMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingCountArgs} args - Arguments to filter ChannelMappings to count.
     * @example
     * // Count the number of ChannelMappings
     * const count = await prisma.channelMapping.count({
     *   where: {
     *     // ... the filter for the ChannelMappings we want to count
     *   }
     * })
    **/
    count<T extends ChannelMappingCountArgs>(
      args?: Subset<T, ChannelMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelMappingAggregateArgs>(args: Subset<T, ChannelMappingAggregateArgs>): Prisma.PrismaPromise<GetChannelMappingAggregateType<T>>

    /**
     * Group by ChannelMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelMappingGroupByArgs['orderBy'] }
        : { orderBy?: ChannelMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelMapping model
   */
  readonly fields: ChannelMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ratePlan<T extends ChannelMapping$ratePlanArgs<ExtArgs> = {}>(args?: Subset<T, ChannelMapping$ratePlanArgs<ExtArgs>>): Prisma__RatePlanClient<$Result.GetResult<Prisma.$RatePlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelMapping model
   */ 
  interface ChannelMappingFieldRefs {
    readonly id: FieldRef<"ChannelMapping", 'String'>
    readonly channelId: FieldRef<"ChannelMapping", 'String'>
    readonly roomTypeId: FieldRef<"ChannelMapping", 'String'>
    readonly ratePlanId: FieldRef<"ChannelMapping", 'String'>
    readonly externalId: FieldRef<"ChannelMapping", 'String'>
    readonly externalName: FieldRef<"ChannelMapping", 'String'>
    readonly syncEnabled: FieldRef<"ChannelMapping", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ChannelMapping findUnique
   */
  export type ChannelMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMapping to fetch.
     */
    where: ChannelMappingWhereUniqueInput
  }

  /**
   * ChannelMapping findUniqueOrThrow
   */
  export type ChannelMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMapping to fetch.
     */
    where: ChannelMappingWhereUniqueInput
  }

  /**
   * ChannelMapping findFirst
   */
  export type ChannelMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMapping to fetch.
     */
    where?: ChannelMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMappings to fetch.
     */
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMappings.
     */
    cursor?: ChannelMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMappings.
     */
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * ChannelMapping findFirstOrThrow
   */
  export type ChannelMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMapping to fetch.
     */
    where?: ChannelMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMappings to fetch.
     */
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMappings.
     */
    cursor?: ChannelMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMappings.
     */
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * ChannelMapping findMany
   */
  export type ChannelMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMappings to fetch.
     */
    where?: ChannelMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMappings to fetch.
     */
    orderBy?: ChannelMappingOrderByWithRelationInput | ChannelMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelMappings.
     */
    cursor?: ChannelMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMappings.
     */
    skip?: number
    distinct?: ChannelMappingScalarFieldEnum | ChannelMappingScalarFieldEnum[]
  }

  /**
   * ChannelMapping create
   */
  export type ChannelMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelMapping.
     */
    data: XOR<ChannelMappingCreateInput, ChannelMappingUncheckedCreateInput>
  }

  /**
   * ChannelMapping createMany
   */
  export type ChannelMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelMappings.
     */
    data: ChannelMappingCreateManyInput | ChannelMappingCreateManyInput[]
  }

  /**
   * ChannelMapping createManyAndReturn
   */
  export type ChannelMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChannelMappings.
     */
    data: ChannelMappingCreateManyInput | ChannelMappingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelMapping update
   */
  export type ChannelMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelMapping.
     */
    data: XOR<ChannelMappingUpdateInput, ChannelMappingUncheckedUpdateInput>
    /**
     * Choose, which ChannelMapping to update.
     */
    where: ChannelMappingWhereUniqueInput
  }

  /**
   * ChannelMapping updateMany
   */
  export type ChannelMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelMappings.
     */
    data: XOR<ChannelMappingUpdateManyMutationInput, ChannelMappingUncheckedUpdateManyInput>
    /**
     * Filter which ChannelMappings to update
     */
    where?: ChannelMappingWhereInput
  }

  /**
   * ChannelMapping upsert
   */
  export type ChannelMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelMapping to update in case it exists.
     */
    where: ChannelMappingWhereUniqueInput
    /**
     * In case the ChannelMapping found by the `where` argument doesn't exist, create a new ChannelMapping with this data.
     */
    create: XOR<ChannelMappingCreateInput, ChannelMappingUncheckedCreateInput>
    /**
     * In case the ChannelMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelMappingUpdateInput, ChannelMappingUncheckedUpdateInput>
  }

  /**
   * ChannelMapping delete
   */
  export type ChannelMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
    /**
     * Filter which ChannelMapping to delete.
     */
    where: ChannelMappingWhereUniqueInput
  }

  /**
   * ChannelMapping deleteMany
   */
  export type ChannelMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMappings to delete
     */
    where?: ChannelMappingWhereInput
  }

  /**
   * ChannelMapping.ratePlan
   */
  export type ChannelMapping$ratePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RatePlan
     */
    select?: RatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatePlanInclude<ExtArgs> | null
    where?: RatePlanWhereInput
  }

  /**
   * ChannelMapping without action
   */
  export type ChannelMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMapping
     */
    select?: ChannelMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMappingInclude<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    channel: string | null
    action: string | null
    status: string | null
    details: string | null
    timestamp: Date | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    channel: string | null
    action: string | null
    status: string | null
    details: string | null
    timestamp: Date | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    channel: number
    action: number
    status: number
    details: number
    timestamp: number
    _all: number
  }


  export type SyncLogMinAggregateInputType = {
    id?: true
    channel?: true
    action?: true
    status?: true
    details?: true
    timestamp?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    channel?: true
    action?: true
    status?: true
    details?: true
    timestamp?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    channel?: true
    action?: true
    status?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    channel: string
    action: string
    status: string
    details: string | null
    timestamp: Date
    _count: SyncLogCountAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channel?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channel?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    channel?: boolean
    action?: boolean
    status?: boolean
    details?: boolean
    timestamp?: boolean
  }


  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channel: string
      action: string
      status: string
      details: string | null
      timestamp: Date
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */ 
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly channel: FieldRef<"SyncLog", 'String'>
    readonly action: FieldRef<"SyncLog", 'String'>
    readonly status: FieldRef<"SyncLog", 'String'>
    readonly details: FieldRef<"SyncLog", 'String'>
    readonly timestamp: FieldRef<"SyncLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    domain: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    actor: string | null
    metadata: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    actor: string | null
    metadata: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    domain: number
    entity: number
    entityId: number
    action: number
    actor: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    domain?: true
    entity?: true
    entityId?: true
    action?: true
    actor?: true
    metadata?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    domain?: true
    entity?: true
    entityId?: true
    action?: true
    actor?: true
    metadata?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    domain?: true
    entity?: true
    entityId?: true
    action?: true
    actor?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    domain: string
    entity: string
    entityId: string
    action: string
    actor: string
    metadata: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actor?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actor?: boolean
    metadata?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    domain?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    actor?: boolean
    metadata?: boolean
    timestamp?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domain: string
      entity: string
      entityId: string
      action: string
      actor: string
      metadata: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly domain: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly actor: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model ICalFeed
   */

  export type AggregateICalFeed = {
    _count: ICalFeedCountAggregateOutputType | null
    _min: ICalFeedMinAggregateOutputType | null
    _max: ICalFeedMaxAggregateOutputType | null
  }

  export type ICalFeedMinAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    url: string | null
    name: string | null
    source: string | null
    lastSync: Date | null
    isActive: boolean | null
  }

  export type ICalFeedMaxAggregateOutputType = {
    id: string | null
    roomTypeId: string | null
    url: string | null
    name: string | null
    source: string | null
    lastSync: Date | null
    isActive: boolean | null
  }

  export type ICalFeedCountAggregateOutputType = {
    id: number
    roomTypeId: number
    url: number
    name: number
    source: number
    lastSync: number
    isActive: number
    _all: number
  }


  export type ICalFeedMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    url?: true
    name?: true
    source?: true
    lastSync?: true
    isActive?: true
  }

  export type ICalFeedMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    url?: true
    name?: true
    source?: true
    lastSync?: true
    isActive?: true
  }

  export type ICalFeedCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    url?: true
    name?: true
    source?: true
    lastSync?: true
    isActive?: true
    _all?: true
  }

  export type ICalFeedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ICalFeed to aggregate.
     */
    where?: ICalFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICalFeeds to fetch.
     */
    orderBy?: ICalFeedOrderByWithRelationInput | ICalFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ICalFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICalFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICalFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ICalFeeds
    **/
    _count?: true | ICalFeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ICalFeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ICalFeedMaxAggregateInputType
  }

  export type GetICalFeedAggregateType<T extends ICalFeedAggregateArgs> = {
        [P in keyof T & keyof AggregateICalFeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateICalFeed[P]>
      : GetScalarType<T[P], AggregateICalFeed[P]>
  }




  export type ICalFeedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ICalFeedWhereInput
    orderBy?: ICalFeedOrderByWithAggregationInput | ICalFeedOrderByWithAggregationInput[]
    by: ICalFeedScalarFieldEnum[] | ICalFeedScalarFieldEnum
    having?: ICalFeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ICalFeedCountAggregateInputType | true
    _min?: ICalFeedMinAggregateInputType
    _max?: ICalFeedMaxAggregateInputType
  }

  export type ICalFeedGroupByOutputType = {
    id: string
    roomTypeId: string
    url: string
    name: string | null
    source: string
    lastSync: Date | null
    isActive: boolean
    _count: ICalFeedCountAggregateOutputType | null
    _min: ICalFeedMinAggregateOutputType | null
    _max: ICalFeedMaxAggregateOutputType | null
  }

  type GetICalFeedGroupByPayload<T extends ICalFeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ICalFeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ICalFeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ICalFeedGroupByOutputType[P]>
            : GetScalarType<T[P], ICalFeedGroupByOutputType[P]>
        }
      >
    >


  export type ICalFeedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    url?: boolean
    name?: boolean
    source?: boolean
    lastSync?: boolean
    isActive?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iCalFeed"]>

  export type ICalFeedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    url?: boolean
    name?: boolean
    source?: boolean
    lastSync?: boolean
    isActive?: boolean
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iCalFeed"]>

  export type ICalFeedSelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    url?: boolean
    name?: boolean
    source?: boolean
    lastSync?: boolean
    isActive?: boolean
  }

  export type ICalFeedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }
  export type ICalFeedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }

  export type $ICalFeedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ICalFeed"
    objects: {
      roomType: Prisma.$RoomTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomTypeId: string
      url: string
      name: string | null
      source: string
      lastSync: Date | null
      isActive: boolean
    }, ExtArgs["result"]["iCalFeed"]>
    composites: {}
  }

  type ICalFeedGetPayload<S extends boolean | null | undefined | ICalFeedDefaultArgs> = $Result.GetResult<Prisma.$ICalFeedPayload, S>

  type ICalFeedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ICalFeedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ICalFeedCountAggregateInputType | true
    }

  export interface ICalFeedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ICalFeed'], meta: { name: 'ICalFeed' } }
    /**
     * Find zero or one ICalFeed that matches the filter.
     * @param {ICalFeedFindUniqueArgs} args - Arguments to find a ICalFeed
     * @example
     * // Get one ICalFeed
     * const iCalFeed = await prisma.iCalFeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ICalFeedFindUniqueArgs>(args: SelectSubset<T, ICalFeedFindUniqueArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ICalFeed that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ICalFeedFindUniqueOrThrowArgs} args - Arguments to find a ICalFeed
     * @example
     * // Get one ICalFeed
     * const iCalFeed = await prisma.iCalFeed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ICalFeedFindUniqueOrThrowArgs>(args: SelectSubset<T, ICalFeedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ICalFeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedFindFirstArgs} args - Arguments to find a ICalFeed
     * @example
     * // Get one ICalFeed
     * const iCalFeed = await prisma.iCalFeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ICalFeedFindFirstArgs>(args?: SelectSubset<T, ICalFeedFindFirstArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ICalFeed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedFindFirstOrThrowArgs} args - Arguments to find a ICalFeed
     * @example
     * // Get one ICalFeed
     * const iCalFeed = await prisma.iCalFeed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ICalFeedFindFirstOrThrowArgs>(args?: SelectSubset<T, ICalFeedFindFirstOrThrowArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ICalFeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ICalFeeds
     * const iCalFeeds = await prisma.iCalFeed.findMany()
     * 
     * // Get first 10 ICalFeeds
     * const iCalFeeds = await prisma.iCalFeed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iCalFeedWithIdOnly = await prisma.iCalFeed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ICalFeedFindManyArgs>(args?: SelectSubset<T, ICalFeedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ICalFeed.
     * @param {ICalFeedCreateArgs} args - Arguments to create a ICalFeed.
     * @example
     * // Create one ICalFeed
     * const ICalFeed = await prisma.iCalFeed.create({
     *   data: {
     *     // ... data to create a ICalFeed
     *   }
     * })
     * 
     */
    create<T extends ICalFeedCreateArgs>(args: SelectSubset<T, ICalFeedCreateArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ICalFeeds.
     * @param {ICalFeedCreateManyArgs} args - Arguments to create many ICalFeeds.
     * @example
     * // Create many ICalFeeds
     * const iCalFeed = await prisma.iCalFeed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ICalFeedCreateManyArgs>(args?: SelectSubset<T, ICalFeedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ICalFeeds and returns the data saved in the database.
     * @param {ICalFeedCreateManyAndReturnArgs} args - Arguments to create many ICalFeeds.
     * @example
     * // Create many ICalFeeds
     * const iCalFeed = await prisma.iCalFeed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ICalFeeds and only return the `id`
     * const iCalFeedWithIdOnly = await prisma.iCalFeed.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ICalFeedCreateManyAndReturnArgs>(args?: SelectSubset<T, ICalFeedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ICalFeed.
     * @param {ICalFeedDeleteArgs} args - Arguments to delete one ICalFeed.
     * @example
     * // Delete one ICalFeed
     * const ICalFeed = await prisma.iCalFeed.delete({
     *   where: {
     *     // ... filter to delete one ICalFeed
     *   }
     * })
     * 
     */
    delete<T extends ICalFeedDeleteArgs>(args: SelectSubset<T, ICalFeedDeleteArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ICalFeed.
     * @param {ICalFeedUpdateArgs} args - Arguments to update one ICalFeed.
     * @example
     * // Update one ICalFeed
     * const iCalFeed = await prisma.iCalFeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ICalFeedUpdateArgs>(args: SelectSubset<T, ICalFeedUpdateArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ICalFeeds.
     * @param {ICalFeedDeleteManyArgs} args - Arguments to filter ICalFeeds to delete.
     * @example
     * // Delete a few ICalFeeds
     * const { count } = await prisma.iCalFeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ICalFeedDeleteManyArgs>(args?: SelectSubset<T, ICalFeedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ICalFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ICalFeeds
     * const iCalFeed = await prisma.iCalFeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ICalFeedUpdateManyArgs>(args: SelectSubset<T, ICalFeedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ICalFeed.
     * @param {ICalFeedUpsertArgs} args - Arguments to update or create a ICalFeed.
     * @example
     * // Update or create a ICalFeed
     * const iCalFeed = await prisma.iCalFeed.upsert({
     *   create: {
     *     // ... data to create a ICalFeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ICalFeed we want to update
     *   }
     * })
     */
    upsert<T extends ICalFeedUpsertArgs>(args: SelectSubset<T, ICalFeedUpsertArgs<ExtArgs>>): Prisma__ICalFeedClient<$Result.GetResult<Prisma.$ICalFeedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ICalFeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedCountArgs} args - Arguments to filter ICalFeeds to count.
     * @example
     * // Count the number of ICalFeeds
     * const count = await prisma.iCalFeed.count({
     *   where: {
     *     // ... the filter for the ICalFeeds we want to count
     *   }
     * })
    **/
    count<T extends ICalFeedCountArgs>(
      args?: Subset<T, ICalFeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ICalFeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ICalFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ICalFeedAggregateArgs>(args: Subset<T, ICalFeedAggregateArgs>): Prisma.PrismaPromise<GetICalFeedAggregateType<T>>

    /**
     * Group by ICalFeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICalFeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ICalFeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ICalFeedGroupByArgs['orderBy'] }
        : { orderBy?: ICalFeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ICalFeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetICalFeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ICalFeed model
   */
  readonly fields: ICalFeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ICalFeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ICalFeedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ICalFeed model
   */ 
  interface ICalFeedFieldRefs {
    readonly id: FieldRef<"ICalFeed", 'String'>
    readonly roomTypeId: FieldRef<"ICalFeed", 'String'>
    readonly url: FieldRef<"ICalFeed", 'String'>
    readonly name: FieldRef<"ICalFeed", 'String'>
    readonly source: FieldRef<"ICalFeed", 'String'>
    readonly lastSync: FieldRef<"ICalFeed", 'DateTime'>
    readonly isActive: FieldRef<"ICalFeed", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ICalFeed findUnique
   */
  export type ICalFeedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter, which ICalFeed to fetch.
     */
    where: ICalFeedWhereUniqueInput
  }

  /**
   * ICalFeed findUniqueOrThrow
   */
  export type ICalFeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter, which ICalFeed to fetch.
     */
    where: ICalFeedWhereUniqueInput
  }

  /**
   * ICalFeed findFirst
   */
  export type ICalFeedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter, which ICalFeed to fetch.
     */
    where?: ICalFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICalFeeds to fetch.
     */
    orderBy?: ICalFeedOrderByWithRelationInput | ICalFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ICalFeeds.
     */
    cursor?: ICalFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICalFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICalFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ICalFeeds.
     */
    distinct?: ICalFeedScalarFieldEnum | ICalFeedScalarFieldEnum[]
  }

  /**
   * ICalFeed findFirstOrThrow
   */
  export type ICalFeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter, which ICalFeed to fetch.
     */
    where?: ICalFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICalFeeds to fetch.
     */
    orderBy?: ICalFeedOrderByWithRelationInput | ICalFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ICalFeeds.
     */
    cursor?: ICalFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICalFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICalFeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ICalFeeds.
     */
    distinct?: ICalFeedScalarFieldEnum | ICalFeedScalarFieldEnum[]
  }

  /**
   * ICalFeed findMany
   */
  export type ICalFeedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter, which ICalFeeds to fetch.
     */
    where?: ICalFeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICalFeeds to fetch.
     */
    orderBy?: ICalFeedOrderByWithRelationInput | ICalFeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ICalFeeds.
     */
    cursor?: ICalFeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICalFeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICalFeeds.
     */
    skip?: number
    distinct?: ICalFeedScalarFieldEnum | ICalFeedScalarFieldEnum[]
  }

  /**
   * ICalFeed create
   */
  export type ICalFeedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * The data needed to create a ICalFeed.
     */
    data: XOR<ICalFeedCreateInput, ICalFeedUncheckedCreateInput>
  }

  /**
   * ICalFeed createMany
   */
  export type ICalFeedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ICalFeeds.
     */
    data: ICalFeedCreateManyInput | ICalFeedCreateManyInput[]
  }

  /**
   * ICalFeed createManyAndReturn
   */
  export type ICalFeedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ICalFeeds.
     */
    data: ICalFeedCreateManyInput | ICalFeedCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ICalFeed update
   */
  export type ICalFeedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * The data needed to update a ICalFeed.
     */
    data: XOR<ICalFeedUpdateInput, ICalFeedUncheckedUpdateInput>
    /**
     * Choose, which ICalFeed to update.
     */
    where: ICalFeedWhereUniqueInput
  }

  /**
   * ICalFeed updateMany
   */
  export type ICalFeedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ICalFeeds.
     */
    data: XOR<ICalFeedUpdateManyMutationInput, ICalFeedUncheckedUpdateManyInput>
    /**
     * Filter which ICalFeeds to update
     */
    where?: ICalFeedWhereInput
  }

  /**
   * ICalFeed upsert
   */
  export type ICalFeedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * The filter to search for the ICalFeed to update in case it exists.
     */
    where: ICalFeedWhereUniqueInput
    /**
     * In case the ICalFeed found by the `where` argument doesn't exist, create a new ICalFeed with this data.
     */
    create: XOR<ICalFeedCreateInput, ICalFeedUncheckedCreateInput>
    /**
     * In case the ICalFeed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ICalFeedUpdateInput, ICalFeedUncheckedUpdateInput>
  }

  /**
   * ICalFeed delete
   */
  export type ICalFeedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
    /**
     * Filter which ICalFeed to delete.
     */
    where: ICalFeedWhereUniqueInput
  }

  /**
   * ICalFeed deleteMany
   */
  export type ICalFeedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ICalFeeds to delete
     */
    where?: ICalFeedWhereInput
  }

  /**
   * ICalFeed without action
   */
  export type ICalFeedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICalFeed
     */
    select?: ICalFeedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICalFeedInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: Decimal | null
    gateway: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: Decimal | null
    gateway: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    gateway: number
    transactionId: number
    status: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    gateway?: true
    transactionId?: true
    status?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    gateway?: true
    transactionId?: true
    status?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    gateway?: true
    transactionId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    amount: Decimal
    gateway: string
    transactionId: string | null
    status: string
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    gateway?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    gateway?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    gateway?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      amount: Prisma.Decimal
      gateway: string
      transactionId: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly gateway: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    hotelId: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    hotelId?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    hotelId?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    hotelId?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    hotelId: string | null
    email: string
    password: string
    role: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    hotel?: boolean | User$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    hotel?: boolean | User$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    hotelId?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | User$hotelArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | User$hotelArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string | null
      email: string
      password: string
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends User$hotelArgs<ExtArgs> = {}>(args?: Subset<T, User$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly hotelId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.hotel
   */
  export type User$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantMinAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
  }

  export type RestaurantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
  }

  export type RestaurantCountAggregateOutputType = {
    id: number
    name: number
    currency: number
    _all: number
  }


  export type RestaurantMinAggregateInputType = {
    id?: true
    name?: true
    currency?: true
  }

  export type RestaurantMaxAggregateInputType = {
    id?: true
    name?: true
    currency?: true
  }

  export type RestaurantCountAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    _all?: true
  }

  export type RestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurant to aggregate.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restaurants
    **/
    _count?: true | RestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>
  }




  export type RestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithAggregationInput | RestaurantOrderByWithAggregationInput[]
    by: RestaurantScalarFieldEnum[] | RestaurantScalarFieldEnum
    having?: RestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCountAggregateInputType | true
    _min?: RestaurantMinAggregateInputType
    _max?: RestaurantMaxAggregateInputType
  }

  export type RestaurantGroupByOutputType = {
    id: string
    name: string
    currency: string
    _count: RestaurantCountAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    zones?: boolean | Restaurant$zonesArgs<ExtArgs>
    bookings?: boolean | Restaurant$bookingsArgs<ExtArgs>
    waitlist?: boolean | Restaurant$waitlistArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectScalar = {
    id?: boolean
    name?: boolean
    currency?: boolean
  }

  export type RestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | Restaurant$zonesArgs<ExtArgs>
    bookings?: boolean | Restaurant$bookingsArgs<ExtArgs>
    waitlist?: boolean | Restaurant$waitlistArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restaurant"
    objects: {
      zones: Prisma.$ZonePayload<ExtArgs>[]
      bookings: Prisma.$ResBookingPayload<ExtArgs>[]
      waitlist: Prisma.$RestaurantWaitlistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      currency: string
    }, ExtArgs["result"]["restaurant"]>
    composites: {}
  }

  type RestaurantGetPayload<S extends boolean | null | undefined | RestaurantDefaultArgs> = $Result.GetResult<Prisma.$RestaurantPayload, S>

  type RestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestaurantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestaurantCountAggregateInputType | true
    }

  export interface RestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restaurant'], meta: { name: 'Restaurant' } }
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantFindUniqueArgs>(args: SelectSubset<T, RestaurantFindUniqueArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Restaurant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RestaurantFindUniqueOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantFindFirstArgs>(args?: SelectSubset<T, RestaurantFindFirstArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantFindManyArgs>(args?: SelectSubset<T, RestaurantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
     */
    create<T extends RestaurantCreateArgs>(args: SelectSubset<T, RestaurantCreateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Restaurants.
     * @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantCreateManyArgs>(args?: SelectSubset<T, RestaurantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Restaurants and returns the data saved in the database.
     * @param {RestaurantCreateManyAndReturnArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Restaurants and only return the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
     */
    delete<T extends RestaurantDeleteArgs>(args: SelectSubset<T, RestaurantDeleteArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantUpdateArgs>(args: SelectSubset<T, RestaurantUpdateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantDeleteManyArgs>(args?: SelectSubset<T, RestaurantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantUpdateManyArgs>(args: SelectSubset<T, RestaurantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantUpsertArgs>(args: SelectSubset<T, RestaurantUpsertArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantAggregateArgs>(args: Subset<T, RestaurantAggregateArgs>): Prisma.PrismaPromise<GetRestaurantAggregateType<T>>

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restaurant model
   */
  readonly fields: RestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zones<T extends Restaurant$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Restaurant$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findMany"> | Null>
    waitlist<T extends Restaurant$waitlistArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$waitlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restaurant model
   */ 
  interface RestaurantFieldRefs {
    readonly id: FieldRef<"Restaurant", 'String'>
    readonly name: FieldRef<"Restaurant", 'String'>
    readonly currency: FieldRef<"Restaurant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findUniqueOrThrow
   */
  export type RestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findFirstOrThrow
   */
  export type RestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurants to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a Restaurant.
     */
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
  }

  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
  }

  /**
   * Restaurant createManyAndReturn
   */
  export type RestaurantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
  }

  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a Restaurant.
     */
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    /**
     * Choose, which Restaurant to update.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
  }

  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
     */
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     */
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
  }

  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter which Restaurant to delete.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurants to delete
     */
    where?: RestaurantWhereInput
  }

  /**
   * Restaurant.zones
   */
  export type Restaurant$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Restaurant.bookings
   */
  export type Restaurant$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    where?: ResBookingWhereInput
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    cursor?: ResBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * Restaurant.waitlist
   */
  export type Restaurant$waitlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    where?: RestaurantWaitlistWhereInput
    orderBy?: RestaurantWaitlistOrderByWithRelationInput | RestaurantWaitlistOrderByWithRelationInput[]
    cursor?: RestaurantWaitlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantWaitlistScalarFieldEnum | RestaurantWaitlistScalarFieldEnum[]
  }

  /**
   * Restaurant without action
   */
  export type RestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    index: number | null
  }

  export type ZoneSumAggregateOutputType = {
    index: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    name: string | null
    index: number | null
    isActive: boolean | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    name: string | null
    index: number | null
    isActive: boolean | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    restaurantId: number
    name: number
    index: number
    isActive: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    index?: true
  }

  export type ZoneSumAggregateInputType = {
    index?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    index?: true
    isActive?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    index?: true
    isActive?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    index?: true
    isActive?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    restaurantId: string
    name: string
    index: number
    isActive: boolean
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    index?: boolean
    isActive?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    tables?: boolean | Zone$tablesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    index?: boolean
    isActive?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    index?: boolean
    isActive?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    tables?: boolean | Zone$tablesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      tables: Prisma.$TablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      restaurantId: string
      name: string
      index: number
      isActive: boolean
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tables<T extends Zone$tablesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly restaurantId: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly index: FieldRef<"Zone", 'Int'>
    readonly isActive: FieldRef<"Zone", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone.tables
   */
  export type Zone$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    capacity: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    minPax: number | null
    maxPax: number | null
  }

  export type TableSumAggregateOutputType = {
    capacity: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    minPax: number | null
    maxPax: number | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    zoneId: string | null
    name: string | null
    capacity: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    shape: string | null
    rotation: number | null
    isActive: boolean | null
    minPax: number | null
    maxPax: number | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    zoneId: string | null
    name: string | null
    capacity: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    shape: string | null
    rotation: number | null
    isActive: boolean | null
    minPax: number | null
    maxPax: number | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    zoneId: number
    name: number
    capacity: number
    x: number
    y: number
    width: number
    height: number
    shape: number
    rotation: number
    isActive: number
    minPax: number
    maxPax: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    capacity?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    minPax?: true
    maxPax?: true
  }

  export type TableSumAggregateInputType = {
    capacity?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    minPax?: true
    maxPax?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    capacity?: true
    x?: true
    y?: true
    width?: true
    height?: true
    shape?: true
    rotation?: true
    isActive?: true
    minPax?: true
    maxPax?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    capacity?: true
    x?: true
    y?: true
    width?: true
    height?: true
    shape?: true
    rotation?: true
    isActive?: true
    minPax?: true
    maxPax?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    zoneId?: true
    name?: true
    capacity?: true
    x?: true
    y?: true
    width?: true
    height?: true
    shape?: true
    rotation?: true
    isActive?: true
    minPax?: true
    maxPax?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: string
    zoneId: string
    name: string
    capacity: number
    x: number
    y: number
    width: number
    height: number
    shape: string
    rotation: number
    isActive: boolean
    minPax: number
    maxPax: number
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    name?: boolean
    capacity?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    shape?: boolean
    rotation?: boolean
    isActive?: boolean
    minPax?: boolean
    maxPax?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    resBookings?: boolean | Table$resBookingsArgs<ExtArgs>
    tableHolds?: boolean | Table$tableHoldsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    name?: boolean
    capacity?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    shape?: boolean
    rotation?: boolean
    isActive?: boolean
    minPax?: boolean
    maxPax?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    id?: boolean
    zoneId?: boolean
    name?: boolean
    capacity?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    shape?: boolean
    rotation?: boolean
    isActive?: boolean
    minPax?: boolean
    maxPax?: boolean
  }

  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    resBookings?: boolean | Table$resBookingsArgs<ExtArgs>
    tableHolds?: boolean | Table$tableHoldsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      resBookings: Prisma.$ResBookingPayload<ExtArgs>[]
      tableHolds: Prisma.$TableHoldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zoneId: string
      name: string
      capacity: number
      x: number
      y: number
      width: number
      height: number
      shape: string
      rotation: number
      isActive: boolean
      minPax: number
      maxPax: number
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resBookings<T extends Table$resBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Table$resBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findMany"> | Null>
    tableHolds<T extends Table$tableHoldsArgs<ExtArgs> = {}>(args?: Subset<T, Table$tableHoldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */ 
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'String'>
    readonly zoneId: FieldRef<"Table", 'String'>
    readonly name: FieldRef<"Table", 'String'>
    readonly capacity: FieldRef<"Table", 'Int'>
    readonly x: FieldRef<"Table", 'Int'>
    readonly y: FieldRef<"Table", 'Int'>
    readonly width: FieldRef<"Table", 'Int'>
    readonly height: FieldRef<"Table", 'Int'>
    readonly shape: FieldRef<"Table", 'String'>
    readonly rotation: FieldRef<"Table", 'Int'>
    readonly isActive: FieldRef<"Table", 'Boolean'>
    readonly minPax: FieldRef<"Table", 'Int'>
    readonly maxPax: FieldRef<"Table", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
  }

  /**
   * Table.resBookings
   */
  export type Table$resBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    where?: ResBookingWhereInput
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    cursor?: ResBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * Table.tableHolds
   */
  export type Table$tableHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    where?: TableHoldWhereInput
    orderBy?: TableHoldOrderByWithRelationInput | TableHoldOrderByWithRelationInput[]
    cursor?: TableHoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableHoldScalarFieldEnum | TableHoldScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model ResBooking
   */

  export type AggregateResBooking = {
    _count: ResBookingCountAggregateOutputType | null
    _avg: ResBookingAvgAggregateOutputType | null
    _sum: ResBookingSumAggregateOutputType | null
    _min: ResBookingMinAggregateOutputType | null
    _max: ResBookingMaxAggregateOutputType | null
  }

  export type ResBookingAvgAggregateOutputType = {
    pax: number | null
    duration: number | null
  }

  export type ResBookingSumAggregateOutputType = {
    pax: number | null
    duration: number | null
  }

  export type ResBookingMinAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    tableId: string | null
    guestName: string | null
    guestPhone: string | null
    guestEmail: string | null
    pax: number | null
    date: Date | null
    duration: number | null
    status: string | null
    tags: string | null
    notes: string | null
    origin: string | null
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    smsSent: boolean | null
    emailSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    idempotencyKey: string | null
    channelId: string | null
  }

  export type ResBookingMaxAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    tableId: string | null
    guestName: string | null
    guestPhone: string | null
    guestEmail: string | null
    pax: number | null
    date: Date | null
    duration: number | null
    status: string | null
    tags: string | null
    notes: string | null
    origin: string | null
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    smsSent: boolean | null
    emailSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    idempotencyKey: string | null
    channelId: string | null
  }

  export type ResBookingCountAggregateOutputType = {
    id: number
    restaurantId: number
    tableId: number
    guestName: number
    guestPhone: number
    guestEmail: number
    pax: number
    date: number
    duration: number
    status: number
    tags: number
    notes: number
    origin: number
    stripeCustomerId: number
    stripePaymentMethodId: number
    smsSent: number
    emailSent: number
    createdAt: number
    updatedAt: number
    idempotencyKey: number
    channelId: number
    _all: number
  }


  export type ResBookingAvgAggregateInputType = {
    pax?: true
    duration?: true
  }

  export type ResBookingSumAggregateInputType = {
    pax?: true
    duration?: true
  }

  export type ResBookingMinAggregateInputType = {
    id?: true
    restaurantId?: true
    tableId?: true
    guestName?: true
    guestPhone?: true
    guestEmail?: true
    pax?: true
    date?: true
    duration?: true
    status?: true
    tags?: true
    notes?: true
    origin?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    smsSent?: true
    emailSent?: true
    createdAt?: true
    updatedAt?: true
    idempotencyKey?: true
    channelId?: true
  }

  export type ResBookingMaxAggregateInputType = {
    id?: true
    restaurantId?: true
    tableId?: true
    guestName?: true
    guestPhone?: true
    guestEmail?: true
    pax?: true
    date?: true
    duration?: true
    status?: true
    tags?: true
    notes?: true
    origin?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    smsSent?: true
    emailSent?: true
    createdAt?: true
    updatedAt?: true
    idempotencyKey?: true
    channelId?: true
  }

  export type ResBookingCountAggregateInputType = {
    id?: true
    restaurantId?: true
    tableId?: true
    guestName?: true
    guestPhone?: true
    guestEmail?: true
    pax?: true
    date?: true
    duration?: true
    status?: true
    tags?: true
    notes?: true
    origin?: true
    stripeCustomerId?: true
    stripePaymentMethodId?: true
    smsSent?: true
    emailSent?: true
    createdAt?: true
    updatedAt?: true
    idempotencyKey?: true
    channelId?: true
    _all?: true
  }

  export type ResBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResBooking to aggregate.
     */
    where?: ResBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResBookings to fetch.
     */
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResBookings
    **/
    _count?: true | ResBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResBookingMaxAggregateInputType
  }

  export type GetResBookingAggregateType<T extends ResBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateResBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResBooking[P]>
      : GetScalarType<T[P], AggregateResBooking[P]>
  }




  export type ResBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResBookingWhereInput
    orderBy?: ResBookingOrderByWithAggregationInput | ResBookingOrderByWithAggregationInput[]
    by: ResBookingScalarFieldEnum[] | ResBookingScalarFieldEnum
    having?: ResBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResBookingCountAggregateInputType | true
    _avg?: ResBookingAvgAggregateInputType
    _sum?: ResBookingSumAggregateInputType
    _min?: ResBookingMinAggregateInputType
    _max?: ResBookingMaxAggregateInputType
  }

  export type ResBookingGroupByOutputType = {
    id: string
    restaurantId: string
    tableId: string | null
    guestName: string
    guestPhone: string | null
    guestEmail: string | null
    pax: number
    date: Date
    duration: number
    status: string
    tags: string | null
    notes: string | null
    origin: string
    stripeCustomerId: string | null
    stripePaymentMethodId: string | null
    smsSent: boolean
    emailSent: boolean
    createdAt: Date
    updatedAt: Date
    idempotencyKey: string | null
    channelId: string | null
    _count: ResBookingCountAggregateOutputType | null
    _avg: ResBookingAvgAggregateOutputType | null
    _sum: ResBookingSumAggregateOutputType | null
    _min: ResBookingMinAggregateOutputType | null
    _max: ResBookingMaxAggregateOutputType | null
  }

  type GetResBookingGroupByPayload<T extends ResBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ResBookingGroupByOutputType[P]>
        }
      >
    >


  export type ResBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    tableId?: boolean
    guestName?: boolean
    guestPhone?: boolean
    guestEmail?: boolean
    pax?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    origin?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idempotencyKey?: boolean
    channelId?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    table?: boolean | ResBooking$tableArgs<ExtArgs>
    channel?: boolean | ResBooking$channelArgs<ExtArgs>
  }, ExtArgs["result"]["resBooking"]>

  export type ResBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    tableId?: boolean
    guestName?: boolean
    guestPhone?: boolean
    guestEmail?: boolean
    pax?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    origin?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idempotencyKey?: boolean
    channelId?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    table?: boolean | ResBooking$tableArgs<ExtArgs>
    channel?: boolean | ResBooking$channelArgs<ExtArgs>
  }, ExtArgs["result"]["resBooking"]>

  export type ResBookingSelectScalar = {
    id?: boolean
    restaurantId?: boolean
    tableId?: boolean
    guestName?: boolean
    guestPhone?: boolean
    guestEmail?: boolean
    pax?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    tags?: boolean
    notes?: boolean
    origin?: boolean
    stripeCustomerId?: boolean
    stripePaymentMethodId?: boolean
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idempotencyKey?: boolean
    channelId?: boolean
  }

  export type ResBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    table?: boolean | ResBooking$tableArgs<ExtArgs>
    channel?: boolean | ResBooking$channelArgs<ExtArgs>
  }
  export type ResBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    table?: boolean | ResBooking$tableArgs<ExtArgs>
    channel?: boolean | ResBooking$channelArgs<ExtArgs>
  }

  export type $ResBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResBooking"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      table: Prisma.$TablePayload<ExtArgs> | null
      channel: Prisma.$RestaurantChannelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      restaurantId: string
      tableId: string | null
      guestName: string
      guestPhone: string | null
      guestEmail: string | null
      pax: number
      date: Date
      duration: number
      status: string
      tags: string | null
      notes: string | null
      origin: string
      stripeCustomerId: string | null
      stripePaymentMethodId: string | null
      smsSent: boolean
      emailSent: boolean
      createdAt: Date
      updatedAt: Date
      idempotencyKey: string | null
      channelId: string | null
    }, ExtArgs["result"]["resBooking"]>
    composites: {}
  }

  type ResBookingGetPayload<S extends boolean | null | undefined | ResBookingDefaultArgs> = $Result.GetResult<Prisma.$ResBookingPayload, S>

  type ResBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResBookingCountAggregateInputType | true
    }

  export interface ResBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResBooking'], meta: { name: 'ResBooking' } }
    /**
     * Find zero or one ResBooking that matches the filter.
     * @param {ResBookingFindUniqueArgs} args - Arguments to find a ResBooking
     * @example
     * // Get one ResBooking
     * const resBooking = await prisma.resBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResBookingFindUniqueArgs>(args: SelectSubset<T, ResBookingFindUniqueArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResBookingFindUniqueOrThrowArgs} args - Arguments to find a ResBooking
     * @example
     * // Get one ResBooking
     * const resBooking = await prisma.resBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ResBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingFindFirstArgs} args - Arguments to find a ResBooking
     * @example
     * // Get one ResBooking
     * const resBooking = await prisma.resBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResBookingFindFirstArgs>(args?: SelectSubset<T, ResBookingFindFirstArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingFindFirstOrThrowArgs} args - Arguments to find a ResBooking
     * @example
     * // Get one ResBooking
     * const resBooking = await prisma.resBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ResBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResBookings
     * const resBookings = await prisma.resBooking.findMany()
     * 
     * // Get first 10 ResBookings
     * const resBookings = await prisma.resBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resBookingWithIdOnly = await prisma.resBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResBookingFindManyArgs>(args?: SelectSubset<T, ResBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResBooking.
     * @param {ResBookingCreateArgs} args - Arguments to create a ResBooking.
     * @example
     * // Create one ResBooking
     * const ResBooking = await prisma.resBooking.create({
     *   data: {
     *     // ... data to create a ResBooking
     *   }
     * })
     * 
     */
    create<T extends ResBookingCreateArgs>(args: SelectSubset<T, ResBookingCreateArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResBookings.
     * @param {ResBookingCreateManyArgs} args - Arguments to create many ResBookings.
     * @example
     * // Create many ResBookings
     * const resBooking = await prisma.resBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResBookingCreateManyArgs>(args?: SelectSubset<T, ResBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResBookings and returns the data saved in the database.
     * @param {ResBookingCreateManyAndReturnArgs} args - Arguments to create many ResBookings.
     * @example
     * // Create many ResBookings
     * const resBooking = await prisma.resBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResBookings and only return the `id`
     * const resBookingWithIdOnly = await prisma.resBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ResBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResBooking.
     * @param {ResBookingDeleteArgs} args - Arguments to delete one ResBooking.
     * @example
     * // Delete one ResBooking
     * const ResBooking = await prisma.resBooking.delete({
     *   where: {
     *     // ... filter to delete one ResBooking
     *   }
     * })
     * 
     */
    delete<T extends ResBookingDeleteArgs>(args: SelectSubset<T, ResBookingDeleteArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResBooking.
     * @param {ResBookingUpdateArgs} args - Arguments to update one ResBooking.
     * @example
     * // Update one ResBooking
     * const resBooking = await prisma.resBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResBookingUpdateArgs>(args: SelectSubset<T, ResBookingUpdateArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResBookings.
     * @param {ResBookingDeleteManyArgs} args - Arguments to filter ResBookings to delete.
     * @example
     * // Delete a few ResBookings
     * const { count } = await prisma.resBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResBookingDeleteManyArgs>(args?: SelectSubset<T, ResBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResBookings
     * const resBooking = await prisma.resBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResBookingUpdateManyArgs>(args: SelectSubset<T, ResBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResBooking.
     * @param {ResBookingUpsertArgs} args - Arguments to update or create a ResBooking.
     * @example
     * // Update or create a ResBooking
     * const resBooking = await prisma.resBooking.upsert({
     *   create: {
     *     // ... data to create a ResBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResBooking we want to update
     *   }
     * })
     */
    upsert<T extends ResBookingUpsertArgs>(args: SelectSubset<T, ResBookingUpsertArgs<ExtArgs>>): Prisma__ResBookingClient<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingCountArgs} args - Arguments to filter ResBookings to count.
     * @example
     * // Count the number of ResBookings
     * const count = await prisma.resBooking.count({
     *   where: {
     *     // ... the filter for the ResBookings we want to count
     *   }
     * })
    **/
    count<T extends ResBookingCountArgs>(
      args?: Subset<T, ResBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResBookingAggregateArgs>(args: Subset<T, ResBookingAggregateArgs>): Prisma.PrismaPromise<GetResBookingAggregateType<T>>

    /**
     * Group by ResBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResBookingGroupByArgs['orderBy'] }
        : { orderBy?: ResBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResBooking model
   */
  readonly fields: ResBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    table<T extends ResBooking$tableArgs<ExtArgs> = {}>(args?: Subset<T, ResBooking$tableArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    channel<T extends ResBooking$channelArgs<ExtArgs> = {}>(args?: Subset<T, ResBooking$channelArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResBooking model
   */ 
  interface ResBookingFieldRefs {
    readonly id: FieldRef<"ResBooking", 'String'>
    readonly restaurantId: FieldRef<"ResBooking", 'String'>
    readonly tableId: FieldRef<"ResBooking", 'String'>
    readonly guestName: FieldRef<"ResBooking", 'String'>
    readonly guestPhone: FieldRef<"ResBooking", 'String'>
    readonly guestEmail: FieldRef<"ResBooking", 'String'>
    readonly pax: FieldRef<"ResBooking", 'Int'>
    readonly date: FieldRef<"ResBooking", 'DateTime'>
    readonly duration: FieldRef<"ResBooking", 'Int'>
    readonly status: FieldRef<"ResBooking", 'String'>
    readonly tags: FieldRef<"ResBooking", 'String'>
    readonly notes: FieldRef<"ResBooking", 'String'>
    readonly origin: FieldRef<"ResBooking", 'String'>
    readonly stripeCustomerId: FieldRef<"ResBooking", 'String'>
    readonly stripePaymentMethodId: FieldRef<"ResBooking", 'String'>
    readonly smsSent: FieldRef<"ResBooking", 'Boolean'>
    readonly emailSent: FieldRef<"ResBooking", 'Boolean'>
    readonly createdAt: FieldRef<"ResBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ResBooking", 'DateTime'>
    readonly idempotencyKey: FieldRef<"ResBooking", 'String'>
    readonly channelId: FieldRef<"ResBooking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResBooking findUnique
   */
  export type ResBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter, which ResBooking to fetch.
     */
    where: ResBookingWhereUniqueInput
  }

  /**
   * ResBooking findUniqueOrThrow
   */
  export type ResBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter, which ResBooking to fetch.
     */
    where: ResBookingWhereUniqueInput
  }

  /**
   * ResBooking findFirst
   */
  export type ResBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter, which ResBooking to fetch.
     */
    where?: ResBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResBookings to fetch.
     */
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResBookings.
     */
    cursor?: ResBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResBookings.
     */
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * ResBooking findFirstOrThrow
   */
  export type ResBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter, which ResBooking to fetch.
     */
    where?: ResBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResBookings to fetch.
     */
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResBookings.
     */
    cursor?: ResBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResBookings.
     */
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * ResBooking findMany
   */
  export type ResBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter, which ResBookings to fetch.
     */
    where?: ResBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResBookings to fetch.
     */
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResBookings.
     */
    cursor?: ResBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResBookings.
     */
    skip?: number
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * ResBooking create
   */
  export type ResBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ResBooking.
     */
    data: XOR<ResBookingCreateInput, ResBookingUncheckedCreateInput>
  }

  /**
   * ResBooking createMany
   */
  export type ResBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResBookings.
     */
    data: ResBookingCreateManyInput | ResBookingCreateManyInput[]
  }

  /**
   * ResBooking createManyAndReturn
   */
  export type ResBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResBookings.
     */
    data: ResBookingCreateManyInput | ResBookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResBooking update
   */
  export type ResBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ResBooking.
     */
    data: XOR<ResBookingUpdateInput, ResBookingUncheckedUpdateInput>
    /**
     * Choose, which ResBooking to update.
     */
    where: ResBookingWhereUniqueInput
  }

  /**
   * ResBooking updateMany
   */
  export type ResBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResBookings.
     */
    data: XOR<ResBookingUpdateManyMutationInput, ResBookingUncheckedUpdateManyInput>
    /**
     * Filter which ResBookings to update
     */
    where?: ResBookingWhereInput
  }

  /**
   * ResBooking upsert
   */
  export type ResBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ResBooking to update in case it exists.
     */
    where: ResBookingWhereUniqueInput
    /**
     * In case the ResBooking found by the `where` argument doesn't exist, create a new ResBooking with this data.
     */
    create: XOR<ResBookingCreateInput, ResBookingUncheckedCreateInput>
    /**
     * In case the ResBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResBookingUpdateInput, ResBookingUncheckedUpdateInput>
  }

  /**
   * ResBooking delete
   */
  export type ResBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    /**
     * Filter which ResBooking to delete.
     */
    where: ResBookingWhereUniqueInput
  }

  /**
   * ResBooking deleteMany
   */
  export type ResBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResBookings to delete
     */
    where?: ResBookingWhereInput
  }

  /**
   * ResBooking.table
   */
  export type ResBooking$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
  }

  /**
   * ResBooking.channel
   */
  export type ResBooking$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    where?: RestaurantChannelWhereInput
  }

  /**
   * ResBooking without action
   */
  export type ResBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantChannel
   */

  export type AggregateRestaurantChannel = {
    _count: RestaurantChannelCountAggregateOutputType | null
    _avg: RestaurantChannelAvgAggregateOutputType | null
    _sum: RestaurantChannelSumAggregateOutputType | null
    _min: RestaurantChannelMinAggregateOutputType | null
    _max: RestaurantChannelMaxAggregateOutputType | null
  }

  export type RestaurantChannelAvgAggregateOutputType = {
    commission: Decimal | null
  }

  export type RestaurantChannelSumAggregateOutputType = {
    commission: Decimal | null
  }

  export type RestaurantChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    commission: Decimal | null
  }

  export type RestaurantChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    commission: Decimal | null
  }

  export type RestaurantChannelCountAggregateOutputType = {
    id: number
    name: number
    commission: number
    _all: number
  }


  export type RestaurantChannelAvgAggregateInputType = {
    commission?: true
  }

  export type RestaurantChannelSumAggregateInputType = {
    commission?: true
  }

  export type RestaurantChannelMinAggregateInputType = {
    id?: true
    name?: true
    commission?: true
  }

  export type RestaurantChannelMaxAggregateInputType = {
    id?: true
    name?: true
    commission?: true
  }

  export type RestaurantChannelCountAggregateInputType = {
    id?: true
    name?: true
    commission?: true
    _all?: true
  }

  export type RestaurantChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantChannel to aggregate.
     */
    where?: RestaurantChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantChannels to fetch.
     */
    orderBy?: RestaurantChannelOrderByWithRelationInput | RestaurantChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantChannels
    **/
    _count?: true | RestaurantChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantChannelMaxAggregateInputType
  }

  export type GetRestaurantChannelAggregateType<T extends RestaurantChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantChannel[P]>
      : GetScalarType<T[P], AggregateRestaurantChannel[P]>
  }




  export type RestaurantChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantChannelWhereInput
    orderBy?: RestaurantChannelOrderByWithAggregationInput | RestaurantChannelOrderByWithAggregationInput[]
    by: RestaurantChannelScalarFieldEnum[] | RestaurantChannelScalarFieldEnum
    having?: RestaurantChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantChannelCountAggregateInputType | true
    _avg?: RestaurantChannelAvgAggregateInputType
    _sum?: RestaurantChannelSumAggregateInputType
    _min?: RestaurantChannelMinAggregateInputType
    _max?: RestaurantChannelMaxAggregateInputType
  }

  export type RestaurantChannelGroupByOutputType = {
    id: string
    name: string
    commission: Decimal
    _count: RestaurantChannelCountAggregateOutputType | null
    _avg: RestaurantChannelAvgAggregateOutputType | null
    _sum: RestaurantChannelSumAggregateOutputType | null
    _min: RestaurantChannelMinAggregateOutputType | null
    _max: RestaurantChannelMaxAggregateOutputType | null
  }

  type GetRestaurantChannelGroupByPayload<T extends RestaurantChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantChannelGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantChannelGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    commission?: boolean
    resBookings?: boolean | RestaurantChannel$resBookingsArgs<ExtArgs>
    _count?: boolean | RestaurantChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantChannel"]>

  export type RestaurantChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    commission?: boolean
  }, ExtArgs["result"]["restaurantChannel"]>

  export type RestaurantChannelSelectScalar = {
    id?: boolean
    name?: boolean
    commission?: boolean
  }

  export type RestaurantChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resBookings?: boolean | RestaurantChannel$resBookingsArgs<ExtArgs>
    _count?: boolean | RestaurantChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RestaurantChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantChannel"
    objects: {
      resBookings: Prisma.$ResBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      commission: Prisma.Decimal
    }, ExtArgs["result"]["restaurantChannel"]>
    composites: {}
  }

  type RestaurantChannelGetPayload<S extends boolean | null | undefined | RestaurantChannelDefaultArgs> = $Result.GetResult<Prisma.$RestaurantChannelPayload, S>

  type RestaurantChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestaurantChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestaurantChannelCountAggregateInputType | true
    }

  export interface RestaurantChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantChannel'], meta: { name: 'RestaurantChannel' } }
    /**
     * Find zero or one RestaurantChannel that matches the filter.
     * @param {RestaurantChannelFindUniqueArgs} args - Arguments to find a RestaurantChannel
     * @example
     * // Get one RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantChannelFindUniqueArgs>(args: SelectSubset<T, RestaurantChannelFindUniqueArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RestaurantChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RestaurantChannelFindUniqueOrThrowArgs} args - Arguments to find a RestaurantChannel
     * @example
     * // Get one RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RestaurantChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelFindFirstArgs} args - Arguments to find a RestaurantChannel
     * @example
     * // Get one RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantChannelFindFirstArgs>(args?: SelectSubset<T, RestaurantChannelFindFirstArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RestaurantChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelFindFirstOrThrowArgs} args - Arguments to find a RestaurantChannel
     * @example
     * // Get one RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RestaurantChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantChannels
     * const restaurantChannels = await prisma.restaurantChannel.findMany()
     * 
     * // Get first 10 RestaurantChannels
     * const restaurantChannels = await prisma.restaurantChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantChannelWithIdOnly = await prisma.restaurantChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantChannelFindManyArgs>(args?: SelectSubset<T, RestaurantChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RestaurantChannel.
     * @param {RestaurantChannelCreateArgs} args - Arguments to create a RestaurantChannel.
     * @example
     * // Create one RestaurantChannel
     * const RestaurantChannel = await prisma.restaurantChannel.create({
     *   data: {
     *     // ... data to create a RestaurantChannel
     *   }
     * })
     * 
     */
    create<T extends RestaurantChannelCreateArgs>(args: SelectSubset<T, RestaurantChannelCreateArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RestaurantChannels.
     * @param {RestaurantChannelCreateManyArgs} args - Arguments to create many RestaurantChannels.
     * @example
     * // Create many RestaurantChannels
     * const restaurantChannel = await prisma.restaurantChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantChannelCreateManyArgs>(args?: SelectSubset<T, RestaurantChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantChannels and returns the data saved in the database.
     * @param {RestaurantChannelCreateManyAndReturnArgs} args - Arguments to create many RestaurantChannels.
     * @example
     * // Create many RestaurantChannels
     * const restaurantChannel = await prisma.restaurantChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantChannels and only return the `id`
     * const restaurantChannelWithIdOnly = await prisma.restaurantChannel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RestaurantChannel.
     * @param {RestaurantChannelDeleteArgs} args - Arguments to delete one RestaurantChannel.
     * @example
     * // Delete one RestaurantChannel
     * const RestaurantChannel = await prisma.restaurantChannel.delete({
     *   where: {
     *     // ... filter to delete one RestaurantChannel
     *   }
     * })
     * 
     */
    delete<T extends RestaurantChannelDeleteArgs>(args: SelectSubset<T, RestaurantChannelDeleteArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RestaurantChannel.
     * @param {RestaurantChannelUpdateArgs} args - Arguments to update one RestaurantChannel.
     * @example
     * // Update one RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantChannelUpdateArgs>(args: SelectSubset<T, RestaurantChannelUpdateArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RestaurantChannels.
     * @param {RestaurantChannelDeleteManyArgs} args - Arguments to filter RestaurantChannels to delete.
     * @example
     * // Delete a few RestaurantChannels
     * const { count } = await prisma.restaurantChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantChannelDeleteManyArgs>(args?: SelectSubset<T, RestaurantChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantChannels
     * const restaurantChannel = await prisma.restaurantChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantChannelUpdateManyArgs>(args: SelectSubset<T, RestaurantChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RestaurantChannel.
     * @param {RestaurantChannelUpsertArgs} args - Arguments to update or create a RestaurantChannel.
     * @example
     * // Update or create a RestaurantChannel
     * const restaurantChannel = await prisma.restaurantChannel.upsert({
     *   create: {
     *     // ... data to create a RestaurantChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantChannel we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantChannelUpsertArgs>(args: SelectSubset<T, RestaurantChannelUpsertArgs<ExtArgs>>): Prisma__RestaurantChannelClient<$Result.GetResult<Prisma.$RestaurantChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RestaurantChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelCountArgs} args - Arguments to filter RestaurantChannels to count.
     * @example
     * // Count the number of RestaurantChannels
     * const count = await prisma.restaurantChannel.count({
     *   where: {
     *     // ... the filter for the RestaurantChannels we want to count
     *   }
     * })
    **/
    count<T extends RestaurantChannelCountArgs>(
      args?: Subset<T, RestaurantChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantChannelAggregateArgs>(args: Subset<T, RestaurantChannelAggregateArgs>): Prisma.PrismaPromise<GetRestaurantChannelAggregateType<T>>

    /**
     * Group by RestaurantChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantChannelGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantChannel model
   */
  readonly fields: RestaurantChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resBookings<T extends RestaurantChannel$resBookingsArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantChannel$resBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantChannel model
   */ 
  interface RestaurantChannelFieldRefs {
    readonly id: FieldRef<"RestaurantChannel", 'String'>
    readonly name: FieldRef<"RestaurantChannel", 'String'>
    readonly commission: FieldRef<"RestaurantChannel", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantChannel findUnique
   */
  export type RestaurantChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantChannel to fetch.
     */
    where: RestaurantChannelWhereUniqueInput
  }

  /**
   * RestaurantChannel findUniqueOrThrow
   */
  export type RestaurantChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantChannel to fetch.
     */
    where: RestaurantChannelWhereUniqueInput
  }

  /**
   * RestaurantChannel findFirst
   */
  export type RestaurantChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantChannel to fetch.
     */
    where?: RestaurantChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantChannels to fetch.
     */
    orderBy?: RestaurantChannelOrderByWithRelationInput | RestaurantChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantChannels.
     */
    cursor?: RestaurantChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantChannels.
     */
    distinct?: RestaurantChannelScalarFieldEnum | RestaurantChannelScalarFieldEnum[]
  }

  /**
   * RestaurantChannel findFirstOrThrow
   */
  export type RestaurantChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantChannel to fetch.
     */
    where?: RestaurantChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantChannels to fetch.
     */
    orderBy?: RestaurantChannelOrderByWithRelationInput | RestaurantChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantChannels.
     */
    cursor?: RestaurantChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantChannels.
     */
    distinct?: RestaurantChannelScalarFieldEnum | RestaurantChannelScalarFieldEnum[]
  }

  /**
   * RestaurantChannel findMany
   */
  export type RestaurantChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantChannels to fetch.
     */
    where?: RestaurantChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantChannels to fetch.
     */
    orderBy?: RestaurantChannelOrderByWithRelationInput | RestaurantChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantChannels.
     */
    cursor?: RestaurantChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantChannels.
     */
    skip?: number
    distinct?: RestaurantChannelScalarFieldEnum | RestaurantChannelScalarFieldEnum[]
  }

  /**
   * RestaurantChannel create
   */
  export type RestaurantChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantChannel.
     */
    data: XOR<RestaurantChannelCreateInput, RestaurantChannelUncheckedCreateInput>
  }

  /**
   * RestaurantChannel createMany
   */
  export type RestaurantChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantChannels.
     */
    data: RestaurantChannelCreateManyInput | RestaurantChannelCreateManyInput[]
  }

  /**
   * RestaurantChannel createManyAndReturn
   */
  export type RestaurantChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RestaurantChannels.
     */
    data: RestaurantChannelCreateManyInput | RestaurantChannelCreateManyInput[]
  }

  /**
   * RestaurantChannel update
   */
  export type RestaurantChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantChannel.
     */
    data: XOR<RestaurantChannelUpdateInput, RestaurantChannelUncheckedUpdateInput>
    /**
     * Choose, which RestaurantChannel to update.
     */
    where: RestaurantChannelWhereUniqueInput
  }

  /**
   * RestaurantChannel updateMany
   */
  export type RestaurantChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantChannels.
     */
    data: XOR<RestaurantChannelUpdateManyMutationInput, RestaurantChannelUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantChannels to update
     */
    where?: RestaurantChannelWhereInput
  }

  /**
   * RestaurantChannel upsert
   */
  export type RestaurantChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantChannel to update in case it exists.
     */
    where: RestaurantChannelWhereUniqueInput
    /**
     * In case the RestaurantChannel found by the `where` argument doesn't exist, create a new RestaurantChannel with this data.
     */
    create: XOR<RestaurantChannelCreateInput, RestaurantChannelUncheckedCreateInput>
    /**
     * In case the RestaurantChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantChannelUpdateInput, RestaurantChannelUncheckedUpdateInput>
  }

  /**
   * RestaurantChannel delete
   */
  export type RestaurantChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
    /**
     * Filter which RestaurantChannel to delete.
     */
    where: RestaurantChannelWhereUniqueInput
  }

  /**
   * RestaurantChannel deleteMany
   */
  export type RestaurantChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantChannels to delete
     */
    where?: RestaurantChannelWhereInput
  }

  /**
   * RestaurantChannel.resBookings
   */
  export type RestaurantChannel$resBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResBooking
     */
    select?: ResBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResBookingInclude<ExtArgs> | null
    where?: ResBookingWhereInput
    orderBy?: ResBookingOrderByWithRelationInput | ResBookingOrderByWithRelationInput[]
    cursor?: ResBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResBookingScalarFieldEnum | ResBookingScalarFieldEnum[]
  }

  /**
   * RestaurantChannel without action
   */
  export type RestaurantChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantChannel
     */
    select?: RestaurantChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantChannelInclude<ExtArgs> | null
  }


  /**
   * Model ResPolicy
   */

  export type AggregateResPolicy = {
    _count: ResPolicyCountAggregateOutputType | null
    _avg: ResPolicyAvgAggregateOutputType | null
    _sum: ResPolicySumAggregateOutputType | null
    _min: ResPolicyMinAggregateOutputType | null
    _max: ResPolicyMaxAggregateOutputType | null
  }

  export type ResPolicyAvgAggregateOutputType = {
    cancelHours: number | null
    noShowFee: Decimal | null
  }

  export type ResPolicySumAggregateOutputType = {
    cancelHours: number | null
    noShowFee: Decimal | null
  }

  export type ResPolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    cancelHours: number | null
    noShowFee: Decimal | null
    requireCreditCard: boolean | null
    isActive: boolean | null
  }

  export type ResPolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cancelHours: number | null
    noShowFee: Decimal | null
    requireCreditCard: boolean | null
    isActive: boolean | null
  }

  export type ResPolicyCountAggregateOutputType = {
    id: number
    name: number
    cancelHours: number
    noShowFee: number
    requireCreditCard: number
    isActive: number
    _all: number
  }


  export type ResPolicyAvgAggregateInputType = {
    cancelHours?: true
    noShowFee?: true
  }

  export type ResPolicySumAggregateInputType = {
    cancelHours?: true
    noShowFee?: true
  }

  export type ResPolicyMinAggregateInputType = {
    id?: true
    name?: true
    cancelHours?: true
    noShowFee?: true
    requireCreditCard?: true
    isActive?: true
  }

  export type ResPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    cancelHours?: true
    noShowFee?: true
    requireCreditCard?: true
    isActive?: true
  }

  export type ResPolicyCountAggregateInputType = {
    id?: true
    name?: true
    cancelHours?: true
    noShowFee?: true
    requireCreditCard?: true
    isActive?: true
    _all?: true
  }

  export type ResPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResPolicy to aggregate.
     */
    where?: ResPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResPolicies to fetch.
     */
    orderBy?: ResPolicyOrderByWithRelationInput | ResPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResPolicies
    **/
    _count?: true | ResPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResPolicyMaxAggregateInputType
  }

  export type GetResPolicyAggregateType<T extends ResPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateResPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResPolicy[P]>
      : GetScalarType<T[P], AggregateResPolicy[P]>
  }




  export type ResPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResPolicyWhereInput
    orderBy?: ResPolicyOrderByWithAggregationInput | ResPolicyOrderByWithAggregationInput[]
    by: ResPolicyScalarFieldEnum[] | ResPolicyScalarFieldEnum
    having?: ResPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResPolicyCountAggregateInputType | true
    _avg?: ResPolicyAvgAggregateInputType
    _sum?: ResPolicySumAggregateInputType
    _min?: ResPolicyMinAggregateInputType
    _max?: ResPolicyMaxAggregateInputType
  }

  export type ResPolicyGroupByOutputType = {
    id: string
    name: string
    cancelHours: number
    noShowFee: Decimal
    requireCreditCard: boolean
    isActive: boolean
    _count: ResPolicyCountAggregateOutputType | null
    _avg: ResPolicyAvgAggregateOutputType | null
    _sum: ResPolicySumAggregateOutputType | null
    _min: ResPolicyMinAggregateOutputType | null
    _max: ResPolicyMaxAggregateOutputType | null
  }

  type GetResPolicyGroupByPayload<T extends ResPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], ResPolicyGroupByOutputType[P]>
        }
      >
    >


  export type ResPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cancelHours?: boolean
    noShowFee?: boolean
    requireCreditCard?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["resPolicy"]>

  export type ResPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cancelHours?: boolean
    noShowFee?: boolean
    requireCreditCard?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["resPolicy"]>

  export type ResPolicySelectScalar = {
    id?: boolean
    name?: boolean
    cancelHours?: boolean
    noShowFee?: boolean
    requireCreditCard?: boolean
    isActive?: boolean
  }


  export type $ResPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cancelHours: number
      noShowFee: Prisma.Decimal
      requireCreditCard: boolean
      isActive: boolean
    }, ExtArgs["result"]["resPolicy"]>
    composites: {}
  }

  type ResPolicyGetPayload<S extends boolean | null | undefined | ResPolicyDefaultArgs> = $Result.GetResult<Prisma.$ResPolicyPayload, S>

  type ResPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResPolicyCountAggregateInputType | true
    }

  export interface ResPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResPolicy'], meta: { name: 'ResPolicy' } }
    /**
     * Find zero or one ResPolicy that matches the filter.
     * @param {ResPolicyFindUniqueArgs} args - Arguments to find a ResPolicy
     * @example
     * // Get one ResPolicy
     * const resPolicy = await prisma.resPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResPolicyFindUniqueArgs>(args: SelectSubset<T, ResPolicyFindUniqueArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResPolicyFindUniqueOrThrowArgs} args - Arguments to find a ResPolicy
     * @example
     * // Get one ResPolicy
     * const resPolicy = await prisma.resPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, ResPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyFindFirstArgs} args - Arguments to find a ResPolicy
     * @example
     * // Get one ResPolicy
     * const resPolicy = await prisma.resPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResPolicyFindFirstArgs>(args?: SelectSubset<T, ResPolicyFindFirstArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyFindFirstOrThrowArgs} args - Arguments to find a ResPolicy
     * @example
     * // Get one ResPolicy
     * const resPolicy = await prisma.resPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, ResPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResPolicies
     * const resPolicies = await prisma.resPolicy.findMany()
     * 
     * // Get first 10 ResPolicies
     * const resPolicies = await prisma.resPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resPolicyWithIdOnly = await prisma.resPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResPolicyFindManyArgs>(args?: SelectSubset<T, ResPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResPolicy.
     * @param {ResPolicyCreateArgs} args - Arguments to create a ResPolicy.
     * @example
     * // Create one ResPolicy
     * const ResPolicy = await prisma.resPolicy.create({
     *   data: {
     *     // ... data to create a ResPolicy
     *   }
     * })
     * 
     */
    create<T extends ResPolicyCreateArgs>(args: SelectSubset<T, ResPolicyCreateArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResPolicies.
     * @param {ResPolicyCreateManyArgs} args - Arguments to create many ResPolicies.
     * @example
     * // Create many ResPolicies
     * const resPolicy = await prisma.resPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResPolicyCreateManyArgs>(args?: SelectSubset<T, ResPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResPolicies and returns the data saved in the database.
     * @param {ResPolicyCreateManyAndReturnArgs} args - Arguments to create many ResPolicies.
     * @example
     * // Create many ResPolicies
     * const resPolicy = await prisma.resPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResPolicies and only return the `id`
     * const resPolicyWithIdOnly = await prisma.resPolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, ResPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResPolicy.
     * @param {ResPolicyDeleteArgs} args - Arguments to delete one ResPolicy.
     * @example
     * // Delete one ResPolicy
     * const ResPolicy = await prisma.resPolicy.delete({
     *   where: {
     *     // ... filter to delete one ResPolicy
     *   }
     * })
     * 
     */
    delete<T extends ResPolicyDeleteArgs>(args: SelectSubset<T, ResPolicyDeleteArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResPolicy.
     * @param {ResPolicyUpdateArgs} args - Arguments to update one ResPolicy.
     * @example
     * // Update one ResPolicy
     * const resPolicy = await prisma.resPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResPolicyUpdateArgs>(args: SelectSubset<T, ResPolicyUpdateArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResPolicies.
     * @param {ResPolicyDeleteManyArgs} args - Arguments to filter ResPolicies to delete.
     * @example
     * // Delete a few ResPolicies
     * const { count } = await prisma.resPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResPolicyDeleteManyArgs>(args?: SelectSubset<T, ResPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResPolicies
     * const resPolicy = await prisma.resPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResPolicyUpdateManyArgs>(args: SelectSubset<T, ResPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResPolicy.
     * @param {ResPolicyUpsertArgs} args - Arguments to update or create a ResPolicy.
     * @example
     * // Update or create a ResPolicy
     * const resPolicy = await prisma.resPolicy.upsert({
     *   create: {
     *     // ... data to create a ResPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResPolicy we want to update
     *   }
     * })
     */
    upsert<T extends ResPolicyUpsertArgs>(args: SelectSubset<T, ResPolicyUpsertArgs<ExtArgs>>): Prisma__ResPolicyClient<$Result.GetResult<Prisma.$ResPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyCountArgs} args - Arguments to filter ResPolicies to count.
     * @example
     * // Count the number of ResPolicies
     * const count = await prisma.resPolicy.count({
     *   where: {
     *     // ... the filter for the ResPolicies we want to count
     *   }
     * })
    **/
    count<T extends ResPolicyCountArgs>(
      args?: Subset<T, ResPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResPolicyAggregateArgs>(args: Subset<T, ResPolicyAggregateArgs>): Prisma.PrismaPromise<GetResPolicyAggregateType<T>>

    /**
     * Group by ResPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResPolicyGroupByArgs['orderBy'] }
        : { orderBy?: ResPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResPolicy model
   */
  readonly fields: ResPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResPolicy model
   */ 
  interface ResPolicyFieldRefs {
    readonly id: FieldRef<"ResPolicy", 'String'>
    readonly name: FieldRef<"ResPolicy", 'String'>
    readonly cancelHours: FieldRef<"ResPolicy", 'Int'>
    readonly noShowFee: FieldRef<"ResPolicy", 'Decimal'>
    readonly requireCreditCard: FieldRef<"ResPolicy", 'Boolean'>
    readonly isActive: FieldRef<"ResPolicy", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ResPolicy findUnique
   */
  export type ResPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter, which ResPolicy to fetch.
     */
    where: ResPolicyWhereUniqueInput
  }

  /**
   * ResPolicy findUniqueOrThrow
   */
  export type ResPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter, which ResPolicy to fetch.
     */
    where: ResPolicyWhereUniqueInput
  }

  /**
   * ResPolicy findFirst
   */
  export type ResPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter, which ResPolicy to fetch.
     */
    where?: ResPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResPolicies to fetch.
     */
    orderBy?: ResPolicyOrderByWithRelationInput | ResPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResPolicies.
     */
    cursor?: ResPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResPolicies.
     */
    distinct?: ResPolicyScalarFieldEnum | ResPolicyScalarFieldEnum[]
  }

  /**
   * ResPolicy findFirstOrThrow
   */
  export type ResPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter, which ResPolicy to fetch.
     */
    where?: ResPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResPolicies to fetch.
     */
    orderBy?: ResPolicyOrderByWithRelationInput | ResPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResPolicies.
     */
    cursor?: ResPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResPolicies.
     */
    distinct?: ResPolicyScalarFieldEnum | ResPolicyScalarFieldEnum[]
  }

  /**
   * ResPolicy findMany
   */
  export type ResPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter, which ResPolicies to fetch.
     */
    where?: ResPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResPolicies to fetch.
     */
    orderBy?: ResPolicyOrderByWithRelationInput | ResPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResPolicies.
     */
    cursor?: ResPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResPolicies.
     */
    skip?: number
    distinct?: ResPolicyScalarFieldEnum | ResPolicyScalarFieldEnum[]
  }

  /**
   * ResPolicy create
   */
  export type ResPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * The data needed to create a ResPolicy.
     */
    data: XOR<ResPolicyCreateInput, ResPolicyUncheckedCreateInput>
  }

  /**
   * ResPolicy createMany
   */
  export type ResPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResPolicies.
     */
    data: ResPolicyCreateManyInput | ResPolicyCreateManyInput[]
  }

  /**
   * ResPolicy createManyAndReturn
   */
  export type ResPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResPolicies.
     */
    data: ResPolicyCreateManyInput | ResPolicyCreateManyInput[]
  }

  /**
   * ResPolicy update
   */
  export type ResPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * The data needed to update a ResPolicy.
     */
    data: XOR<ResPolicyUpdateInput, ResPolicyUncheckedUpdateInput>
    /**
     * Choose, which ResPolicy to update.
     */
    where: ResPolicyWhereUniqueInput
  }

  /**
   * ResPolicy updateMany
   */
  export type ResPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResPolicies.
     */
    data: XOR<ResPolicyUpdateManyMutationInput, ResPolicyUncheckedUpdateManyInput>
    /**
     * Filter which ResPolicies to update
     */
    where?: ResPolicyWhereInput
  }

  /**
   * ResPolicy upsert
   */
  export type ResPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * The filter to search for the ResPolicy to update in case it exists.
     */
    where: ResPolicyWhereUniqueInput
    /**
     * In case the ResPolicy found by the `where` argument doesn't exist, create a new ResPolicy with this data.
     */
    create: XOR<ResPolicyCreateInput, ResPolicyUncheckedCreateInput>
    /**
     * In case the ResPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResPolicyUpdateInput, ResPolicyUncheckedUpdateInput>
  }

  /**
   * ResPolicy delete
   */
  export type ResPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
    /**
     * Filter which ResPolicy to delete.
     */
    where: ResPolicyWhereUniqueInput
  }

  /**
   * ResPolicy deleteMany
   */
  export type ResPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResPolicies to delete
     */
    where?: ResPolicyWhereInput
  }

  /**
   * ResPolicy without action
   */
  export type ResPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResPolicy
     */
    select?: ResPolicySelect<ExtArgs> | null
  }


  /**
   * Model TableHold
   */

  export type AggregateTableHold = {
    _count: TableHoldCountAggregateOutputType | null
    _min: TableHoldMinAggregateOutputType | null
    _max: TableHoldMaxAggregateOutputType | null
  }

  export type TableHoldMinAggregateOutputType = {
    id: string | null
    tableId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type TableHoldMaxAggregateOutputType = {
    id: string | null
    tableId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type TableHoldCountAggregateOutputType = {
    id: number
    tableId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type TableHoldMinAggregateInputType = {
    id?: true
    tableId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type TableHoldMaxAggregateInputType = {
    id?: true
    tableId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type TableHoldCountAggregateInputType = {
    id?: true
    tableId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type TableHoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableHold to aggregate.
     */
    where?: TableHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableHolds to fetch.
     */
    orderBy?: TableHoldOrderByWithRelationInput | TableHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableHolds
    **/
    _count?: true | TableHoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableHoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableHoldMaxAggregateInputType
  }

  export type GetTableHoldAggregateType<T extends TableHoldAggregateArgs> = {
        [P in keyof T & keyof AggregateTableHold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableHold[P]>
      : GetScalarType<T[P], AggregateTableHold[P]>
  }




  export type TableHoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableHoldWhereInput
    orderBy?: TableHoldOrderByWithAggregationInput | TableHoldOrderByWithAggregationInput[]
    by: TableHoldScalarFieldEnum[] | TableHoldScalarFieldEnum
    having?: TableHoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableHoldCountAggregateInputType | true
    _min?: TableHoldMinAggregateInputType
    _max?: TableHoldMaxAggregateInputType
  }

  export type TableHoldGroupByOutputType = {
    id: string
    tableId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: TableHoldCountAggregateOutputType | null
    _min: TableHoldMinAggregateOutputType | null
    _max: TableHoldMaxAggregateOutputType | null
  }

  type GetTableHoldGroupByPayload<T extends TableHoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableHoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableHoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableHoldGroupByOutputType[P]>
            : GetScalarType<T[P], TableHoldGroupByOutputType[P]>
        }
      >
    >


  export type TableHoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableHold"]>

  export type TableHoldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableHold"]>

  export type TableHoldSelectScalar = {
    id?: boolean
    tableId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type TableHoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | TableDefaultArgs<ExtArgs>
  }
  export type TableHoldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | TableDefaultArgs<ExtArgs>
  }

  export type $TableHoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TableHold"
    objects: {
      table: Prisma.$TablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["tableHold"]>
    composites: {}
  }

  type TableHoldGetPayload<S extends boolean | null | undefined | TableHoldDefaultArgs> = $Result.GetResult<Prisma.$TableHoldPayload, S>

  type TableHoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TableHoldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TableHoldCountAggregateInputType | true
    }

  export interface TableHoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TableHold'], meta: { name: 'TableHold' } }
    /**
     * Find zero or one TableHold that matches the filter.
     * @param {TableHoldFindUniqueArgs} args - Arguments to find a TableHold
     * @example
     * // Get one TableHold
     * const tableHold = await prisma.tableHold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableHoldFindUniqueArgs>(args: SelectSubset<T, TableHoldFindUniqueArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TableHold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TableHoldFindUniqueOrThrowArgs} args - Arguments to find a TableHold
     * @example
     * // Get one TableHold
     * const tableHold = await prisma.tableHold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableHoldFindUniqueOrThrowArgs>(args: SelectSubset<T, TableHoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TableHold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldFindFirstArgs} args - Arguments to find a TableHold
     * @example
     * // Get one TableHold
     * const tableHold = await prisma.tableHold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableHoldFindFirstArgs>(args?: SelectSubset<T, TableHoldFindFirstArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TableHold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldFindFirstOrThrowArgs} args - Arguments to find a TableHold
     * @example
     * // Get one TableHold
     * const tableHold = await prisma.tableHold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableHoldFindFirstOrThrowArgs>(args?: SelectSubset<T, TableHoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TableHolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableHolds
     * const tableHolds = await prisma.tableHold.findMany()
     * 
     * // Get first 10 TableHolds
     * const tableHolds = await prisma.tableHold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableHoldWithIdOnly = await prisma.tableHold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableHoldFindManyArgs>(args?: SelectSubset<T, TableHoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TableHold.
     * @param {TableHoldCreateArgs} args - Arguments to create a TableHold.
     * @example
     * // Create one TableHold
     * const TableHold = await prisma.tableHold.create({
     *   data: {
     *     // ... data to create a TableHold
     *   }
     * })
     * 
     */
    create<T extends TableHoldCreateArgs>(args: SelectSubset<T, TableHoldCreateArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TableHolds.
     * @param {TableHoldCreateManyArgs} args - Arguments to create many TableHolds.
     * @example
     * // Create many TableHolds
     * const tableHold = await prisma.tableHold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableHoldCreateManyArgs>(args?: SelectSubset<T, TableHoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TableHolds and returns the data saved in the database.
     * @param {TableHoldCreateManyAndReturnArgs} args - Arguments to create many TableHolds.
     * @example
     * // Create many TableHolds
     * const tableHold = await prisma.tableHold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TableHolds and only return the `id`
     * const tableHoldWithIdOnly = await prisma.tableHold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableHoldCreateManyAndReturnArgs>(args?: SelectSubset<T, TableHoldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TableHold.
     * @param {TableHoldDeleteArgs} args - Arguments to delete one TableHold.
     * @example
     * // Delete one TableHold
     * const TableHold = await prisma.tableHold.delete({
     *   where: {
     *     // ... filter to delete one TableHold
     *   }
     * })
     * 
     */
    delete<T extends TableHoldDeleteArgs>(args: SelectSubset<T, TableHoldDeleteArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TableHold.
     * @param {TableHoldUpdateArgs} args - Arguments to update one TableHold.
     * @example
     * // Update one TableHold
     * const tableHold = await prisma.tableHold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableHoldUpdateArgs>(args: SelectSubset<T, TableHoldUpdateArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TableHolds.
     * @param {TableHoldDeleteManyArgs} args - Arguments to filter TableHolds to delete.
     * @example
     * // Delete a few TableHolds
     * const { count } = await prisma.tableHold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableHoldDeleteManyArgs>(args?: SelectSubset<T, TableHoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableHolds
     * const tableHold = await prisma.tableHold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableHoldUpdateManyArgs>(args: SelectSubset<T, TableHoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TableHold.
     * @param {TableHoldUpsertArgs} args - Arguments to update or create a TableHold.
     * @example
     * // Update or create a TableHold
     * const tableHold = await prisma.tableHold.upsert({
     *   create: {
     *     // ... data to create a TableHold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableHold we want to update
     *   }
     * })
     */
    upsert<T extends TableHoldUpsertArgs>(args: SelectSubset<T, TableHoldUpsertArgs<ExtArgs>>): Prisma__TableHoldClient<$Result.GetResult<Prisma.$TableHoldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TableHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldCountArgs} args - Arguments to filter TableHolds to count.
     * @example
     * // Count the number of TableHolds
     * const count = await prisma.tableHold.count({
     *   where: {
     *     // ... the filter for the TableHolds we want to count
     *   }
     * })
    **/
    count<T extends TableHoldCountArgs>(
      args?: Subset<T, TableHoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableHoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableHoldAggregateArgs>(args: Subset<T, TableHoldAggregateArgs>): Prisma.PrismaPromise<GetTableHoldAggregateType<T>>

    /**
     * Group by TableHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableHoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableHoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableHoldGroupByArgs['orderBy'] }
        : { orderBy?: TableHoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableHoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableHoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TableHold model
   */
  readonly fields: TableHoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableHold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableHoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TableHold model
   */ 
  interface TableHoldFieldRefs {
    readonly id: FieldRef<"TableHold", 'String'>
    readonly tableId: FieldRef<"TableHold", 'String'>
    readonly token: FieldRef<"TableHold", 'String'>
    readonly expiresAt: FieldRef<"TableHold", 'DateTime'>
    readonly createdAt: FieldRef<"TableHold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TableHold findUnique
   */
  export type TableHoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter, which TableHold to fetch.
     */
    where: TableHoldWhereUniqueInput
  }

  /**
   * TableHold findUniqueOrThrow
   */
  export type TableHoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter, which TableHold to fetch.
     */
    where: TableHoldWhereUniqueInput
  }

  /**
   * TableHold findFirst
   */
  export type TableHoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter, which TableHold to fetch.
     */
    where?: TableHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableHolds to fetch.
     */
    orderBy?: TableHoldOrderByWithRelationInput | TableHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableHolds.
     */
    cursor?: TableHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableHolds.
     */
    distinct?: TableHoldScalarFieldEnum | TableHoldScalarFieldEnum[]
  }

  /**
   * TableHold findFirstOrThrow
   */
  export type TableHoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter, which TableHold to fetch.
     */
    where?: TableHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableHolds to fetch.
     */
    orderBy?: TableHoldOrderByWithRelationInput | TableHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableHolds.
     */
    cursor?: TableHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableHolds.
     */
    distinct?: TableHoldScalarFieldEnum | TableHoldScalarFieldEnum[]
  }

  /**
   * TableHold findMany
   */
  export type TableHoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter, which TableHolds to fetch.
     */
    where?: TableHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableHolds to fetch.
     */
    orderBy?: TableHoldOrderByWithRelationInput | TableHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableHolds.
     */
    cursor?: TableHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableHolds.
     */
    skip?: number
    distinct?: TableHoldScalarFieldEnum | TableHoldScalarFieldEnum[]
  }

  /**
   * TableHold create
   */
  export type TableHoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * The data needed to create a TableHold.
     */
    data: XOR<TableHoldCreateInput, TableHoldUncheckedCreateInput>
  }

  /**
   * TableHold createMany
   */
  export type TableHoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TableHolds.
     */
    data: TableHoldCreateManyInput | TableHoldCreateManyInput[]
  }

  /**
   * TableHold createManyAndReturn
   */
  export type TableHoldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TableHolds.
     */
    data: TableHoldCreateManyInput | TableHoldCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TableHold update
   */
  export type TableHoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * The data needed to update a TableHold.
     */
    data: XOR<TableHoldUpdateInput, TableHoldUncheckedUpdateInput>
    /**
     * Choose, which TableHold to update.
     */
    where: TableHoldWhereUniqueInput
  }

  /**
   * TableHold updateMany
   */
  export type TableHoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TableHolds.
     */
    data: XOR<TableHoldUpdateManyMutationInput, TableHoldUncheckedUpdateManyInput>
    /**
     * Filter which TableHolds to update
     */
    where?: TableHoldWhereInput
  }

  /**
   * TableHold upsert
   */
  export type TableHoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * The filter to search for the TableHold to update in case it exists.
     */
    where: TableHoldWhereUniqueInput
    /**
     * In case the TableHold found by the `where` argument doesn't exist, create a new TableHold with this data.
     */
    create: XOR<TableHoldCreateInput, TableHoldUncheckedCreateInput>
    /**
     * In case the TableHold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableHoldUpdateInput, TableHoldUncheckedUpdateInput>
  }

  /**
   * TableHold delete
   */
  export type TableHoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
    /**
     * Filter which TableHold to delete.
     */
    where: TableHoldWhereUniqueInput
  }

  /**
   * TableHold deleteMany
   */
  export type TableHoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableHolds to delete
     */
    where?: TableHoldWhereInput
  }

  /**
   * TableHold without action
   */
  export type TableHoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableHold
     */
    select?: TableHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableHoldInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantWaitlist
   */

  export type AggregateRestaurantWaitlist = {
    _count: RestaurantWaitlistCountAggregateOutputType | null
    _avg: RestaurantWaitlistAvgAggregateOutputType | null
    _sum: RestaurantWaitlistSumAggregateOutputType | null
    _min: RestaurantWaitlistMinAggregateOutputType | null
    _max: RestaurantWaitlistMaxAggregateOutputType | null
  }

  export type RestaurantWaitlistAvgAggregateOutputType = {
    pax: number | null
  }

  export type RestaurantWaitlistSumAggregateOutputType = {
    pax: number | null
  }

  export type RestaurantWaitlistMinAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    name: string | null
    phone: string | null
    pax: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    notifiedAt: Date | null
  }

  export type RestaurantWaitlistMaxAggregateOutputType = {
    id: string | null
    restaurantId: string | null
    name: string | null
    phone: string | null
    pax: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    notifiedAt: Date | null
  }

  export type RestaurantWaitlistCountAggregateOutputType = {
    id: number
    restaurantId: number
    name: number
    phone: number
    pax: number
    notes: number
    status: number
    createdAt: number
    notifiedAt: number
    _all: number
  }


  export type RestaurantWaitlistAvgAggregateInputType = {
    pax?: true
  }

  export type RestaurantWaitlistSumAggregateInputType = {
    pax?: true
  }

  export type RestaurantWaitlistMinAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    phone?: true
    pax?: true
    notes?: true
    status?: true
    createdAt?: true
    notifiedAt?: true
  }

  export type RestaurantWaitlistMaxAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    phone?: true
    pax?: true
    notes?: true
    status?: true
    createdAt?: true
    notifiedAt?: true
  }

  export type RestaurantWaitlistCountAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    phone?: true
    pax?: true
    notes?: true
    status?: true
    createdAt?: true
    notifiedAt?: true
    _all?: true
  }

  export type RestaurantWaitlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantWaitlist to aggregate.
     */
    where?: RestaurantWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaitlists to fetch.
     */
    orderBy?: RestaurantWaitlistOrderByWithRelationInput | RestaurantWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantWaitlists
    **/
    _count?: true | RestaurantWaitlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantWaitlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantWaitlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantWaitlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantWaitlistMaxAggregateInputType
  }

  export type GetRestaurantWaitlistAggregateType<T extends RestaurantWaitlistAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantWaitlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantWaitlist[P]>
      : GetScalarType<T[P], AggregateRestaurantWaitlist[P]>
  }




  export type RestaurantWaitlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWaitlistWhereInput
    orderBy?: RestaurantWaitlistOrderByWithAggregationInput | RestaurantWaitlistOrderByWithAggregationInput[]
    by: RestaurantWaitlistScalarFieldEnum[] | RestaurantWaitlistScalarFieldEnum
    having?: RestaurantWaitlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantWaitlistCountAggregateInputType | true
    _avg?: RestaurantWaitlistAvgAggregateInputType
    _sum?: RestaurantWaitlistSumAggregateInputType
    _min?: RestaurantWaitlistMinAggregateInputType
    _max?: RestaurantWaitlistMaxAggregateInputType
  }

  export type RestaurantWaitlistGroupByOutputType = {
    id: string
    restaurantId: string
    name: string
    phone: string | null
    pax: number
    notes: string | null
    status: string
    createdAt: Date
    notifiedAt: Date | null
    _count: RestaurantWaitlistCountAggregateOutputType | null
    _avg: RestaurantWaitlistAvgAggregateOutputType | null
    _sum: RestaurantWaitlistSumAggregateOutputType | null
    _min: RestaurantWaitlistMinAggregateOutputType | null
    _max: RestaurantWaitlistMaxAggregateOutputType | null
  }

  type GetRestaurantWaitlistGroupByPayload<T extends RestaurantWaitlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantWaitlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantWaitlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantWaitlistGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantWaitlistGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantWaitlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    phone?: boolean
    pax?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    notifiedAt?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantWaitlist"]>

  export type RestaurantWaitlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    phone?: boolean
    pax?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    notifiedAt?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantWaitlist"]>

  export type RestaurantWaitlistSelectScalar = {
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    phone?: boolean
    pax?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    notifiedAt?: boolean
  }

  export type RestaurantWaitlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type RestaurantWaitlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $RestaurantWaitlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantWaitlist"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      restaurantId: string
      name: string
      phone: string | null
      pax: number
      notes: string | null
      status: string
      createdAt: Date
      notifiedAt: Date | null
    }, ExtArgs["result"]["restaurantWaitlist"]>
    composites: {}
  }

  type RestaurantWaitlistGetPayload<S extends boolean | null | undefined | RestaurantWaitlistDefaultArgs> = $Result.GetResult<Prisma.$RestaurantWaitlistPayload, S>

  type RestaurantWaitlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestaurantWaitlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestaurantWaitlistCountAggregateInputType | true
    }

  export interface RestaurantWaitlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantWaitlist'], meta: { name: 'RestaurantWaitlist' } }
    /**
     * Find zero or one RestaurantWaitlist that matches the filter.
     * @param {RestaurantWaitlistFindUniqueArgs} args - Arguments to find a RestaurantWaitlist
     * @example
     * // Get one RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantWaitlistFindUniqueArgs>(args: SelectSubset<T, RestaurantWaitlistFindUniqueArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RestaurantWaitlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RestaurantWaitlistFindUniqueOrThrowArgs} args - Arguments to find a RestaurantWaitlist
     * @example
     * // Get one RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantWaitlistFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantWaitlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RestaurantWaitlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistFindFirstArgs} args - Arguments to find a RestaurantWaitlist
     * @example
     * // Get one RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantWaitlistFindFirstArgs>(args?: SelectSubset<T, RestaurantWaitlistFindFirstArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RestaurantWaitlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistFindFirstOrThrowArgs} args - Arguments to find a RestaurantWaitlist
     * @example
     * // Get one RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantWaitlistFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantWaitlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RestaurantWaitlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantWaitlists
     * const restaurantWaitlists = await prisma.restaurantWaitlist.findMany()
     * 
     * // Get first 10 RestaurantWaitlists
     * const restaurantWaitlists = await prisma.restaurantWaitlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWaitlistWithIdOnly = await prisma.restaurantWaitlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantWaitlistFindManyArgs>(args?: SelectSubset<T, RestaurantWaitlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RestaurantWaitlist.
     * @param {RestaurantWaitlistCreateArgs} args - Arguments to create a RestaurantWaitlist.
     * @example
     * // Create one RestaurantWaitlist
     * const RestaurantWaitlist = await prisma.restaurantWaitlist.create({
     *   data: {
     *     // ... data to create a RestaurantWaitlist
     *   }
     * })
     * 
     */
    create<T extends RestaurantWaitlistCreateArgs>(args: SelectSubset<T, RestaurantWaitlistCreateArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RestaurantWaitlists.
     * @param {RestaurantWaitlistCreateManyArgs} args - Arguments to create many RestaurantWaitlists.
     * @example
     * // Create many RestaurantWaitlists
     * const restaurantWaitlist = await prisma.restaurantWaitlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantWaitlistCreateManyArgs>(args?: SelectSubset<T, RestaurantWaitlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RestaurantWaitlists and returns the data saved in the database.
     * @param {RestaurantWaitlistCreateManyAndReturnArgs} args - Arguments to create many RestaurantWaitlists.
     * @example
     * // Create many RestaurantWaitlists
     * const restaurantWaitlist = await prisma.restaurantWaitlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RestaurantWaitlists and only return the `id`
     * const restaurantWaitlistWithIdOnly = await prisma.restaurantWaitlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantWaitlistCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantWaitlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RestaurantWaitlist.
     * @param {RestaurantWaitlistDeleteArgs} args - Arguments to delete one RestaurantWaitlist.
     * @example
     * // Delete one RestaurantWaitlist
     * const RestaurantWaitlist = await prisma.restaurantWaitlist.delete({
     *   where: {
     *     // ... filter to delete one RestaurantWaitlist
     *   }
     * })
     * 
     */
    delete<T extends RestaurantWaitlistDeleteArgs>(args: SelectSubset<T, RestaurantWaitlistDeleteArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RestaurantWaitlist.
     * @param {RestaurantWaitlistUpdateArgs} args - Arguments to update one RestaurantWaitlist.
     * @example
     * // Update one RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantWaitlistUpdateArgs>(args: SelectSubset<T, RestaurantWaitlistUpdateArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RestaurantWaitlists.
     * @param {RestaurantWaitlistDeleteManyArgs} args - Arguments to filter RestaurantWaitlists to delete.
     * @example
     * // Delete a few RestaurantWaitlists
     * const { count } = await prisma.restaurantWaitlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantWaitlistDeleteManyArgs>(args?: SelectSubset<T, RestaurantWaitlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantWaitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantWaitlists
     * const restaurantWaitlist = await prisma.restaurantWaitlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantWaitlistUpdateManyArgs>(args: SelectSubset<T, RestaurantWaitlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RestaurantWaitlist.
     * @param {RestaurantWaitlistUpsertArgs} args - Arguments to update or create a RestaurantWaitlist.
     * @example
     * // Update or create a RestaurantWaitlist
     * const restaurantWaitlist = await prisma.restaurantWaitlist.upsert({
     *   create: {
     *     // ... data to create a RestaurantWaitlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantWaitlist we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantWaitlistUpsertArgs>(args: SelectSubset<T, RestaurantWaitlistUpsertArgs<ExtArgs>>): Prisma__RestaurantWaitlistClient<$Result.GetResult<Prisma.$RestaurantWaitlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RestaurantWaitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistCountArgs} args - Arguments to filter RestaurantWaitlists to count.
     * @example
     * // Count the number of RestaurantWaitlists
     * const count = await prisma.restaurantWaitlist.count({
     *   where: {
     *     // ... the filter for the RestaurantWaitlists we want to count
     *   }
     * })
    **/
    count<T extends RestaurantWaitlistCountArgs>(
      args?: Subset<T, RestaurantWaitlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantWaitlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantWaitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantWaitlistAggregateArgs>(args: Subset<T, RestaurantWaitlistAggregateArgs>): Prisma.PrismaPromise<GetRestaurantWaitlistAggregateType<T>>

    /**
     * Group by RestaurantWaitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantWaitlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantWaitlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantWaitlistGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantWaitlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantWaitlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantWaitlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantWaitlist model
   */
  readonly fields: RestaurantWaitlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantWaitlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantWaitlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantWaitlist model
   */ 
  interface RestaurantWaitlistFieldRefs {
    readonly id: FieldRef<"RestaurantWaitlist", 'String'>
    readonly restaurantId: FieldRef<"RestaurantWaitlist", 'String'>
    readonly name: FieldRef<"RestaurantWaitlist", 'String'>
    readonly phone: FieldRef<"RestaurantWaitlist", 'String'>
    readonly pax: FieldRef<"RestaurantWaitlist", 'Int'>
    readonly notes: FieldRef<"RestaurantWaitlist", 'String'>
    readonly status: FieldRef<"RestaurantWaitlist", 'String'>
    readonly createdAt: FieldRef<"RestaurantWaitlist", 'DateTime'>
    readonly notifiedAt: FieldRef<"RestaurantWaitlist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantWaitlist findUnique
   */
  export type RestaurantWaitlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaitlist to fetch.
     */
    where: RestaurantWaitlistWhereUniqueInput
  }

  /**
   * RestaurantWaitlist findUniqueOrThrow
   */
  export type RestaurantWaitlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaitlist to fetch.
     */
    where: RestaurantWaitlistWhereUniqueInput
  }

  /**
   * RestaurantWaitlist findFirst
   */
  export type RestaurantWaitlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaitlist to fetch.
     */
    where?: RestaurantWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaitlists to fetch.
     */
    orderBy?: RestaurantWaitlistOrderByWithRelationInput | RestaurantWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantWaitlists.
     */
    cursor?: RestaurantWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantWaitlists.
     */
    distinct?: RestaurantWaitlistScalarFieldEnum | RestaurantWaitlistScalarFieldEnum[]
  }

  /**
   * RestaurantWaitlist findFirstOrThrow
   */
  export type RestaurantWaitlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaitlist to fetch.
     */
    where?: RestaurantWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaitlists to fetch.
     */
    orderBy?: RestaurantWaitlistOrderByWithRelationInput | RestaurantWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantWaitlists.
     */
    cursor?: RestaurantWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantWaitlists.
     */
    distinct?: RestaurantWaitlistScalarFieldEnum | RestaurantWaitlistScalarFieldEnum[]
  }

  /**
   * RestaurantWaitlist findMany
   */
  export type RestaurantWaitlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantWaitlists to fetch.
     */
    where?: RestaurantWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantWaitlists to fetch.
     */
    orderBy?: RestaurantWaitlistOrderByWithRelationInput | RestaurantWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantWaitlists.
     */
    cursor?: RestaurantWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantWaitlists.
     */
    skip?: number
    distinct?: RestaurantWaitlistScalarFieldEnum | RestaurantWaitlistScalarFieldEnum[]
  }

  /**
   * RestaurantWaitlist create
   */
  export type RestaurantWaitlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantWaitlist.
     */
    data: XOR<RestaurantWaitlistCreateInput, RestaurantWaitlistUncheckedCreateInput>
  }

  /**
   * RestaurantWaitlist createMany
   */
  export type RestaurantWaitlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantWaitlists.
     */
    data: RestaurantWaitlistCreateManyInput | RestaurantWaitlistCreateManyInput[]
  }

  /**
   * RestaurantWaitlist createManyAndReturn
   */
  export type RestaurantWaitlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RestaurantWaitlists.
     */
    data: RestaurantWaitlistCreateManyInput | RestaurantWaitlistCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RestaurantWaitlist update
   */
  export type RestaurantWaitlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantWaitlist.
     */
    data: XOR<RestaurantWaitlistUpdateInput, RestaurantWaitlistUncheckedUpdateInput>
    /**
     * Choose, which RestaurantWaitlist to update.
     */
    where: RestaurantWaitlistWhereUniqueInput
  }

  /**
   * RestaurantWaitlist updateMany
   */
  export type RestaurantWaitlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantWaitlists.
     */
    data: XOR<RestaurantWaitlistUpdateManyMutationInput, RestaurantWaitlistUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantWaitlists to update
     */
    where?: RestaurantWaitlistWhereInput
  }

  /**
   * RestaurantWaitlist upsert
   */
  export type RestaurantWaitlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantWaitlist to update in case it exists.
     */
    where: RestaurantWaitlistWhereUniqueInput
    /**
     * In case the RestaurantWaitlist found by the `where` argument doesn't exist, create a new RestaurantWaitlist with this data.
     */
    create: XOR<RestaurantWaitlistCreateInput, RestaurantWaitlistUncheckedCreateInput>
    /**
     * In case the RestaurantWaitlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantWaitlistUpdateInput, RestaurantWaitlistUncheckedUpdateInput>
  }

  /**
   * RestaurantWaitlist delete
   */
  export type RestaurantWaitlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
    /**
     * Filter which RestaurantWaitlist to delete.
     */
    where: RestaurantWaitlistWhereUniqueInput
  }

  /**
   * RestaurantWaitlist deleteMany
   */
  export type RestaurantWaitlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantWaitlists to delete
     */
    where?: RestaurantWaitlistWhereInput
  }

  /**
   * RestaurantWaitlist without action
   */
  export type RestaurantWaitlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantWaitlist
     */
    select?: RestaurantWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantWaitlistInclude<ExtArgs> | null
  }


  /**
   * Model HotelWaitlist
   */

  export type AggregateHotelWaitlist = {
    _count: HotelWaitlistCountAggregateOutputType | null
    _min: HotelWaitlistMinAggregateOutputType | null
    _max: HotelWaitlistMaxAggregateOutputType | null
  }

  export type HotelWaitlistMinAggregateOutputType = {
    id: string | null
    hotelId: string | null
    roomTypeId: string | null
    email: string | null
    dateFrom: Date | null
    dateTo: Date | null
    requestDate: Date | null
    fulfilled: boolean | null
  }

  export type HotelWaitlistMaxAggregateOutputType = {
    id: string | null
    hotelId: string | null
    roomTypeId: string | null
    email: string | null
    dateFrom: Date | null
    dateTo: Date | null
    requestDate: Date | null
    fulfilled: boolean | null
  }

  export type HotelWaitlistCountAggregateOutputType = {
    id: number
    hotelId: number
    roomTypeId: number
    email: number
    dateFrom: number
    dateTo: number
    requestDate: number
    fulfilled: number
    _all: number
  }


  export type HotelWaitlistMinAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    email?: true
    dateFrom?: true
    dateTo?: true
    requestDate?: true
    fulfilled?: true
  }

  export type HotelWaitlistMaxAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    email?: true
    dateFrom?: true
    dateTo?: true
    requestDate?: true
    fulfilled?: true
  }

  export type HotelWaitlistCountAggregateInputType = {
    id?: true
    hotelId?: true
    roomTypeId?: true
    email?: true
    dateFrom?: true
    dateTo?: true
    requestDate?: true
    fulfilled?: true
    _all?: true
  }

  export type HotelWaitlistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelWaitlist to aggregate.
     */
    where?: HotelWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelWaitlists to fetch.
     */
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelWaitlists
    **/
    _count?: true | HotelWaitlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelWaitlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelWaitlistMaxAggregateInputType
  }

  export type GetHotelWaitlistAggregateType<T extends HotelWaitlistAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelWaitlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelWaitlist[P]>
      : GetScalarType<T[P], AggregateHotelWaitlist[P]>
  }




  export type HotelWaitlistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWaitlistWhereInput
    orderBy?: HotelWaitlistOrderByWithAggregationInput | HotelWaitlistOrderByWithAggregationInput[]
    by: HotelWaitlistScalarFieldEnum[] | HotelWaitlistScalarFieldEnum
    having?: HotelWaitlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelWaitlistCountAggregateInputType | true
    _min?: HotelWaitlistMinAggregateInputType
    _max?: HotelWaitlistMaxAggregateInputType
  }

  export type HotelWaitlistGroupByOutputType = {
    id: string
    hotelId: string
    roomTypeId: string
    email: string
    dateFrom: Date
    dateTo: Date
    requestDate: Date
    fulfilled: boolean
    _count: HotelWaitlistCountAggregateOutputType | null
    _min: HotelWaitlistMinAggregateOutputType | null
    _max: HotelWaitlistMaxAggregateOutputType | null
  }

  type GetHotelWaitlistGroupByPayload<T extends HotelWaitlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelWaitlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelWaitlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelWaitlistGroupByOutputType[P]>
            : GetScalarType<T[P], HotelWaitlistGroupByOutputType[P]>
        }
      >
    >


  export type HotelWaitlistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    email?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    requestDate?: boolean
    fulfilled?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelWaitlist"]>

  export type HotelWaitlistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    email?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    requestDate?: boolean
    fulfilled?: boolean
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelWaitlist"]>

  export type HotelWaitlistSelectScalar = {
    id?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    email?: boolean
    dateFrom?: boolean
    dateTo?: boolean
    requestDate?: boolean
    fulfilled?: boolean
  }

  export type HotelWaitlistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }
  export type HotelWaitlistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
    roomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }

  export type $HotelWaitlistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelWaitlist"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs>
      roomType: Prisma.$RoomTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hotelId: string
      roomTypeId: string
      email: string
      dateFrom: Date
      dateTo: Date
      requestDate: Date
      fulfilled: boolean
    }, ExtArgs["result"]["hotelWaitlist"]>
    composites: {}
  }

  type HotelWaitlistGetPayload<S extends boolean | null | undefined | HotelWaitlistDefaultArgs> = $Result.GetResult<Prisma.$HotelWaitlistPayload, S>

  type HotelWaitlistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelWaitlistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelWaitlistCountAggregateInputType | true
    }

  export interface HotelWaitlistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelWaitlist'], meta: { name: 'HotelWaitlist' } }
    /**
     * Find zero or one HotelWaitlist that matches the filter.
     * @param {HotelWaitlistFindUniqueArgs} args - Arguments to find a HotelWaitlist
     * @example
     * // Get one HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelWaitlistFindUniqueArgs>(args: SelectSubset<T, HotelWaitlistFindUniqueArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HotelWaitlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelWaitlistFindUniqueOrThrowArgs} args - Arguments to find a HotelWaitlist
     * @example
     * // Get one HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelWaitlistFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelWaitlistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HotelWaitlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistFindFirstArgs} args - Arguments to find a HotelWaitlist
     * @example
     * // Get one HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelWaitlistFindFirstArgs>(args?: SelectSubset<T, HotelWaitlistFindFirstArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HotelWaitlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistFindFirstOrThrowArgs} args - Arguments to find a HotelWaitlist
     * @example
     * // Get one HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelWaitlistFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelWaitlistFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HotelWaitlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelWaitlists
     * const hotelWaitlists = await prisma.hotelWaitlist.findMany()
     * 
     * // Get first 10 HotelWaitlists
     * const hotelWaitlists = await prisma.hotelWaitlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWaitlistWithIdOnly = await prisma.hotelWaitlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelWaitlistFindManyArgs>(args?: SelectSubset<T, HotelWaitlistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HotelWaitlist.
     * @param {HotelWaitlistCreateArgs} args - Arguments to create a HotelWaitlist.
     * @example
     * // Create one HotelWaitlist
     * const HotelWaitlist = await prisma.hotelWaitlist.create({
     *   data: {
     *     // ... data to create a HotelWaitlist
     *   }
     * })
     * 
     */
    create<T extends HotelWaitlistCreateArgs>(args: SelectSubset<T, HotelWaitlistCreateArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HotelWaitlists.
     * @param {HotelWaitlistCreateManyArgs} args - Arguments to create many HotelWaitlists.
     * @example
     * // Create many HotelWaitlists
     * const hotelWaitlist = await prisma.hotelWaitlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelWaitlistCreateManyArgs>(args?: SelectSubset<T, HotelWaitlistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelWaitlists and returns the data saved in the database.
     * @param {HotelWaitlistCreateManyAndReturnArgs} args - Arguments to create many HotelWaitlists.
     * @example
     * // Create many HotelWaitlists
     * const hotelWaitlist = await prisma.hotelWaitlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelWaitlists and only return the `id`
     * const hotelWaitlistWithIdOnly = await prisma.hotelWaitlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelWaitlistCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelWaitlistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HotelWaitlist.
     * @param {HotelWaitlistDeleteArgs} args - Arguments to delete one HotelWaitlist.
     * @example
     * // Delete one HotelWaitlist
     * const HotelWaitlist = await prisma.hotelWaitlist.delete({
     *   where: {
     *     // ... filter to delete one HotelWaitlist
     *   }
     * })
     * 
     */
    delete<T extends HotelWaitlistDeleteArgs>(args: SelectSubset<T, HotelWaitlistDeleteArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HotelWaitlist.
     * @param {HotelWaitlistUpdateArgs} args - Arguments to update one HotelWaitlist.
     * @example
     * // Update one HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelWaitlistUpdateArgs>(args: SelectSubset<T, HotelWaitlistUpdateArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HotelWaitlists.
     * @param {HotelWaitlistDeleteManyArgs} args - Arguments to filter HotelWaitlists to delete.
     * @example
     * // Delete a few HotelWaitlists
     * const { count } = await prisma.hotelWaitlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelWaitlistDeleteManyArgs>(args?: SelectSubset<T, HotelWaitlistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelWaitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelWaitlists
     * const hotelWaitlist = await prisma.hotelWaitlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelWaitlistUpdateManyArgs>(args: SelectSubset<T, HotelWaitlistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotelWaitlist.
     * @param {HotelWaitlistUpsertArgs} args - Arguments to update or create a HotelWaitlist.
     * @example
     * // Update or create a HotelWaitlist
     * const hotelWaitlist = await prisma.hotelWaitlist.upsert({
     *   create: {
     *     // ... data to create a HotelWaitlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelWaitlist we want to update
     *   }
     * })
     */
    upsert<T extends HotelWaitlistUpsertArgs>(args: SelectSubset<T, HotelWaitlistUpsertArgs<ExtArgs>>): Prisma__HotelWaitlistClient<$Result.GetResult<Prisma.$HotelWaitlistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HotelWaitlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistCountArgs} args - Arguments to filter HotelWaitlists to count.
     * @example
     * // Count the number of HotelWaitlists
     * const count = await prisma.hotelWaitlist.count({
     *   where: {
     *     // ... the filter for the HotelWaitlists we want to count
     *   }
     * })
    **/
    count<T extends HotelWaitlistCountArgs>(
      args?: Subset<T, HotelWaitlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelWaitlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelWaitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelWaitlistAggregateArgs>(args: Subset<T, HotelWaitlistAggregateArgs>): Prisma.PrismaPromise<GetHotelWaitlistAggregateType<T>>

    /**
     * Group by HotelWaitlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelWaitlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelWaitlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelWaitlistGroupByArgs['orderBy'] }
        : { orderBy?: HotelWaitlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelWaitlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelWaitlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelWaitlist model
   */
  readonly fields: HotelWaitlistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelWaitlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelWaitlistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelWaitlist model
   */ 
  interface HotelWaitlistFieldRefs {
    readonly id: FieldRef<"HotelWaitlist", 'String'>
    readonly hotelId: FieldRef<"HotelWaitlist", 'String'>
    readonly roomTypeId: FieldRef<"HotelWaitlist", 'String'>
    readonly email: FieldRef<"HotelWaitlist", 'String'>
    readonly dateFrom: FieldRef<"HotelWaitlist", 'DateTime'>
    readonly dateTo: FieldRef<"HotelWaitlist", 'DateTime'>
    readonly requestDate: FieldRef<"HotelWaitlist", 'DateTime'>
    readonly fulfilled: FieldRef<"HotelWaitlist", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HotelWaitlist findUnique
   */
  export type HotelWaitlistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which HotelWaitlist to fetch.
     */
    where: HotelWaitlistWhereUniqueInput
  }

  /**
   * HotelWaitlist findUniqueOrThrow
   */
  export type HotelWaitlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which HotelWaitlist to fetch.
     */
    where: HotelWaitlistWhereUniqueInput
  }

  /**
   * HotelWaitlist findFirst
   */
  export type HotelWaitlistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which HotelWaitlist to fetch.
     */
    where?: HotelWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelWaitlists to fetch.
     */
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelWaitlists.
     */
    cursor?: HotelWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelWaitlists.
     */
    distinct?: HotelWaitlistScalarFieldEnum | HotelWaitlistScalarFieldEnum[]
  }

  /**
   * HotelWaitlist findFirstOrThrow
   */
  export type HotelWaitlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which HotelWaitlist to fetch.
     */
    where?: HotelWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelWaitlists to fetch.
     */
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelWaitlists.
     */
    cursor?: HotelWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelWaitlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelWaitlists.
     */
    distinct?: HotelWaitlistScalarFieldEnum | HotelWaitlistScalarFieldEnum[]
  }

  /**
   * HotelWaitlist findMany
   */
  export type HotelWaitlistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter, which HotelWaitlists to fetch.
     */
    where?: HotelWaitlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelWaitlists to fetch.
     */
    orderBy?: HotelWaitlistOrderByWithRelationInput | HotelWaitlistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelWaitlists.
     */
    cursor?: HotelWaitlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelWaitlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelWaitlists.
     */
    skip?: number
    distinct?: HotelWaitlistScalarFieldEnum | HotelWaitlistScalarFieldEnum[]
  }

  /**
   * HotelWaitlist create
   */
  export type HotelWaitlistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelWaitlist.
     */
    data: XOR<HotelWaitlistCreateInput, HotelWaitlistUncheckedCreateInput>
  }

  /**
   * HotelWaitlist createMany
   */
  export type HotelWaitlistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelWaitlists.
     */
    data: HotelWaitlistCreateManyInput | HotelWaitlistCreateManyInput[]
  }

  /**
   * HotelWaitlist createManyAndReturn
   */
  export type HotelWaitlistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HotelWaitlists.
     */
    data: HotelWaitlistCreateManyInput | HotelWaitlistCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelWaitlist update
   */
  export type HotelWaitlistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelWaitlist.
     */
    data: XOR<HotelWaitlistUpdateInput, HotelWaitlistUncheckedUpdateInput>
    /**
     * Choose, which HotelWaitlist to update.
     */
    where: HotelWaitlistWhereUniqueInput
  }

  /**
   * HotelWaitlist updateMany
   */
  export type HotelWaitlistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelWaitlists.
     */
    data: XOR<HotelWaitlistUpdateManyMutationInput, HotelWaitlistUncheckedUpdateManyInput>
    /**
     * Filter which HotelWaitlists to update
     */
    where?: HotelWaitlistWhereInput
  }

  /**
   * HotelWaitlist upsert
   */
  export type HotelWaitlistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelWaitlist to update in case it exists.
     */
    where: HotelWaitlistWhereUniqueInput
    /**
     * In case the HotelWaitlist found by the `where` argument doesn't exist, create a new HotelWaitlist with this data.
     */
    create: XOR<HotelWaitlistCreateInput, HotelWaitlistUncheckedCreateInput>
    /**
     * In case the HotelWaitlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelWaitlistUpdateInput, HotelWaitlistUncheckedUpdateInput>
  }

  /**
   * HotelWaitlist delete
   */
  export type HotelWaitlistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
    /**
     * Filter which HotelWaitlist to delete.
     */
    where: HotelWaitlistWhereUniqueInput
  }

  /**
   * HotelWaitlist deleteMany
   */
  export type HotelWaitlistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelWaitlists to delete
     */
    where?: HotelWaitlistWhereInput
  }

  /**
   * HotelWaitlist without action
   */
  export type HotelWaitlistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelWaitlist
     */
    select?: HotelWaitlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelWaitlistInclude<ExtArgs> | null
  }


  /**
   * Model CustomerProfile
   */

  export type AggregateCustomerProfile = {
    _count: CustomerProfileCountAggregateOutputType | null
    _avg: CustomerProfileAvgAggregateOutputType | null
    _sum: CustomerProfileSumAggregateOutputType | null
    _min: CustomerProfileMinAggregateOutputType | null
    _max: CustomerProfileMaxAggregateOutputType | null
  }

  export type CustomerProfileAvgAggregateOutputType = {
    totalSpend: Decimal | null
    visitCount: number | null
  }

  export type CustomerProfileSumAggregateOutputType = {
    totalSpend: Decimal | null
    visitCount: number | null
  }

  export type CustomerProfileMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    lifecycleStage: string | null
    totalSpend: Decimal | null
    visitCount: number | null
    lastInteraction: Date | null
    tags: string | null
    consentEmail: boolean | null
    consentWhatsApp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProfileMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    lifecycleStage: string | null
    totalSpend: Decimal | null
    visitCount: number | null
    lastInteraction: Date | null
    tags: string | null
    consentEmail: boolean | null
    consentWhatsApp: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProfileCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    firstName: number
    lastName: number
    lifecycleStage: number
    totalSpend: number
    visitCount: number
    lastInteraction: number
    tags: number
    consentEmail: number
    consentWhatsApp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerProfileAvgAggregateInputType = {
    totalSpend?: true
    visitCount?: true
  }

  export type CustomerProfileSumAggregateInputType = {
    totalSpend?: true
    visitCount?: true
  }

  export type CustomerProfileMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    lifecycleStage?: true
    totalSpend?: true
    visitCount?: true
    lastInteraction?: true
    tags?: true
    consentEmail?: true
    consentWhatsApp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProfileMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    lifecycleStage?: true
    totalSpend?: true
    visitCount?: true
    lastInteraction?: true
    tags?: true
    consentEmail?: true
    consentWhatsApp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProfileCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    lifecycleStage?: true
    totalSpend?: true
    visitCount?: true
    lastInteraction?: true
    tags?: true
    consentEmail?: true
    consentWhatsApp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProfile to aggregate.
     */
    where?: CustomerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?: CustomerProfileOrderByWithRelationInput | CustomerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerProfiles
    **/
    _count?: true | CustomerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerProfileMaxAggregateInputType
  }

  export type GetCustomerProfileAggregateType<T extends CustomerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProfile[P]>
      : GetScalarType<T[P], AggregateCustomerProfile[P]>
  }




  export type CustomerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProfileWhereInput
    orderBy?: CustomerProfileOrderByWithAggregationInput | CustomerProfileOrderByWithAggregationInput[]
    by: CustomerProfileScalarFieldEnum[] | CustomerProfileScalarFieldEnum
    having?: CustomerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerProfileCountAggregateInputType | true
    _avg?: CustomerProfileAvgAggregateInputType
    _sum?: CustomerProfileSumAggregateInputType
    _min?: CustomerProfileMinAggregateInputType
    _max?: CustomerProfileMaxAggregateInputType
  }

  export type CustomerProfileGroupByOutputType = {
    id: string
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    lifecycleStage: string
    totalSpend: Decimal
    visitCount: number
    lastInteraction: Date | null
    tags: string | null
    consentEmail: boolean
    consentWhatsApp: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerProfileCountAggregateOutputType | null
    _avg: CustomerProfileAvgAggregateOutputType | null
    _sum: CustomerProfileSumAggregateOutputType | null
    _min: CustomerProfileMinAggregateOutputType | null
    _max: CustomerProfileMaxAggregateOutputType | null
  }

  type GetCustomerProfileGroupByPayload<T extends CustomerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProfileGroupByOutputType[P]>
        }
      >
    >


  export type CustomerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    lifecycleStage?: boolean
    totalSpend?: boolean
    visitCount?: boolean
    lastInteraction?: boolean
    tags?: boolean
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identityLinks?: boolean | CustomerProfile$identityLinksArgs<ExtArgs>
    webVisits?: boolean | CustomerProfile$webVisitsArgs<ExtArgs>
    _count?: boolean | CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProfile"]>

  export type CustomerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    lifecycleStage?: boolean
    totalSpend?: boolean
    visitCount?: boolean
    lastInteraction?: boolean
    tags?: boolean
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerProfile"]>

  export type CustomerProfileSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    lifecycleStage?: boolean
    totalSpend?: boolean
    visitCount?: boolean
    lastInteraction?: boolean
    tags?: boolean
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    identityLinks?: boolean | CustomerProfile$identityLinksArgs<ExtArgs>
    webVisits?: boolean | CustomerProfile$webVisitsArgs<ExtArgs>
    _count?: boolean | CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerProfile"
    objects: {
      identityLinks: Prisma.$IdentityLinkPayload<ExtArgs>[]
      webVisits: Prisma.$WebVisitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      phone: string | null
      firstName: string | null
      lastName: string | null
      lifecycleStage: string
      totalSpend: Prisma.Decimal
      visitCount: number
      lastInteraction: Date | null
      tags: string | null
      consentEmail: boolean
      consentWhatsApp: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerProfile"]>
    composites: {}
  }

  type CustomerProfileGetPayload<S extends boolean | null | undefined | CustomerProfileDefaultArgs> = $Result.GetResult<Prisma.$CustomerProfilePayload, S>

  type CustomerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerProfileCountAggregateInputType | true
    }

  export interface CustomerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerProfile'], meta: { name: 'CustomerProfile' } }
    /**
     * Find zero or one CustomerProfile that matches the filter.
     * @param {CustomerProfileFindUniqueArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerProfileFindUniqueArgs>(args: SelectSubset<T, CustomerProfileFindUniqueArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerProfileFindUniqueOrThrowArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindFirstArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerProfileFindFirstArgs>(args?: SelectSubset<T, CustomerProfileFindFirstArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindFirstOrThrowArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProfiles
     * const customerProfiles = await prisma.customerProfile.findMany()
     * 
     * // Get first 10 CustomerProfiles
     * const customerProfiles = await prisma.customerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerProfileWithIdOnly = await prisma.customerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerProfileFindManyArgs>(args?: SelectSubset<T, CustomerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerProfile.
     * @param {CustomerProfileCreateArgs} args - Arguments to create a CustomerProfile.
     * @example
     * // Create one CustomerProfile
     * const CustomerProfile = await prisma.customerProfile.create({
     *   data: {
     *     // ... data to create a CustomerProfile
     *   }
     * })
     * 
     */
    create<T extends CustomerProfileCreateArgs>(args: SelectSubset<T, CustomerProfileCreateArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerProfiles.
     * @param {CustomerProfileCreateManyArgs} args - Arguments to create many CustomerProfiles.
     * @example
     * // Create many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerProfileCreateManyArgs>(args?: SelectSubset<T, CustomerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerProfiles and returns the data saved in the database.
     * @param {CustomerProfileCreateManyAndReturnArgs} args - Arguments to create many CustomerProfiles.
     * @example
     * // Create many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerProfiles and only return the `id`
     * const customerProfileWithIdOnly = await prisma.customerProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerProfile.
     * @param {CustomerProfileDeleteArgs} args - Arguments to delete one CustomerProfile.
     * @example
     * // Delete one CustomerProfile
     * const CustomerProfile = await prisma.customerProfile.delete({
     *   where: {
     *     // ... filter to delete one CustomerProfile
     *   }
     * })
     * 
     */
    delete<T extends CustomerProfileDeleteArgs>(args: SelectSubset<T, CustomerProfileDeleteArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerProfile.
     * @param {CustomerProfileUpdateArgs} args - Arguments to update one CustomerProfile.
     * @example
     * // Update one CustomerProfile
     * const customerProfile = await prisma.customerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerProfileUpdateArgs>(args: SelectSubset<T, CustomerProfileUpdateArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerProfiles.
     * @param {CustomerProfileDeleteManyArgs} args - Arguments to filter CustomerProfiles to delete.
     * @example
     * // Delete a few CustomerProfiles
     * const { count } = await prisma.customerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerProfileDeleteManyArgs>(args?: SelectSubset<T, CustomerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerProfileUpdateManyArgs>(args: SelectSubset<T, CustomerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerProfile.
     * @param {CustomerProfileUpsertArgs} args - Arguments to update or create a CustomerProfile.
     * @example
     * // Update or create a CustomerProfile
     * const customerProfile = await prisma.customerProfile.upsert({
     *   create: {
     *     // ... data to create a CustomerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProfile we want to update
     *   }
     * })
     */
    upsert<T extends CustomerProfileUpsertArgs>(args: SelectSubset<T, CustomerProfileUpsertArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileCountArgs} args - Arguments to filter CustomerProfiles to count.
     * @example
     * // Count the number of CustomerProfiles
     * const count = await prisma.customerProfile.count({
     *   where: {
     *     // ... the filter for the CustomerProfiles we want to count
     *   }
     * })
    **/
    count<T extends CustomerProfileCountArgs>(
      args?: Subset<T, CustomerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerProfileAggregateArgs>(args: Subset<T, CustomerProfileAggregateArgs>): Prisma.PrismaPromise<GetCustomerProfileAggregateType<T>>

    /**
     * Group by CustomerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProfileGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerProfile model
   */
  readonly fields: CustomerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    identityLinks<T extends CustomerProfile$identityLinksArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProfile$identityLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findMany"> | Null>
    webVisits<T extends CustomerProfile$webVisitsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProfile$webVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerProfile model
   */ 
  interface CustomerProfileFieldRefs {
    readonly id: FieldRef<"CustomerProfile", 'String'>
    readonly email: FieldRef<"CustomerProfile", 'String'>
    readonly phone: FieldRef<"CustomerProfile", 'String'>
    readonly firstName: FieldRef<"CustomerProfile", 'String'>
    readonly lastName: FieldRef<"CustomerProfile", 'String'>
    readonly lifecycleStage: FieldRef<"CustomerProfile", 'String'>
    readonly totalSpend: FieldRef<"CustomerProfile", 'Decimal'>
    readonly visitCount: FieldRef<"CustomerProfile", 'Int'>
    readonly lastInteraction: FieldRef<"CustomerProfile", 'DateTime'>
    readonly tags: FieldRef<"CustomerProfile", 'String'>
    readonly consentEmail: FieldRef<"CustomerProfile", 'Boolean'>
    readonly consentWhatsApp: FieldRef<"CustomerProfile", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerProfile findUnique
   */
  export type CustomerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where: CustomerProfileWhereUniqueInput
  }

  /**
   * CustomerProfile findUniqueOrThrow
   */
  export type CustomerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where: CustomerProfileWhereUniqueInput
  }

  /**
   * CustomerProfile findFirst
   */
  export type CustomerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where?: CustomerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?: CustomerProfileOrderByWithRelationInput | CustomerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProfiles.
     */
    distinct?: CustomerProfileScalarFieldEnum | CustomerProfileScalarFieldEnum[]
  }

  /**
   * CustomerProfile findFirstOrThrow
   */
  export type CustomerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where?: CustomerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?: CustomerProfileOrderByWithRelationInput | CustomerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProfiles.
     */
    distinct?: CustomerProfileScalarFieldEnum | CustomerProfileScalarFieldEnum[]
  }

  /**
   * CustomerProfile findMany
   */
  export type CustomerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProfiles to fetch.
     */
    where?: CustomerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?: CustomerProfileOrderByWithRelationInput | CustomerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number
    distinct?: CustomerProfileScalarFieldEnum | CustomerProfileScalarFieldEnum[]
  }

  /**
   * CustomerProfile create
   */
  export type CustomerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerProfile.
     */
    data: XOR<CustomerProfileCreateInput, CustomerProfileUncheckedCreateInput>
  }

  /**
   * CustomerProfile createMany
   */
  export type CustomerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerProfiles.
     */
    data: CustomerProfileCreateManyInput | CustomerProfileCreateManyInput[]
  }

  /**
   * CustomerProfile createManyAndReturn
   */
  export type CustomerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerProfiles.
     */
    data: CustomerProfileCreateManyInput | CustomerProfileCreateManyInput[]
  }

  /**
   * CustomerProfile update
   */
  export type CustomerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerProfile.
     */
    data: XOR<CustomerProfileUpdateInput, CustomerProfileUncheckedUpdateInput>
    /**
     * Choose, which CustomerProfile to update.
     */
    where: CustomerProfileWhereUniqueInput
  }

  /**
   * CustomerProfile updateMany
   */
  export type CustomerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerProfiles.
     */
    data: XOR<CustomerProfileUpdateManyMutationInput, CustomerProfileUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProfiles to update
     */
    where?: CustomerProfileWhereInput
  }

  /**
   * CustomerProfile upsert
   */
  export type CustomerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerProfile to update in case it exists.
     */
    where: CustomerProfileWhereUniqueInput
    /**
     * In case the CustomerProfile found by the `where` argument doesn't exist, create a new CustomerProfile with this data.
     */
    create: XOR<CustomerProfileCreateInput, CustomerProfileUncheckedCreateInput>
    /**
     * In case the CustomerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerProfileUpdateInput, CustomerProfileUncheckedUpdateInput>
  }

  /**
   * CustomerProfile delete
   */
  export type CustomerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    /**
     * Filter which CustomerProfile to delete.
     */
    where: CustomerProfileWhereUniqueInput
  }

  /**
   * CustomerProfile deleteMany
   */
  export type CustomerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProfiles to delete
     */
    where?: CustomerProfileWhereInput
  }

  /**
   * CustomerProfile.identityLinks
   */
  export type CustomerProfile$identityLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    where?: IdentityLinkWhereInput
    orderBy?: IdentityLinkOrderByWithRelationInput | IdentityLinkOrderByWithRelationInput[]
    cursor?: IdentityLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentityLinkScalarFieldEnum | IdentityLinkScalarFieldEnum[]
  }

  /**
   * CustomerProfile.webVisits
   */
  export type CustomerProfile$webVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    where?: WebVisitWhereInput
    orderBy?: WebVisitOrderByWithRelationInput | WebVisitOrderByWithRelationInput[]
    cursor?: WebVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebVisitScalarFieldEnum | WebVisitScalarFieldEnum[]
  }

  /**
   * CustomerProfile without action
   */
  export type CustomerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
  }


  /**
   * Model IdentityLink
   */

  export type AggregateIdentityLink = {
    _count: IdentityLinkCountAggregateOutputType | null
    _min: IdentityLinkMinAggregateOutputType | null
    _max: IdentityLinkMaxAggregateOutputType | null
  }

  export type IdentityLinkMinAggregateOutputType = {
    id: string | null
    customerProfileId: string | null
    sourceType: string | null
    sourceId: string | null
    mergedAt: Date | null
  }

  export type IdentityLinkMaxAggregateOutputType = {
    id: string | null
    customerProfileId: string | null
    sourceType: string | null
    sourceId: string | null
    mergedAt: Date | null
  }

  export type IdentityLinkCountAggregateOutputType = {
    id: number
    customerProfileId: number
    sourceType: number
    sourceId: number
    mergedAt: number
    _all: number
  }


  export type IdentityLinkMinAggregateInputType = {
    id?: true
    customerProfileId?: true
    sourceType?: true
    sourceId?: true
    mergedAt?: true
  }

  export type IdentityLinkMaxAggregateInputType = {
    id?: true
    customerProfileId?: true
    sourceType?: true
    sourceId?: true
    mergedAt?: true
  }

  export type IdentityLinkCountAggregateInputType = {
    id?: true
    customerProfileId?: true
    sourceType?: true
    sourceId?: true
    mergedAt?: true
    _all?: true
  }

  export type IdentityLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentityLink to aggregate.
     */
    where?: IdentityLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityLinks to fetch.
     */
    orderBy?: IdentityLinkOrderByWithRelationInput | IdentityLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentityLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdentityLinks
    **/
    _count?: true | IdentityLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentityLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentityLinkMaxAggregateInputType
  }

  export type GetIdentityLinkAggregateType<T extends IdentityLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentityLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentityLink[P]>
      : GetScalarType<T[P], AggregateIdentityLink[P]>
  }




  export type IdentityLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityLinkWhereInput
    orderBy?: IdentityLinkOrderByWithAggregationInput | IdentityLinkOrderByWithAggregationInput[]
    by: IdentityLinkScalarFieldEnum[] | IdentityLinkScalarFieldEnum
    having?: IdentityLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentityLinkCountAggregateInputType | true
    _min?: IdentityLinkMinAggregateInputType
    _max?: IdentityLinkMaxAggregateInputType
  }

  export type IdentityLinkGroupByOutputType = {
    id: string
    customerProfileId: string
    sourceType: string
    sourceId: string
    mergedAt: Date
    _count: IdentityLinkCountAggregateOutputType | null
    _min: IdentityLinkMinAggregateOutputType | null
    _max: IdentityLinkMaxAggregateOutputType | null
  }

  type GetIdentityLinkGroupByPayload<T extends IdentityLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentityLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentityLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentityLinkGroupByOutputType[P]>
            : GetScalarType<T[P], IdentityLinkGroupByOutputType[P]>
        }
      >
    >


  export type IdentityLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    mergedAt?: boolean
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identityLink"]>

  export type IdentityLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    mergedAt?: boolean
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identityLink"]>

  export type IdentityLinkSelectScalar = {
    id?: boolean
    customerProfileId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    mergedAt?: boolean
  }

  export type IdentityLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>
  }
  export type IdentityLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>
  }

  export type $IdentityLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdentityLink"
    objects: {
      customerProfile: Prisma.$CustomerProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerProfileId: string
      sourceType: string
      sourceId: string
      mergedAt: Date
    }, ExtArgs["result"]["identityLink"]>
    composites: {}
  }

  type IdentityLinkGetPayload<S extends boolean | null | undefined | IdentityLinkDefaultArgs> = $Result.GetResult<Prisma.$IdentityLinkPayload, S>

  type IdentityLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IdentityLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IdentityLinkCountAggregateInputType | true
    }

  export interface IdentityLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdentityLink'], meta: { name: 'IdentityLink' } }
    /**
     * Find zero or one IdentityLink that matches the filter.
     * @param {IdentityLinkFindUniqueArgs} args - Arguments to find a IdentityLink
     * @example
     * // Get one IdentityLink
     * const identityLink = await prisma.identityLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentityLinkFindUniqueArgs>(args: SelectSubset<T, IdentityLinkFindUniqueArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IdentityLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IdentityLinkFindUniqueOrThrowArgs} args - Arguments to find a IdentityLink
     * @example
     * // Get one IdentityLink
     * const identityLink = await prisma.identityLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentityLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentityLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IdentityLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkFindFirstArgs} args - Arguments to find a IdentityLink
     * @example
     * // Get one IdentityLink
     * const identityLink = await prisma.identityLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentityLinkFindFirstArgs>(args?: SelectSubset<T, IdentityLinkFindFirstArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IdentityLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkFindFirstOrThrowArgs} args - Arguments to find a IdentityLink
     * @example
     * // Get one IdentityLink
     * const identityLink = await prisma.identityLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentityLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentityLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IdentityLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdentityLinks
     * const identityLinks = await prisma.identityLink.findMany()
     * 
     * // Get first 10 IdentityLinks
     * const identityLinks = await prisma.identityLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identityLinkWithIdOnly = await prisma.identityLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentityLinkFindManyArgs>(args?: SelectSubset<T, IdentityLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IdentityLink.
     * @param {IdentityLinkCreateArgs} args - Arguments to create a IdentityLink.
     * @example
     * // Create one IdentityLink
     * const IdentityLink = await prisma.identityLink.create({
     *   data: {
     *     // ... data to create a IdentityLink
     *   }
     * })
     * 
     */
    create<T extends IdentityLinkCreateArgs>(args: SelectSubset<T, IdentityLinkCreateArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IdentityLinks.
     * @param {IdentityLinkCreateManyArgs} args - Arguments to create many IdentityLinks.
     * @example
     * // Create many IdentityLinks
     * const identityLink = await prisma.identityLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentityLinkCreateManyArgs>(args?: SelectSubset<T, IdentityLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdentityLinks and returns the data saved in the database.
     * @param {IdentityLinkCreateManyAndReturnArgs} args - Arguments to create many IdentityLinks.
     * @example
     * // Create many IdentityLinks
     * const identityLink = await prisma.identityLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdentityLinks and only return the `id`
     * const identityLinkWithIdOnly = await prisma.identityLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentityLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentityLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IdentityLink.
     * @param {IdentityLinkDeleteArgs} args - Arguments to delete one IdentityLink.
     * @example
     * // Delete one IdentityLink
     * const IdentityLink = await prisma.identityLink.delete({
     *   where: {
     *     // ... filter to delete one IdentityLink
     *   }
     * })
     * 
     */
    delete<T extends IdentityLinkDeleteArgs>(args: SelectSubset<T, IdentityLinkDeleteArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IdentityLink.
     * @param {IdentityLinkUpdateArgs} args - Arguments to update one IdentityLink.
     * @example
     * // Update one IdentityLink
     * const identityLink = await prisma.identityLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentityLinkUpdateArgs>(args: SelectSubset<T, IdentityLinkUpdateArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IdentityLinks.
     * @param {IdentityLinkDeleteManyArgs} args - Arguments to filter IdentityLinks to delete.
     * @example
     * // Delete a few IdentityLinks
     * const { count } = await prisma.identityLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentityLinkDeleteManyArgs>(args?: SelectSubset<T, IdentityLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdentityLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdentityLinks
     * const identityLink = await prisma.identityLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentityLinkUpdateManyArgs>(args: SelectSubset<T, IdentityLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IdentityLink.
     * @param {IdentityLinkUpsertArgs} args - Arguments to update or create a IdentityLink.
     * @example
     * // Update or create a IdentityLink
     * const identityLink = await prisma.identityLink.upsert({
     *   create: {
     *     // ... data to create a IdentityLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdentityLink we want to update
     *   }
     * })
     */
    upsert<T extends IdentityLinkUpsertArgs>(args: SelectSubset<T, IdentityLinkUpsertArgs<ExtArgs>>): Prisma__IdentityLinkClient<$Result.GetResult<Prisma.$IdentityLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IdentityLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkCountArgs} args - Arguments to filter IdentityLinks to count.
     * @example
     * // Count the number of IdentityLinks
     * const count = await prisma.identityLink.count({
     *   where: {
     *     // ... the filter for the IdentityLinks we want to count
     *   }
     * })
    **/
    count<T extends IdentityLinkCountArgs>(
      args?: Subset<T, IdentityLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentityLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdentityLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentityLinkAggregateArgs>(args: Subset<T, IdentityLinkAggregateArgs>): Prisma.PrismaPromise<GetIdentityLinkAggregateType<T>>

    /**
     * Group by IdentityLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentityLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentityLinkGroupByArgs['orderBy'] }
        : { orderBy?: IdentityLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentityLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentityLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdentityLink model
   */
  readonly fields: IdentityLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdentityLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentityLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerProfile<T extends CustomerProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProfileDefaultArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdentityLink model
   */ 
  interface IdentityLinkFieldRefs {
    readonly id: FieldRef<"IdentityLink", 'String'>
    readonly customerProfileId: FieldRef<"IdentityLink", 'String'>
    readonly sourceType: FieldRef<"IdentityLink", 'String'>
    readonly sourceId: FieldRef<"IdentityLink", 'String'>
    readonly mergedAt: FieldRef<"IdentityLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IdentityLink findUnique
   */
  export type IdentityLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter, which IdentityLink to fetch.
     */
    where: IdentityLinkWhereUniqueInput
  }

  /**
   * IdentityLink findUniqueOrThrow
   */
  export type IdentityLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter, which IdentityLink to fetch.
     */
    where: IdentityLinkWhereUniqueInput
  }

  /**
   * IdentityLink findFirst
   */
  export type IdentityLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter, which IdentityLink to fetch.
     */
    where?: IdentityLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityLinks to fetch.
     */
    orderBy?: IdentityLinkOrderByWithRelationInput | IdentityLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentityLinks.
     */
    cursor?: IdentityLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentityLinks.
     */
    distinct?: IdentityLinkScalarFieldEnum | IdentityLinkScalarFieldEnum[]
  }

  /**
   * IdentityLink findFirstOrThrow
   */
  export type IdentityLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter, which IdentityLink to fetch.
     */
    where?: IdentityLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityLinks to fetch.
     */
    orderBy?: IdentityLinkOrderByWithRelationInput | IdentityLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdentityLinks.
     */
    cursor?: IdentityLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdentityLinks.
     */
    distinct?: IdentityLinkScalarFieldEnum | IdentityLinkScalarFieldEnum[]
  }

  /**
   * IdentityLink findMany
   */
  export type IdentityLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter, which IdentityLinks to fetch.
     */
    where?: IdentityLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdentityLinks to fetch.
     */
    orderBy?: IdentityLinkOrderByWithRelationInput | IdentityLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdentityLinks.
     */
    cursor?: IdentityLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdentityLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdentityLinks.
     */
    skip?: number
    distinct?: IdentityLinkScalarFieldEnum | IdentityLinkScalarFieldEnum[]
  }

  /**
   * IdentityLink create
   */
  export type IdentityLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a IdentityLink.
     */
    data: XOR<IdentityLinkCreateInput, IdentityLinkUncheckedCreateInput>
  }

  /**
   * IdentityLink createMany
   */
  export type IdentityLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdentityLinks.
     */
    data: IdentityLinkCreateManyInput | IdentityLinkCreateManyInput[]
  }

  /**
   * IdentityLink createManyAndReturn
   */
  export type IdentityLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IdentityLinks.
     */
    data: IdentityLinkCreateManyInput | IdentityLinkCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdentityLink update
   */
  export type IdentityLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a IdentityLink.
     */
    data: XOR<IdentityLinkUpdateInput, IdentityLinkUncheckedUpdateInput>
    /**
     * Choose, which IdentityLink to update.
     */
    where: IdentityLinkWhereUniqueInput
  }

  /**
   * IdentityLink updateMany
   */
  export type IdentityLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdentityLinks.
     */
    data: XOR<IdentityLinkUpdateManyMutationInput, IdentityLinkUncheckedUpdateManyInput>
    /**
     * Filter which IdentityLinks to update
     */
    where?: IdentityLinkWhereInput
  }

  /**
   * IdentityLink upsert
   */
  export type IdentityLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the IdentityLink to update in case it exists.
     */
    where: IdentityLinkWhereUniqueInput
    /**
     * In case the IdentityLink found by the `where` argument doesn't exist, create a new IdentityLink with this data.
     */
    create: XOR<IdentityLinkCreateInput, IdentityLinkUncheckedCreateInput>
    /**
     * In case the IdentityLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentityLinkUpdateInput, IdentityLinkUncheckedUpdateInput>
  }

  /**
   * IdentityLink delete
   */
  export type IdentityLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
    /**
     * Filter which IdentityLink to delete.
     */
    where: IdentityLinkWhereUniqueInput
  }

  /**
   * IdentityLink deleteMany
   */
  export type IdentityLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdentityLinks to delete
     */
    where?: IdentityLinkWhereInput
  }

  /**
   * IdentityLink without action
   */
  export type IdentityLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdentityLink
     */
    select?: IdentityLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityLinkInclude<ExtArgs> | null
  }


  /**
   * Model WebVisit
   */

  export type AggregateWebVisit = {
    _count: WebVisitCountAggregateOutputType | null
    _avg: WebVisitAvgAggregateOutputType | null
    _sum: WebVisitSumAggregateOutputType | null
    _min: WebVisitMinAggregateOutputType | null
    _max: WebVisitMaxAggregateOutputType | null
  }

  export type WebVisitAvgAggregateOutputType = {
    duration: number | null
  }

  export type WebVisitSumAggregateOutputType = {
    duration: number | null
  }

  export type WebVisitMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    visitorId: string | null
    customerProfileId: string | null
    url: string | null
    referrer: string | null
    userAgent: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type WebVisitMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    visitorId: string | null
    customerProfileId: string | null
    url: string | null
    referrer: string | null
    userAgent: string | null
    duration: number | null
    timestamp: Date | null
  }

  export type WebVisitCountAggregateOutputType = {
    id: number
    sessionId: number
    visitorId: number
    customerProfileId: number
    url: number
    referrer: number
    userAgent: number
    duration: number
    timestamp: number
    _all: number
  }


  export type WebVisitAvgAggregateInputType = {
    duration?: true
  }

  export type WebVisitSumAggregateInputType = {
    duration?: true
  }

  export type WebVisitMinAggregateInputType = {
    id?: true
    sessionId?: true
    visitorId?: true
    customerProfileId?: true
    url?: true
    referrer?: true
    userAgent?: true
    duration?: true
    timestamp?: true
  }

  export type WebVisitMaxAggregateInputType = {
    id?: true
    sessionId?: true
    visitorId?: true
    customerProfileId?: true
    url?: true
    referrer?: true
    userAgent?: true
    duration?: true
    timestamp?: true
  }

  export type WebVisitCountAggregateInputType = {
    id?: true
    sessionId?: true
    visitorId?: true
    customerProfileId?: true
    url?: true
    referrer?: true
    userAgent?: true
    duration?: true
    timestamp?: true
    _all?: true
  }

  export type WebVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebVisit to aggregate.
     */
    where?: WebVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebVisits to fetch.
     */
    orderBy?: WebVisitOrderByWithRelationInput | WebVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebVisits
    **/
    _count?: true | WebVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebVisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebVisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebVisitMaxAggregateInputType
  }

  export type GetWebVisitAggregateType<T extends WebVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateWebVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebVisit[P]>
      : GetScalarType<T[P], AggregateWebVisit[P]>
  }




  export type WebVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebVisitWhereInput
    orderBy?: WebVisitOrderByWithAggregationInput | WebVisitOrderByWithAggregationInput[]
    by: WebVisitScalarFieldEnum[] | WebVisitScalarFieldEnum
    having?: WebVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebVisitCountAggregateInputType | true
    _avg?: WebVisitAvgAggregateInputType
    _sum?: WebVisitSumAggregateInputType
    _min?: WebVisitMinAggregateInputType
    _max?: WebVisitMaxAggregateInputType
  }

  export type WebVisitGroupByOutputType = {
    id: string
    sessionId: string
    visitorId: string | null
    customerProfileId: string | null
    url: string
    referrer: string | null
    userAgent: string | null
    duration: number
    timestamp: Date
    _count: WebVisitCountAggregateOutputType | null
    _avg: WebVisitAvgAggregateOutputType | null
    _sum: WebVisitSumAggregateOutputType | null
    _min: WebVisitMinAggregateOutputType | null
    _max: WebVisitMaxAggregateOutputType | null
  }

  type GetWebVisitGroupByPayload<T extends WebVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebVisitGroupByOutputType[P]>
            : GetScalarType<T[P], WebVisitGroupByOutputType[P]>
        }
      >
    >


  export type WebVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    visitorId?: boolean
    customerProfileId?: boolean
    url?: boolean
    referrer?: boolean
    userAgent?: boolean
    duration?: boolean
    timestamp?: boolean
    customerProfile?: boolean | WebVisit$customerProfileArgs<ExtArgs>
  }, ExtArgs["result"]["webVisit"]>

  export type WebVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    visitorId?: boolean
    customerProfileId?: boolean
    url?: boolean
    referrer?: boolean
    userAgent?: boolean
    duration?: boolean
    timestamp?: boolean
    customerProfile?: boolean | WebVisit$customerProfileArgs<ExtArgs>
  }, ExtArgs["result"]["webVisit"]>

  export type WebVisitSelectScalar = {
    id?: boolean
    sessionId?: boolean
    visitorId?: boolean
    customerProfileId?: boolean
    url?: boolean
    referrer?: boolean
    userAgent?: boolean
    duration?: boolean
    timestamp?: boolean
  }

  export type WebVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProfile?: boolean | WebVisit$customerProfileArgs<ExtArgs>
  }
  export type WebVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProfile?: boolean | WebVisit$customerProfileArgs<ExtArgs>
  }

  export type $WebVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebVisit"
    objects: {
      customerProfile: Prisma.$CustomerProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      visitorId: string | null
      customerProfileId: string | null
      url: string
      referrer: string | null
      userAgent: string | null
      duration: number
      timestamp: Date
    }, ExtArgs["result"]["webVisit"]>
    composites: {}
  }

  type WebVisitGetPayload<S extends boolean | null | undefined | WebVisitDefaultArgs> = $Result.GetResult<Prisma.$WebVisitPayload, S>

  type WebVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebVisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebVisitCountAggregateInputType | true
    }

  export interface WebVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebVisit'], meta: { name: 'WebVisit' } }
    /**
     * Find zero or one WebVisit that matches the filter.
     * @param {WebVisitFindUniqueArgs} args - Arguments to find a WebVisit
     * @example
     * // Get one WebVisit
     * const webVisit = await prisma.webVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebVisitFindUniqueArgs>(args: SelectSubset<T, WebVisitFindUniqueArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebVisit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebVisitFindUniqueOrThrowArgs} args - Arguments to find a WebVisit
     * @example
     * // Get one WebVisit
     * const webVisit = await prisma.webVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, WebVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitFindFirstArgs} args - Arguments to find a WebVisit
     * @example
     * // Get one WebVisit
     * const webVisit = await prisma.webVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebVisitFindFirstArgs>(args?: SelectSubset<T, WebVisitFindFirstArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitFindFirstOrThrowArgs} args - Arguments to find a WebVisit
     * @example
     * // Get one WebVisit
     * const webVisit = await prisma.webVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, WebVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebVisits
     * const webVisits = await prisma.webVisit.findMany()
     * 
     * // Get first 10 WebVisits
     * const webVisits = await prisma.webVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webVisitWithIdOnly = await prisma.webVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebVisitFindManyArgs>(args?: SelectSubset<T, WebVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebVisit.
     * @param {WebVisitCreateArgs} args - Arguments to create a WebVisit.
     * @example
     * // Create one WebVisit
     * const WebVisit = await prisma.webVisit.create({
     *   data: {
     *     // ... data to create a WebVisit
     *   }
     * })
     * 
     */
    create<T extends WebVisitCreateArgs>(args: SelectSubset<T, WebVisitCreateArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebVisits.
     * @param {WebVisitCreateManyArgs} args - Arguments to create many WebVisits.
     * @example
     * // Create many WebVisits
     * const webVisit = await prisma.webVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebVisitCreateManyArgs>(args?: SelectSubset<T, WebVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebVisits and returns the data saved in the database.
     * @param {WebVisitCreateManyAndReturnArgs} args - Arguments to create many WebVisits.
     * @example
     * // Create many WebVisits
     * const webVisit = await prisma.webVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebVisits and only return the `id`
     * const webVisitWithIdOnly = await prisma.webVisit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, WebVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebVisit.
     * @param {WebVisitDeleteArgs} args - Arguments to delete one WebVisit.
     * @example
     * // Delete one WebVisit
     * const WebVisit = await prisma.webVisit.delete({
     *   where: {
     *     // ... filter to delete one WebVisit
     *   }
     * })
     * 
     */
    delete<T extends WebVisitDeleteArgs>(args: SelectSubset<T, WebVisitDeleteArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebVisit.
     * @param {WebVisitUpdateArgs} args - Arguments to update one WebVisit.
     * @example
     * // Update one WebVisit
     * const webVisit = await prisma.webVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebVisitUpdateArgs>(args: SelectSubset<T, WebVisitUpdateArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebVisits.
     * @param {WebVisitDeleteManyArgs} args - Arguments to filter WebVisits to delete.
     * @example
     * // Delete a few WebVisits
     * const { count } = await prisma.webVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebVisitDeleteManyArgs>(args?: SelectSubset<T, WebVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebVisits
     * const webVisit = await prisma.webVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebVisitUpdateManyArgs>(args: SelectSubset<T, WebVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebVisit.
     * @param {WebVisitUpsertArgs} args - Arguments to update or create a WebVisit.
     * @example
     * // Update or create a WebVisit
     * const webVisit = await prisma.webVisit.upsert({
     *   create: {
     *     // ... data to create a WebVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebVisit we want to update
     *   }
     * })
     */
    upsert<T extends WebVisitUpsertArgs>(args: SelectSubset<T, WebVisitUpsertArgs<ExtArgs>>): Prisma__WebVisitClient<$Result.GetResult<Prisma.$WebVisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitCountArgs} args - Arguments to filter WebVisits to count.
     * @example
     * // Count the number of WebVisits
     * const count = await prisma.webVisit.count({
     *   where: {
     *     // ... the filter for the WebVisits we want to count
     *   }
     * })
    **/
    count<T extends WebVisitCountArgs>(
      args?: Subset<T, WebVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebVisitAggregateArgs>(args: Subset<T, WebVisitAggregateArgs>): Prisma.PrismaPromise<GetWebVisitAggregateType<T>>

    /**
     * Group by WebVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebVisitGroupByArgs['orderBy'] }
        : { orderBy?: WebVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebVisit model
   */
  readonly fields: WebVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerProfile<T extends WebVisit$customerProfileArgs<ExtArgs> = {}>(args?: Subset<T, WebVisit$customerProfileArgs<ExtArgs>>): Prisma__CustomerProfileClient<$Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebVisit model
   */ 
  interface WebVisitFieldRefs {
    readonly id: FieldRef<"WebVisit", 'String'>
    readonly sessionId: FieldRef<"WebVisit", 'String'>
    readonly visitorId: FieldRef<"WebVisit", 'String'>
    readonly customerProfileId: FieldRef<"WebVisit", 'String'>
    readonly url: FieldRef<"WebVisit", 'String'>
    readonly referrer: FieldRef<"WebVisit", 'String'>
    readonly userAgent: FieldRef<"WebVisit", 'String'>
    readonly duration: FieldRef<"WebVisit", 'Int'>
    readonly timestamp: FieldRef<"WebVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebVisit findUnique
   */
  export type WebVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter, which WebVisit to fetch.
     */
    where: WebVisitWhereUniqueInput
  }

  /**
   * WebVisit findUniqueOrThrow
   */
  export type WebVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter, which WebVisit to fetch.
     */
    where: WebVisitWhereUniqueInput
  }

  /**
   * WebVisit findFirst
   */
  export type WebVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter, which WebVisit to fetch.
     */
    where?: WebVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebVisits to fetch.
     */
    orderBy?: WebVisitOrderByWithRelationInput | WebVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebVisits.
     */
    cursor?: WebVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebVisits.
     */
    distinct?: WebVisitScalarFieldEnum | WebVisitScalarFieldEnum[]
  }

  /**
   * WebVisit findFirstOrThrow
   */
  export type WebVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter, which WebVisit to fetch.
     */
    where?: WebVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebVisits to fetch.
     */
    orderBy?: WebVisitOrderByWithRelationInput | WebVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebVisits.
     */
    cursor?: WebVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebVisits.
     */
    distinct?: WebVisitScalarFieldEnum | WebVisitScalarFieldEnum[]
  }

  /**
   * WebVisit findMany
   */
  export type WebVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter, which WebVisits to fetch.
     */
    where?: WebVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebVisits to fetch.
     */
    orderBy?: WebVisitOrderByWithRelationInput | WebVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebVisits.
     */
    cursor?: WebVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebVisits.
     */
    skip?: number
    distinct?: WebVisitScalarFieldEnum | WebVisitScalarFieldEnum[]
  }

  /**
   * WebVisit create
   */
  export type WebVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a WebVisit.
     */
    data: XOR<WebVisitCreateInput, WebVisitUncheckedCreateInput>
  }

  /**
   * WebVisit createMany
   */
  export type WebVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebVisits.
     */
    data: WebVisitCreateManyInput | WebVisitCreateManyInput[]
  }

  /**
   * WebVisit createManyAndReturn
   */
  export type WebVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebVisits.
     */
    data: WebVisitCreateManyInput | WebVisitCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebVisit update
   */
  export type WebVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a WebVisit.
     */
    data: XOR<WebVisitUpdateInput, WebVisitUncheckedUpdateInput>
    /**
     * Choose, which WebVisit to update.
     */
    where: WebVisitWhereUniqueInput
  }

  /**
   * WebVisit updateMany
   */
  export type WebVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebVisits.
     */
    data: XOR<WebVisitUpdateManyMutationInput, WebVisitUncheckedUpdateManyInput>
    /**
     * Filter which WebVisits to update
     */
    where?: WebVisitWhereInput
  }

  /**
   * WebVisit upsert
   */
  export type WebVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the WebVisit to update in case it exists.
     */
    where: WebVisitWhereUniqueInput
    /**
     * In case the WebVisit found by the `where` argument doesn't exist, create a new WebVisit with this data.
     */
    create: XOR<WebVisitCreateInput, WebVisitUncheckedCreateInput>
    /**
     * In case the WebVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebVisitUpdateInput, WebVisitUncheckedUpdateInput>
  }

  /**
   * WebVisit delete
   */
  export type WebVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
    /**
     * Filter which WebVisit to delete.
     */
    where: WebVisitWhereUniqueInput
  }

  /**
   * WebVisit deleteMany
   */
  export type WebVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebVisits to delete
     */
    where?: WebVisitWhereInput
  }

  /**
   * WebVisit.customerProfile
   */
  export type WebVisit$customerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null
    where?: CustomerProfileWhereInput
  }

  /**
   * WebVisit without action
   */
  export type WebVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebVisit
     */
    select?: WebVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebVisitInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type CampaignSumAggregateOutputType = {
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    subject: string | null
    content: string | null
    segmentConfig: string | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    status: string | null
    subject: string | null
    content: string | null
    segmentConfig: string | null
    sentCount: number | null
    openCount: number | null
    clickCount: number | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    subject: number
    content: number
    segmentConfig: number
    sentCount: number
    openCount: number
    clickCount: number
    scheduledAt: number
    createdAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type CampaignSumAggregateInputType = {
    sentCount?: true
    openCount?: true
    clickCount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    segmentConfig?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    segmentConfig?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    segmentConfig?: true
    sentCount?: true
    openCount?: true
    clickCount?: true
    scheduledAt?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    type: string
    status: string
    subject: string | null
    content: string
    segmentConfig: string | null
    sentCount: number
    openCount: number
    clickCount: number
    scheduledAt: Date | null
    createdAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    segmentConfig?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    segmentConfig?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    segmentConfig?: boolean
    sentCount?: boolean
    openCount?: boolean
    clickCount?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }


  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      status: string
      subject: string | null
      content: string
      segmentConfig: string | null
      sentCount: number
      openCount: number
      clickCount: number
      scheduledAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly subject: FieldRef<"Campaign", 'String'>
    readonly content: FieldRef<"Campaign", 'String'>
    readonly segmentConfig: FieldRef<"Campaign", 'String'>
    readonly sentCount: FieldRef<"Campaign", 'Int'>
    readonly openCount: FieldRef<"Campaign", 'Int'>
    readonly clickCount: FieldRef<"Campaign", 'Int'>
    readonly scheduledAt: FieldRef<"Campaign", 'DateTime'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowAvgAggregateOutputType = {
    runCount: number | null
  }

  export type WorkflowSumAggregateOutputType = {
    runCount: number | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    triggerType: string | null
    triggerConfig: string | null
    steps: string | null
    isActive: boolean | null
    runCount: number | null
    createdAt: Date | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    triggerType: string | null
    triggerConfig: string | null
    steps: string | null
    isActive: boolean | null
    runCount: number | null
    createdAt: Date | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    name: number
    triggerType: number
    triggerConfig: number
    steps: number
    isActive: number
    runCount: number
    createdAt: number
    _all: number
  }


  export type WorkflowAvgAggregateInputType = {
    runCount?: true
  }

  export type WorkflowSumAggregateInputType = {
    runCount?: true
  }

  export type WorkflowMinAggregateInputType = {
    id?: true
    name?: true
    triggerType?: true
    triggerConfig?: true
    steps?: true
    isActive?: true
    runCount?: true
    createdAt?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    triggerType?: true
    triggerConfig?: true
    steps?: true
    isActive?: true
    runCount?: true
    createdAt?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    name?: true
    triggerType?: true
    triggerConfig?: true
    steps?: true
    isActive?: true
    runCount?: true
    createdAt?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _avg?: WorkflowAvgAggregateInputType
    _sum?: WorkflowSumAggregateInputType
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    name: string
    triggerType: string
    triggerConfig: string
    steps: string
    isActive: boolean
    runCount: number
    createdAt: Date
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    steps?: boolean
    isActive?: boolean
    runCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    steps?: boolean
    isActive?: boolean
    runCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    steps?: boolean
    isActive?: boolean
    runCount?: boolean
    createdAt?: boolean
  }


  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      triggerType: string
      triggerConfig: string
      steps: string
      isActive: boolean
      runCount: number
      createdAt: Date
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */ 
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly triggerType: FieldRef<"Workflow", 'String'>
    readonly triggerConfig: FieldRef<"Workflow", 'String'>
    readonly steps: FieldRef<"Workflow", 'String'>
    readonly isActive: FieldRef<"Workflow", 'Boolean'>
    readonly runCount: FieldRef<"Workflow", 'Int'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    timezone: 'timezone',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const WidgetConfigScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    customCss: 'customCss',
    showLogo: 'showLogo',
    title: 'title'
  };

  export type WidgetConfigScalarFieldEnum = (typeof WidgetConfigScalarFieldEnum)[keyof typeof WidgetConfigScalarFieldEnum]


  export const RoomTypeScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    name: 'name',
    description: 'description',
    basePrice: 'basePrice',
    capacity: 'capacity',
    amenities: 'amenities',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomTypeScalarFieldEnum = (typeof RoomTypeScalarFieldEnum)[keyof typeof RoomTypeScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    name: 'name',
    isActive: 'isActive'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const GuestScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    docType: 'docType',
    docNumber: 'docNumber',
    country: 'country',
    notes: 'notes',
    score: 'score',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuestScalarFieldEnum = (typeof GuestScalarFieldEnum)[keyof typeof GuestScalarFieldEnum]


  export const RatePlanScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    name: 'name',
    description: 'description',
    isDefault: 'isDefault',
    cancellationPolicy: 'cancellationPolicy',
    mealsIncluded: 'mealsIncluded',
    requireCreditCard: 'requireCreditCard',
    noShowFee: 'noShowFee'
  };

  export type RatePlanScalarFieldEnum = (typeof RatePlanScalarFieldEnum)[keyof typeof RatePlanScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    priceMultiplier: 'priceMultiplier'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const DailyPriceScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    ratePlanId: 'ratePlanId',
    date: 'date',
    price: 'price'
  };

  export type DailyPriceScalarFieldEnum = (typeof DailyPriceScalarFieldEnum)[keyof typeof DailyPriceScalarFieldEnum]


  export const RestrictionScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomTypeId: 'roomTypeId',
    ratePlanId: 'ratePlanId',
    date: 'date',
    minStay: 'minStay',
    maxStay: 'maxStay',
    closedToArrival: 'closedToArrival',
    closedToDeparture: 'closedToDeparture',
    stopSell: 'stopSell'
  };

  export type RestrictionScalarFieldEnum = (typeof RestrictionScalarFieldEnum)[keyof typeof RestrictionScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    referenceCode: 'referenceCode',
    guestId: 'guestId',
    guestName: 'guestName',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    status: 'status',
    source: 'source',
    totalPrice: 'totalPrice',
    currency: 'currency',
    isPaid: 'isPaid',
    stripeCustomerId: 'stripeCustomerId',
    stripePaymentMethodId: 'stripePaymentMethodId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    nights: 'nights',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    otaId: 'otaId',
    otaRawData: 'otaRawData'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingRoomScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    roomId: 'roomId',
    priceSnapshot: 'priceSnapshot',
    date: 'date'
  };

  export type BookingRoomScalarFieldEnum = (typeof BookingRoomScalarFieldEnum)[keyof typeof BookingRoomScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    isEnabled: 'isEnabled'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ChannelMappingScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    roomTypeId: 'roomTypeId',
    ratePlanId: 'ratePlanId',
    externalId: 'externalId',
    externalName: 'externalName',
    syncEnabled: 'syncEnabled'
  };

  export type ChannelMappingScalarFieldEnum = (typeof ChannelMappingScalarFieldEnum)[keyof typeof ChannelMappingScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    channel: 'channel',
    action: 'action',
    status: 'status',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    actor: 'actor',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ICalFeedScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    url: 'url',
    name: 'name',
    source: 'source',
    lastSync: 'lastSync',
    isActive: 'isActive'
  };

  export type ICalFeedScalarFieldEnum = (typeof ICalFeedScalarFieldEnum)[keyof typeof ICalFeedScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    gateway: 'gateway',
    transactionId: 'transactionId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    currency: 'currency'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    restaurantId: 'restaurantId',
    name: 'name',
    index: 'index',
    isActive: 'isActive'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    zoneId: 'zoneId',
    name: 'name',
    capacity: 'capacity',
    x: 'x',
    y: 'y',
    width: 'width',
    height: 'height',
    shape: 'shape',
    rotation: 'rotation',
    isActive: 'isActive',
    minPax: 'minPax',
    maxPax: 'maxPax'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const ResBookingScalarFieldEnum: {
    id: 'id',
    restaurantId: 'restaurantId',
    tableId: 'tableId',
    guestName: 'guestName',
    guestPhone: 'guestPhone',
    guestEmail: 'guestEmail',
    pax: 'pax',
    date: 'date',
    duration: 'duration',
    status: 'status',
    tags: 'tags',
    notes: 'notes',
    origin: 'origin',
    stripeCustomerId: 'stripeCustomerId',
    stripePaymentMethodId: 'stripePaymentMethodId',
    smsSent: 'smsSent',
    emailSent: 'emailSent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    idempotencyKey: 'idempotencyKey',
    channelId: 'channelId'
  };

  export type ResBookingScalarFieldEnum = (typeof ResBookingScalarFieldEnum)[keyof typeof ResBookingScalarFieldEnum]


  export const RestaurantChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    commission: 'commission'
  };

  export type RestaurantChannelScalarFieldEnum = (typeof RestaurantChannelScalarFieldEnum)[keyof typeof RestaurantChannelScalarFieldEnum]


  export const ResPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cancelHours: 'cancelHours',
    noShowFee: 'noShowFee',
    requireCreditCard: 'requireCreditCard',
    isActive: 'isActive'
  };

  export type ResPolicyScalarFieldEnum = (typeof ResPolicyScalarFieldEnum)[keyof typeof ResPolicyScalarFieldEnum]


  export const TableHoldScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type TableHoldScalarFieldEnum = (typeof TableHoldScalarFieldEnum)[keyof typeof TableHoldScalarFieldEnum]


  export const RestaurantWaitlistScalarFieldEnum: {
    id: 'id',
    restaurantId: 'restaurantId',
    name: 'name',
    phone: 'phone',
    pax: 'pax',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    notifiedAt: 'notifiedAt'
  };

  export type RestaurantWaitlistScalarFieldEnum = (typeof RestaurantWaitlistScalarFieldEnum)[keyof typeof RestaurantWaitlistScalarFieldEnum]


  export const HotelWaitlistScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    roomTypeId: 'roomTypeId',
    email: 'email',
    dateFrom: 'dateFrom',
    dateTo: 'dateTo',
    requestDate: 'requestDate',
    fulfilled: 'fulfilled'
  };

  export type HotelWaitlistScalarFieldEnum = (typeof HotelWaitlistScalarFieldEnum)[keyof typeof HotelWaitlistScalarFieldEnum]


  export const CustomerProfileScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    lifecycleStage: 'lifecycleStage',
    totalSpend: 'totalSpend',
    visitCount: 'visitCount',
    lastInteraction: 'lastInteraction',
    tags: 'tags',
    consentEmail: 'consentEmail',
    consentWhatsApp: 'consentWhatsApp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerProfileScalarFieldEnum = (typeof CustomerProfileScalarFieldEnum)[keyof typeof CustomerProfileScalarFieldEnum]


  export const IdentityLinkScalarFieldEnum: {
    id: 'id',
    customerProfileId: 'customerProfileId',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    mergedAt: 'mergedAt'
  };

  export type IdentityLinkScalarFieldEnum = (typeof IdentityLinkScalarFieldEnum)[keyof typeof IdentityLinkScalarFieldEnum]


  export const WebVisitScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    visitorId: 'visitorId',
    customerProfileId: 'customerProfileId',
    url: 'url',
    referrer: 'referrer',
    userAgent: 'userAgent',
    duration: 'duration',
    timestamp: 'timestamp'
  };

  export type WebVisitScalarFieldEnum = (typeof WebVisitScalarFieldEnum)[keyof typeof WebVisitScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    subject: 'subject',
    content: 'content',
    segmentConfig: 'segmentConfig',
    sentCount: 'sentCount',
    openCount: 'openCount',
    clickCount: 'clickCount',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    triggerType: 'triggerType',
    triggerConfig: 'triggerConfig',
    steps: 'steps',
    isActive: 'isActive',
    runCount: 'runCount',
    createdAt: 'createdAt'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: StringFilter<"Hotel"> | string
    name?: StringFilter<"Hotel"> | string
    domain?: StringNullableFilter<"Hotel"> | string | null
    timezone?: StringFilter<"Hotel"> | string
    currency?: StringFilter<"Hotel"> | string
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    roomTypes?: RoomTypeListRelationFilter
    bookings?: BookingListRelationFilter
    ratePlans?: RatePlanListRelationFilter
    seasons?: SeasonListRelationFilter
    users?: UserListRelationFilter
    widgetConfig?: XOR<WidgetConfigNullableRelationFilter, WidgetConfigWhereInput> | null
    restrictions?: RestrictionListRelationFilter
    waitlistEntries?: HotelWaitlistListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    timezone?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roomTypes?: RoomTypeOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    ratePlans?: RatePlanOrderByRelationAggregateInput
    seasons?: SeasonOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    widgetConfig?: WidgetConfigOrderByWithRelationInput
    restrictions?: RestrictionOrderByRelationAggregateInput
    waitlistEntries?: HotelWaitlistOrderByRelationAggregateInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    timezone?: StringFilter<"Hotel"> | string
    currency?: StringFilter<"Hotel"> | string
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    roomTypes?: RoomTypeListRelationFilter
    bookings?: BookingListRelationFilter
    ratePlans?: RatePlanListRelationFilter
    seasons?: SeasonListRelationFilter
    users?: UserListRelationFilter
    widgetConfig?: XOR<WidgetConfigNullableRelationFilter, WidgetConfigWhereInput> | null
    restrictions?: RestrictionListRelationFilter
    waitlistEntries?: HotelWaitlistListRelationFilter
  }, "id" | "domain">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    timezone?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hotel"> | string
    name?: StringWithAggregatesFilter<"Hotel"> | string
    domain?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    timezone?: StringWithAggregatesFilter<"Hotel"> | string
    currency?: StringWithAggregatesFilter<"Hotel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
  }

  export type WidgetConfigWhereInput = {
    AND?: WidgetConfigWhereInput | WidgetConfigWhereInput[]
    OR?: WidgetConfigWhereInput[]
    NOT?: WidgetConfigWhereInput | WidgetConfigWhereInput[]
    id?: StringFilter<"WidgetConfig"> | string
    hotelId?: StringFilter<"WidgetConfig"> | string
    primaryColor?: StringFilter<"WidgetConfig"> | string
    secondaryColor?: StringFilter<"WidgetConfig"> | string
    customCss?: StringNullableFilter<"WidgetConfig"> | string | null
    showLogo?: BoolFilter<"WidgetConfig"> | boolean
    title?: StringNullableFilter<"WidgetConfig"> | string | null
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }

  export type WidgetConfigOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    customCss?: SortOrderInput | SortOrder
    showLogo?: SortOrder
    title?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
  }

  export type WidgetConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hotelId?: string
    AND?: WidgetConfigWhereInput | WidgetConfigWhereInput[]
    OR?: WidgetConfigWhereInput[]
    NOT?: WidgetConfigWhereInput | WidgetConfigWhereInput[]
    primaryColor?: StringFilter<"WidgetConfig"> | string
    secondaryColor?: StringFilter<"WidgetConfig"> | string
    customCss?: StringNullableFilter<"WidgetConfig"> | string | null
    showLogo?: BoolFilter<"WidgetConfig"> | boolean
    title?: StringNullableFilter<"WidgetConfig"> | string | null
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }, "id" | "hotelId">

  export type WidgetConfigOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    customCss?: SortOrderInput | SortOrder
    showLogo?: SortOrder
    title?: SortOrderInput | SortOrder
    _count?: WidgetConfigCountOrderByAggregateInput
    _max?: WidgetConfigMaxOrderByAggregateInput
    _min?: WidgetConfigMinOrderByAggregateInput
  }

  export type WidgetConfigScalarWhereWithAggregatesInput = {
    AND?: WidgetConfigScalarWhereWithAggregatesInput | WidgetConfigScalarWhereWithAggregatesInput[]
    OR?: WidgetConfigScalarWhereWithAggregatesInput[]
    NOT?: WidgetConfigScalarWhereWithAggregatesInput | WidgetConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WidgetConfig"> | string
    hotelId?: StringWithAggregatesFilter<"WidgetConfig"> | string
    primaryColor?: StringWithAggregatesFilter<"WidgetConfig"> | string
    secondaryColor?: StringWithAggregatesFilter<"WidgetConfig"> | string
    customCss?: StringNullableWithAggregatesFilter<"WidgetConfig"> | string | null
    showLogo?: BoolWithAggregatesFilter<"WidgetConfig"> | boolean
    title?: StringNullableWithAggregatesFilter<"WidgetConfig"> | string | null
  }

  export type RoomTypeWhereInput = {
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    id?: StringFilter<"RoomType"> | string
    hotelId?: StringFilter<"RoomType"> | string
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    basePrice?: DecimalFilter<"RoomType"> | Decimal | DecimalJsLike | number | string
    capacity?: IntFilter<"RoomType"> | number
    amenities?: StringNullableFilter<"RoomType"> | string | null
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    rooms?: RoomListRelationFilter
    icalFeeds?: ICalFeedListRelationFilter
    dailyPrices?: DailyPriceListRelationFilter
    restrictions?: RestrictionListRelationFilter
    channelMappings?: ChannelMappingListRelationFilter
    waitlistEntries?: HotelWaitlistListRelationFilter
  }

  export type RoomTypeOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    rooms?: RoomOrderByRelationAggregateInput
    icalFeeds?: ICalFeedOrderByRelationAggregateInput
    dailyPrices?: DailyPriceOrderByRelationAggregateInput
    restrictions?: RestrictionOrderByRelationAggregateInput
    channelMappings?: ChannelMappingOrderByRelationAggregateInput
    waitlistEntries?: HotelWaitlistOrderByRelationAggregateInput
  }

  export type RoomTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    hotelId?: StringFilter<"RoomType"> | string
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    basePrice?: DecimalFilter<"RoomType"> | Decimal | DecimalJsLike | number | string
    capacity?: IntFilter<"RoomType"> | number
    amenities?: StringNullableFilter<"RoomType"> | string | null
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    rooms?: RoomListRelationFilter
    icalFeeds?: ICalFeedListRelationFilter
    dailyPrices?: DailyPriceListRelationFilter
    restrictions?: RestrictionListRelationFilter
    channelMappings?: ChannelMappingListRelationFilter
    waitlistEntries?: HotelWaitlistListRelationFilter
  }, "id">

  export type RoomTypeOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomTypeCountOrderByAggregateInput
    _avg?: RoomTypeAvgOrderByAggregateInput
    _max?: RoomTypeMaxOrderByAggregateInput
    _min?: RoomTypeMinOrderByAggregateInput
    _sum?: RoomTypeSumOrderByAggregateInput
  }

  export type RoomTypeScalarWhereWithAggregatesInput = {
    AND?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    OR?: RoomTypeScalarWhereWithAggregatesInput[]
    NOT?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomType"> | string
    hotelId?: StringWithAggregatesFilter<"RoomType"> | string
    name?: StringWithAggregatesFilter<"RoomType"> | string
    description?: StringNullableWithAggregatesFilter<"RoomType"> | string | null
    basePrice?: DecimalWithAggregatesFilter<"RoomType"> | Decimal | DecimalJsLike | number | string
    capacity?: IntWithAggregatesFilter<"RoomType"> | number
    amenities?: StringNullableWithAggregatesFilter<"RoomType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomType"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    roomTypeId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    isActive?: BoolFilter<"Room"> | boolean
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    bookingRooms?: BookingRoomListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    roomType?: RoomTypeOrderByWithRelationInput
    bookingRooms?: BookingRoomOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomTypeId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    isActive?: BoolFilter<"Room"> | boolean
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    bookingRooms?: BookingRoomListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    roomTypeId?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    isActive?: BoolWithAggregatesFilter<"Room"> | boolean
  }

  export type GuestWhereInput = {
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    id?: StringFilter<"Guest"> | string
    firstName?: StringFilter<"Guest"> | string
    lastName?: StringNullableFilter<"Guest"> | string | null
    email?: StringNullableFilter<"Guest"> | string | null
    phone?: StringNullableFilter<"Guest"> | string | null
    docType?: StringNullableFilter<"Guest"> | string | null
    docNumber?: StringNullableFilter<"Guest"> | string | null
    country?: StringNullableFilter<"Guest"> | string | null
    notes?: StringNullableFilter<"Guest"> | string | null
    score?: IntFilter<"Guest"> | number
    tags?: StringNullableFilter<"Guest"> | string | null
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    bookings?: BookingListRelationFilter
  }

  export type GuestOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    docNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    score?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type GuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    firstName?: StringFilter<"Guest"> | string
    lastName?: StringNullableFilter<"Guest"> | string | null
    phone?: StringNullableFilter<"Guest"> | string | null
    docType?: StringNullableFilter<"Guest"> | string | null
    docNumber?: StringNullableFilter<"Guest"> | string | null
    country?: StringNullableFilter<"Guest"> | string | null
    notes?: StringNullableFilter<"Guest"> | string | null
    score?: IntFilter<"Guest"> | number
    tags?: StringNullableFilter<"Guest"> | string | null
    createdAt?: DateTimeFilter<"Guest"> | Date | string
    updatedAt?: DateTimeFilter<"Guest"> | Date | string
    bookings?: BookingListRelationFilter
  }, "id" | "email">

  export type GuestOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    docType?: SortOrderInput | SortOrder
    docNumber?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    score?: SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuestCountOrderByAggregateInput
    _avg?: GuestAvgOrderByAggregateInput
    _max?: GuestMaxOrderByAggregateInput
    _min?: GuestMinOrderByAggregateInput
    _sum?: GuestSumOrderByAggregateInput
  }

  export type GuestScalarWhereWithAggregatesInput = {
    AND?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    OR?: GuestScalarWhereWithAggregatesInput[]
    NOT?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guest"> | string
    firstName?: StringWithAggregatesFilter<"Guest"> | string
    lastName?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    email?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    docType?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    docNumber?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    country?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    score?: IntWithAggregatesFilter<"Guest"> | number
    tags?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guest"> | Date | string
  }

  export type RatePlanWhereInput = {
    AND?: RatePlanWhereInput | RatePlanWhereInput[]
    OR?: RatePlanWhereInput[]
    NOT?: RatePlanWhereInput | RatePlanWhereInput[]
    id?: StringFilter<"RatePlan"> | string
    hotelId?: StringFilter<"RatePlan"> | string
    name?: StringFilter<"RatePlan"> | string
    description?: StringNullableFilter<"RatePlan"> | string | null
    isDefault?: BoolFilter<"RatePlan"> | boolean
    cancellationPolicy?: StringNullableFilter<"RatePlan"> | string | null
    mealsIncluded?: StringNullableFilter<"RatePlan"> | string | null
    requireCreditCard?: BoolFilter<"RatePlan"> | boolean
    noShowFee?: DecimalFilter<"RatePlan"> | Decimal | DecimalJsLike | number | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    dailyPrices?: DailyPriceListRelationFilter
    restrictions?: RestrictionListRelationFilter
    channelMappings?: ChannelMappingListRelationFilter
  }

  export type RatePlanOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    mealsIncluded?: SortOrderInput | SortOrder
    requireCreditCard?: SortOrder
    noShowFee?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    dailyPrices?: DailyPriceOrderByRelationAggregateInput
    restrictions?: RestrictionOrderByRelationAggregateInput
    channelMappings?: ChannelMappingOrderByRelationAggregateInput
  }

  export type RatePlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RatePlanWhereInput | RatePlanWhereInput[]
    OR?: RatePlanWhereInput[]
    NOT?: RatePlanWhereInput | RatePlanWhereInput[]
    hotelId?: StringFilter<"RatePlan"> | string
    name?: StringFilter<"RatePlan"> | string
    description?: StringNullableFilter<"RatePlan"> | string | null
    isDefault?: BoolFilter<"RatePlan"> | boolean
    cancellationPolicy?: StringNullableFilter<"RatePlan"> | string | null
    mealsIncluded?: StringNullableFilter<"RatePlan"> | string | null
    requireCreditCard?: BoolFilter<"RatePlan"> | boolean
    noShowFee?: DecimalFilter<"RatePlan"> | Decimal | DecimalJsLike | number | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    dailyPrices?: DailyPriceListRelationFilter
    restrictions?: RestrictionListRelationFilter
    channelMappings?: ChannelMappingListRelationFilter
  }, "id">

  export type RatePlanOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    mealsIncluded?: SortOrderInput | SortOrder
    requireCreditCard?: SortOrder
    noShowFee?: SortOrder
    _count?: RatePlanCountOrderByAggregateInput
    _avg?: RatePlanAvgOrderByAggregateInput
    _max?: RatePlanMaxOrderByAggregateInput
    _min?: RatePlanMinOrderByAggregateInput
    _sum?: RatePlanSumOrderByAggregateInput
  }

  export type RatePlanScalarWhereWithAggregatesInput = {
    AND?: RatePlanScalarWhereWithAggregatesInput | RatePlanScalarWhereWithAggregatesInput[]
    OR?: RatePlanScalarWhereWithAggregatesInput[]
    NOT?: RatePlanScalarWhereWithAggregatesInput | RatePlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RatePlan"> | string
    hotelId?: StringWithAggregatesFilter<"RatePlan"> | string
    name?: StringWithAggregatesFilter<"RatePlan"> | string
    description?: StringNullableWithAggregatesFilter<"RatePlan"> | string | null
    isDefault?: BoolWithAggregatesFilter<"RatePlan"> | boolean
    cancellationPolicy?: StringNullableWithAggregatesFilter<"RatePlan"> | string | null
    mealsIncluded?: StringNullableWithAggregatesFilter<"RatePlan"> | string | null
    requireCreditCard?: BoolWithAggregatesFilter<"RatePlan"> | boolean
    noShowFee?: DecimalWithAggregatesFilter<"RatePlan"> | Decimal | DecimalJsLike | number | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    hotelId?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    priceMultiplier?: DecimalFilter<"Season"> | Decimal | DecimalJsLike | number | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priceMultiplier?: SortOrder
    hotel?: HotelOrderByWithRelationInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    hotelId?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    priceMultiplier?: DecimalFilter<"Season"> | Decimal | DecimalJsLike | number | string
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }, "id">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priceMultiplier?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    hotelId?: StringWithAggregatesFilter<"Season"> | string
    name?: StringWithAggregatesFilter<"Season"> | string
    startDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    priceMultiplier?: DecimalWithAggregatesFilter<"Season"> | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceWhereInput = {
    AND?: DailyPriceWhereInput | DailyPriceWhereInput[]
    OR?: DailyPriceWhereInput[]
    NOT?: DailyPriceWhereInput | DailyPriceWhereInput[]
    id?: StringFilter<"DailyPrice"> | string
    roomTypeId?: StringFilter<"DailyPrice"> | string
    ratePlanId?: StringFilter<"DailyPrice"> | string
    date?: DateTimeFilter<"DailyPrice"> | Date | string
    price?: DecimalFilter<"DailyPrice"> | Decimal | DecimalJsLike | number | string
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    ratePlan?: XOR<RatePlanRelationFilter, RatePlanWhereInput>
  }

  export type DailyPriceOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    roomType?: RoomTypeOrderByWithRelationInput
    ratePlan?: RatePlanOrderByWithRelationInput
  }

  export type DailyPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomTypeId_ratePlanId_date?: DailyPriceRoomTypeIdRatePlanIdDateCompoundUniqueInput
    AND?: DailyPriceWhereInput | DailyPriceWhereInput[]
    OR?: DailyPriceWhereInput[]
    NOT?: DailyPriceWhereInput | DailyPriceWhereInput[]
    roomTypeId?: StringFilter<"DailyPrice"> | string
    ratePlanId?: StringFilter<"DailyPrice"> | string
    date?: DateTimeFilter<"DailyPrice"> | Date | string
    price?: DecimalFilter<"DailyPrice"> | Decimal | DecimalJsLike | number | string
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    ratePlan?: XOR<RatePlanRelationFilter, RatePlanWhereInput>
  }, "id" | "roomTypeId_ratePlanId_date">

  export type DailyPriceOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    _count?: DailyPriceCountOrderByAggregateInput
    _avg?: DailyPriceAvgOrderByAggregateInput
    _max?: DailyPriceMaxOrderByAggregateInput
    _min?: DailyPriceMinOrderByAggregateInput
    _sum?: DailyPriceSumOrderByAggregateInput
  }

  export type DailyPriceScalarWhereWithAggregatesInput = {
    AND?: DailyPriceScalarWhereWithAggregatesInput | DailyPriceScalarWhereWithAggregatesInput[]
    OR?: DailyPriceScalarWhereWithAggregatesInput[]
    NOT?: DailyPriceScalarWhereWithAggregatesInput | DailyPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyPrice"> | string
    roomTypeId?: StringWithAggregatesFilter<"DailyPrice"> | string
    ratePlanId?: StringWithAggregatesFilter<"DailyPrice"> | string
    date?: DateTimeWithAggregatesFilter<"DailyPrice"> | Date | string
    price?: DecimalWithAggregatesFilter<"DailyPrice"> | Decimal | DecimalJsLike | number | string
  }

  export type RestrictionWhereInput = {
    AND?: RestrictionWhereInput | RestrictionWhereInput[]
    OR?: RestrictionWhereInput[]
    NOT?: RestrictionWhereInput | RestrictionWhereInput[]
    id?: StringFilter<"Restriction"> | string
    hotelId?: StringFilter<"Restriction"> | string
    roomTypeId?: StringNullableFilter<"Restriction"> | string | null
    ratePlanId?: StringNullableFilter<"Restriction"> | string | null
    date?: DateTimeFilter<"Restriction"> | Date | string
    minStay?: IntNullableFilter<"Restriction"> | number | null
    maxStay?: IntNullableFilter<"Restriction"> | number | null
    closedToArrival?: BoolFilter<"Restriction"> | boolean
    closedToDeparture?: BoolFilter<"Restriction"> | boolean
    stopSell?: BoolFilter<"Restriction"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    roomType?: XOR<RoomTypeNullableRelationFilter, RoomTypeWhereInput> | null
    ratePlan?: XOR<RatePlanNullableRelationFilter, RatePlanWhereInput> | null
  }

  export type RestrictionOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    ratePlanId?: SortOrderInput | SortOrder
    date?: SortOrder
    minStay?: SortOrderInput | SortOrder
    maxStay?: SortOrderInput | SortOrder
    closedToArrival?: SortOrder
    closedToDeparture?: SortOrder
    stopSell?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    roomType?: RoomTypeOrderByWithRelationInput
    ratePlan?: RatePlanOrderByWithRelationInput
  }

  export type RestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestrictionWhereInput | RestrictionWhereInput[]
    OR?: RestrictionWhereInput[]
    NOT?: RestrictionWhereInput | RestrictionWhereInput[]
    hotelId?: StringFilter<"Restriction"> | string
    roomTypeId?: StringNullableFilter<"Restriction"> | string | null
    ratePlanId?: StringNullableFilter<"Restriction"> | string | null
    date?: DateTimeFilter<"Restriction"> | Date | string
    minStay?: IntNullableFilter<"Restriction"> | number | null
    maxStay?: IntNullableFilter<"Restriction"> | number | null
    closedToArrival?: BoolFilter<"Restriction"> | boolean
    closedToDeparture?: BoolFilter<"Restriction"> | boolean
    stopSell?: BoolFilter<"Restriction"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    roomType?: XOR<RoomTypeNullableRelationFilter, RoomTypeWhereInput> | null
    ratePlan?: XOR<RatePlanNullableRelationFilter, RatePlanWhereInput> | null
  }, "id">

  export type RestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    ratePlanId?: SortOrderInput | SortOrder
    date?: SortOrder
    minStay?: SortOrderInput | SortOrder
    maxStay?: SortOrderInput | SortOrder
    closedToArrival?: SortOrder
    closedToDeparture?: SortOrder
    stopSell?: SortOrder
    _count?: RestrictionCountOrderByAggregateInput
    _avg?: RestrictionAvgOrderByAggregateInput
    _max?: RestrictionMaxOrderByAggregateInput
    _min?: RestrictionMinOrderByAggregateInput
    _sum?: RestrictionSumOrderByAggregateInput
  }

  export type RestrictionScalarWhereWithAggregatesInput = {
    AND?: RestrictionScalarWhereWithAggregatesInput | RestrictionScalarWhereWithAggregatesInput[]
    OR?: RestrictionScalarWhereWithAggregatesInput[]
    NOT?: RestrictionScalarWhereWithAggregatesInput | RestrictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restriction"> | string
    hotelId?: StringWithAggregatesFilter<"Restriction"> | string
    roomTypeId?: StringNullableWithAggregatesFilter<"Restriction"> | string | null
    ratePlanId?: StringNullableWithAggregatesFilter<"Restriction"> | string | null
    date?: DateTimeWithAggregatesFilter<"Restriction"> | Date | string
    minStay?: IntNullableWithAggregatesFilter<"Restriction"> | number | null
    maxStay?: IntNullableWithAggregatesFilter<"Restriction"> | number | null
    closedToArrival?: BoolWithAggregatesFilter<"Restriction"> | boolean
    closedToDeparture?: BoolWithAggregatesFilter<"Restriction"> | boolean
    stopSell?: BoolWithAggregatesFilter<"Restriction"> | boolean
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    hotelId?: StringFilter<"Booking"> | string
    referenceCode?: StringFilter<"Booking"> | string
    guestId?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    source?: StringFilter<"Booking"> | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    isPaid?: BoolFilter<"Booking"> | boolean
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Booking"> | string | null
    checkInDate?: DateTimeFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeFilter<"Booking"> | Date | string
    nights?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    otaId?: StringNullableFilter<"Booking"> | string | null
    otaRawData?: StringNullableFilter<"Booking"> | string | null
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    guest?: XOR<GuestNullableRelationFilter, GuestWhereInput> | null
    bookingRooms?: BookingRoomListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    referenceCode?: SortOrder
    guestId?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripePaymentMethodId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    nights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otaId?: SortOrderInput | SortOrder
    otaRawData?: SortOrderInput | SortOrder
    hotel?: HotelOrderByWithRelationInput
    guest?: GuestOrderByWithRelationInput
    bookingRooms?: BookingRoomOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceCode?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    hotelId?: StringFilter<"Booking"> | string
    guestId?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    source?: StringFilter<"Booking"> | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    isPaid?: BoolFilter<"Booking"> | boolean
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Booking"> | string | null
    checkInDate?: DateTimeFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeFilter<"Booking"> | Date | string
    nights?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    otaId?: StringNullableFilter<"Booking"> | string | null
    otaRawData?: StringNullableFilter<"Booking"> | string | null
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    guest?: XOR<GuestNullableRelationFilter, GuestWhereInput> | null
    bookingRooms?: BookingRoomListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "referenceCode">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    referenceCode?: SortOrder
    guestId?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripePaymentMethodId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    nights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otaId?: SortOrderInput | SortOrder
    otaRawData?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    hotelId?: StringWithAggregatesFilter<"Booking"> | string
    referenceCode?: StringWithAggregatesFilter<"Booking"> | string
    guestId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestName?: StringWithAggregatesFilter<"Booking"> | string
    guestEmail?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestPhone?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: StringWithAggregatesFilter<"Booking"> | string
    source?: StringWithAggregatesFilter<"Booking"> | string
    totalPrice?: DecimalWithAggregatesFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Booking"> | string
    isPaid?: BoolWithAggregatesFilter<"Booking"> | boolean
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    stripePaymentMethodId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    checkInDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    nights?: IntWithAggregatesFilter<"Booking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    otaId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    otaRawData?: StringNullableWithAggregatesFilter<"Booking"> | string | null
  }

  export type BookingRoomWhereInput = {
    AND?: BookingRoomWhereInput | BookingRoomWhereInput[]
    OR?: BookingRoomWhereInput[]
    NOT?: BookingRoomWhereInput | BookingRoomWhereInput[]
    id?: StringFilter<"BookingRoom"> | string
    bookingId?: StringFilter<"BookingRoom"> | string
    roomId?: StringFilter<"BookingRoom"> | string
    priceSnapshot?: DecimalFilter<"BookingRoom"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"BookingRoom"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type BookingRoomOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    roomId?: SortOrder
    priceSnapshot?: SortOrder
    date?: SortOrder
    booking?: BookingOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
  }

  export type BookingRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingRoomWhereInput | BookingRoomWhereInput[]
    OR?: BookingRoomWhereInput[]
    NOT?: BookingRoomWhereInput | BookingRoomWhereInput[]
    bookingId?: StringFilter<"BookingRoom"> | string
    roomId?: StringFilter<"BookingRoom"> | string
    priceSnapshot?: DecimalFilter<"BookingRoom"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"BookingRoom"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type BookingRoomOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    roomId?: SortOrder
    priceSnapshot?: SortOrder
    date?: SortOrder
    _count?: BookingRoomCountOrderByAggregateInput
    _avg?: BookingRoomAvgOrderByAggregateInput
    _max?: BookingRoomMaxOrderByAggregateInput
    _min?: BookingRoomMinOrderByAggregateInput
    _sum?: BookingRoomSumOrderByAggregateInput
  }

  export type BookingRoomScalarWhereWithAggregatesInput = {
    AND?: BookingRoomScalarWhereWithAggregatesInput | BookingRoomScalarWhereWithAggregatesInput[]
    OR?: BookingRoomScalarWhereWithAggregatesInput[]
    NOT?: BookingRoomScalarWhereWithAggregatesInput | BookingRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingRoom"> | string
    bookingId?: StringWithAggregatesFilter<"BookingRoom"> | string
    roomId?: StringWithAggregatesFilter<"BookingRoom"> | string
    priceSnapshot?: DecimalWithAggregatesFilter<"BookingRoom"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"BookingRoom"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    type?: StringFilter<"Channel"> | string
    isEnabled?: BoolFilter<"Channel"> | boolean
    mappings?: ChannelMappingListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isEnabled?: SortOrder
    mappings?: ChannelMappingOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    type?: StringFilter<"Channel"> | string
    isEnabled?: BoolFilter<"Channel"> | boolean
    mappings?: ChannelMappingListRelationFilter
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isEnabled?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    type?: StringWithAggregatesFilter<"Channel"> | string
    isEnabled?: BoolWithAggregatesFilter<"Channel"> | boolean
  }

  export type ChannelMappingWhereInput = {
    AND?: ChannelMappingWhereInput | ChannelMappingWhereInput[]
    OR?: ChannelMappingWhereInput[]
    NOT?: ChannelMappingWhereInput | ChannelMappingWhereInput[]
    id?: StringFilter<"ChannelMapping"> | string
    channelId?: StringFilter<"ChannelMapping"> | string
    roomTypeId?: StringFilter<"ChannelMapping"> | string
    ratePlanId?: StringNullableFilter<"ChannelMapping"> | string | null
    externalId?: StringFilter<"ChannelMapping"> | string
    externalName?: StringNullableFilter<"ChannelMapping"> | string | null
    syncEnabled?: BoolFilter<"ChannelMapping"> | boolean
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    ratePlan?: XOR<RatePlanNullableRelationFilter, RatePlanWhereInput> | null
  }

  export type ChannelMappingOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrderInput | SortOrder
    externalId?: SortOrder
    externalName?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    channel?: ChannelOrderByWithRelationInput
    roomType?: RoomTypeOrderByWithRelationInput
    ratePlan?: RatePlanOrderByWithRelationInput
  }

  export type ChannelMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelMappingWhereInput | ChannelMappingWhereInput[]
    OR?: ChannelMappingWhereInput[]
    NOT?: ChannelMappingWhereInput | ChannelMappingWhereInput[]
    channelId?: StringFilter<"ChannelMapping"> | string
    roomTypeId?: StringFilter<"ChannelMapping"> | string
    ratePlanId?: StringNullableFilter<"ChannelMapping"> | string | null
    externalId?: StringFilter<"ChannelMapping"> | string
    externalName?: StringNullableFilter<"ChannelMapping"> | string | null
    syncEnabled?: BoolFilter<"ChannelMapping"> | boolean
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
    ratePlan?: XOR<RatePlanNullableRelationFilter, RatePlanWhereInput> | null
  }, "id">

  export type ChannelMappingOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrderInput | SortOrder
    externalId?: SortOrder
    externalName?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    _count?: ChannelMappingCountOrderByAggregateInput
    _max?: ChannelMappingMaxOrderByAggregateInput
    _min?: ChannelMappingMinOrderByAggregateInput
  }

  export type ChannelMappingScalarWhereWithAggregatesInput = {
    AND?: ChannelMappingScalarWhereWithAggregatesInput | ChannelMappingScalarWhereWithAggregatesInput[]
    OR?: ChannelMappingScalarWhereWithAggregatesInput[]
    NOT?: ChannelMappingScalarWhereWithAggregatesInput | ChannelMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelMapping"> | string
    channelId?: StringWithAggregatesFilter<"ChannelMapping"> | string
    roomTypeId?: StringWithAggregatesFilter<"ChannelMapping"> | string
    ratePlanId?: StringNullableWithAggregatesFilter<"ChannelMapping"> | string | null
    externalId?: StringWithAggregatesFilter<"ChannelMapping"> | string
    externalName?: StringNullableWithAggregatesFilter<"ChannelMapping"> | string | null
    syncEnabled?: BoolWithAggregatesFilter<"ChannelMapping"> | boolean
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    channel?: StringFilter<"SyncLog"> | string
    action?: StringFilter<"SyncLog"> | string
    status?: StringFilter<"SyncLog"> | string
    details?: StringNullableFilter<"SyncLog"> | string | null
    timestamp?: DateTimeFilter<"SyncLog"> | Date | string
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    channel?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    channel?: StringFilter<"SyncLog"> | string
    action?: StringFilter<"SyncLog"> | string
    status?: StringFilter<"SyncLog"> | string
    details?: StringNullableFilter<"SyncLog"> | string | null
    timestamp?: DateTimeFilter<"SyncLog"> | Date | string
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    channel?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    channel?: StringWithAggregatesFilter<"SyncLog"> | string
    action?: StringWithAggregatesFilter<"SyncLog"> | string
    status?: StringWithAggregatesFilter<"SyncLog"> | string
    details?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    domain?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    actor?: StringFilter<"AuditLog"> | string
    metadata?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    domain?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    actor?: StringFilter<"AuditLog"> | string
    metadata?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    domain?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    actor?: StringWithAggregatesFilter<"AuditLog"> | string
    metadata?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ICalFeedWhereInput = {
    AND?: ICalFeedWhereInput | ICalFeedWhereInput[]
    OR?: ICalFeedWhereInput[]
    NOT?: ICalFeedWhereInput | ICalFeedWhereInput[]
    id?: StringFilter<"ICalFeed"> | string
    roomTypeId?: StringFilter<"ICalFeed"> | string
    url?: StringFilter<"ICalFeed"> | string
    name?: StringNullableFilter<"ICalFeed"> | string | null
    source?: StringFilter<"ICalFeed"> | string
    lastSync?: DateTimeNullableFilter<"ICalFeed"> | Date | string | null
    isActive?: BoolFilter<"ICalFeed"> | boolean
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
  }

  export type ICalFeedOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    source?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    isActive?: SortOrder
    roomType?: RoomTypeOrderByWithRelationInput
  }

  export type ICalFeedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ICalFeedWhereInput | ICalFeedWhereInput[]
    OR?: ICalFeedWhereInput[]
    NOT?: ICalFeedWhereInput | ICalFeedWhereInput[]
    roomTypeId?: StringFilter<"ICalFeed"> | string
    url?: StringFilter<"ICalFeed"> | string
    name?: StringNullableFilter<"ICalFeed"> | string | null
    source?: StringFilter<"ICalFeed"> | string
    lastSync?: DateTimeNullableFilter<"ICalFeed"> | Date | string | null
    isActive?: BoolFilter<"ICalFeed"> | boolean
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
  }, "id">

  export type ICalFeedOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    source?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ICalFeedCountOrderByAggregateInput
    _max?: ICalFeedMaxOrderByAggregateInput
    _min?: ICalFeedMinOrderByAggregateInput
  }

  export type ICalFeedScalarWhereWithAggregatesInput = {
    AND?: ICalFeedScalarWhereWithAggregatesInput | ICalFeedScalarWhereWithAggregatesInput[]
    OR?: ICalFeedScalarWhereWithAggregatesInput[]
    NOT?: ICalFeedScalarWhereWithAggregatesInput | ICalFeedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ICalFeed"> | string
    roomTypeId?: StringWithAggregatesFilter<"ICalFeed"> | string
    url?: StringWithAggregatesFilter<"ICalFeed"> | string
    name?: StringNullableWithAggregatesFilter<"ICalFeed"> | string | null
    source?: StringWithAggregatesFilter<"ICalFeed"> | string
    lastSync?: DateTimeNullableWithAggregatesFilter<"ICalFeed"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ICalFeed"> | boolean
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    gateway?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    gateway?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    gateway?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    hotelId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    hotel?: XOR<HotelNullableRelationFilter, HotelWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    hotel?: HotelOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    hotelId?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    hotel?: XOR<HotelNullableRelationFilter, HotelWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    hotelId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type RestaurantWhereInput = {
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    name?: StringFilter<"Restaurant"> | string
    currency?: StringFilter<"Restaurant"> | string
    zones?: ZoneListRelationFilter
    bookings?: ResBookingListRelationFilter
    waitlist?: RestaurantWaitlistListRelationFilter
  }

  export type RestaurantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    zones?: ZoneOrderByRelationAggregateInput
    bookings?: ResBookingOrderByRelationAggregateInput
    waitlist?: RestaurantWaitlistOrderByRelationAggregateInput
  }

  export type RestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    name?: StringFilter<"Restaurant"> | string
    currency?: StringFilter<"Restaurant"> | string
    zones?: ZoneListRelationFilter
    bookings?: ResBookingListRelationFilter
    waitlist?: RestaurantWaitlistListRelationFilter
  }, "id">

  export type RestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    _count?: RestaurantCountOrderByAggregateInput
    _max?: RestaurantMaxOrderByAggregateInput
    _min?: RestaurantMinOrderByAggregateInput
  }

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    OR?: RestaurantScalarWhereWithAggregatesInput[]
    NOT?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restaurant"> | string
    name?: StringWithAggregatesFilter<"Restaurant"> | string
    currency?: StringWithAggregatesFilter<"Restaurant"> | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    restaurantId?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    index?: IntFilter<"Zone"> | number
    isActive?: BoolFilter<"Zone"> | boolean
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    tables?: TableListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    index?: SortOrder
    isActive?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    tables?: TableOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    restaurantId?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    index?: IntFilter<"Zone"> | number
    isActive?: BoolFilter<"Zone"> | boolean
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    tables?: TableListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    index?: SortOrder
    isActive?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    restaurantId?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    index?: IntWithAggregatesFilter<"Zone"> | number
    isActive?: BoolWithAggregatesFilter<"Zone"> | boolean
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: StringFilter<"Table"> | string
    zoneId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    capacity?: IntFilter<"Table"> | number
    x?: IntFilter<"Table"> | number
    y?: IntFilter<"Table"> | number
    width?: IntFilter<"Table"> | number
    height?: IntFilter<"Table"> | number
    shape?: StringFilter<"Table"> | string
    rotation?: IntFilter<"Table"> | number
    isActive?: BoolFilter<"Table"> | boolean
    minPax?: IntFilter<"Table"> | number
    maxPax?: IntFilter<"Table"> | number
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    resBookings?: ResBookingListRelationFilter
    tableHolds?: TableHoldListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    shape?: SortOrder
    rotation?: SortOrder
    isActive?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    resBookings?: ResBookingOrderByRelationAggregateInput
    tableHolds?: TableHoldOrderByRelationAggregateInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    zoneId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    capacity?: IntFilter<"Table"> | number
    x?: IntFilter<"Table"> | number
    y?: IntFilter<"Table"> | number
    width?: IntFilter<"Table"> | number
    height?: IntFilter<"Table"> | number
    shape?: StringFilter<"Table"> | string
    rotation?: IntFilter<"Table"> | number
    isActive?: BoolFilter<"Table"> | boolean
    minPax?: IntFilter<"Table"> | number
    maxPax?: IntFilter<"Table"> | number
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    resBookings?: ResBookingListRelationFilter
    tableHolds?: TableHoldListRelationFilter
  }, "id">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    shape?: SortOrder
    rotation?: SortOrder
    isActive?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _avg?: TableAvgOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
    _sum?: TableSumOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Table"> | string
    zoneId?: StringWithAggregatesFilter<"Table"> | string
    name?: StringWithAggregatesFilter<"Table"> | string
    capacity?: IntWithAggregatesFilter<"Table"> | number
    x?: IntWithAggregatesFilter<"Table"> | number
    y?: IntWithAggregatesFilter<"Table"> | number
    width?: IntWithAggregatesFilter<"Table"> | number
    height?: IntWithAggregatesFilter<"Table"> | number
    shape?: StringWithAggregatesFilter<"Table"> | string
    rotation?: IntWithAggregatesFilter<"Table"> | number
    isActive?: BoolWithAggregatesFilter<"Table"> | boolean
    minPax?: IntWithAggregatesFilter<"Table"> | number
    maxPax?: IntWithAggregatesFilter<"Table"> | number
  }

  export type ResBookingWhereInput = {
    AND?: ResBookingWhereInput | ResBookingWhereInput[]
    OR?: ResBookingWhereInput[]
    NOT?: ResBookingWhereInput | ResBookingWhereInput[]
    id?: StringFilter<"ResBooking"> | string
    restaurantId?: StringFilter<"ResBooking"> | string
    tableId?: StringNullableFilter<"ResBooking"> | string | null
    guestName?: StringFilter<"ResBooking"> | string
    guestPhone?: StringNullableFilter<"ResBooking"> | string | null
    guestEmail?: StringNullableFilter<"ResBooking"> | string | null
    pax?: IntFilter<"ResBooking"> | number
    date?: DateTimeFilter<"ResBooking"> | Date | string
    duration?: IntFilter<"ResBooking"> | number
    status?: StringFilter<"ResBooking"> | string
    tags?: StringNullableFilter<"ResBooking"> | string | null
    notes?: StringNullableFilter<"ResBooking"> | string | null
    origin?: StringFilter<"ResBooking"> | string
    stripeCustomerId?: StringNullableFilter<"ResBooking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"ResBooking"> | string | null
    smsSent?: BoolFilter<"ResBooking"> | boolean
    emailSent?: BoolFilter<"ResBooking"> | boolean
    createdAt?: DateTimeFilter<"ResBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ResBooking"> | Date | string
    idempotencyKey?: StringNullableFilter<"ResBooking"> | string | null
    channelId?: StringNullableFilter<"ResBooking"> | string | null
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    channel?: XOR<RestaurantChannelNullableRelationFilter, RestaurantChannelWhereInput> | null
  }

  export type ResBookingOrderByWithRelationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestEmail?: SortOrderInput | SortOrder
    pax?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    origin?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripePaymentMethodId?: SortOrderInput | SortOrder
    smsSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    channel?: RestaurantChannelOrderByWithRelationInput
  }

  export type ResBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idempotencyKey?: string
    AND?: ResBookingWhereInput | ResBookingWhereInput[]
    OR?: ResBookingWhereInput[]
    NOT?: ResBookingWhereInput | ResBookingWhereInput[]
    restaurantId?: StringFilter<"ResBooking"> | string
    tableId?: StringNullableFilter<"ResBooking"> | string | null
    guestName?: StringFilter<"ResBooking"> | string
    guestPhone?: StringNullableFilter<"ResBooking"> | string | null
    guestEmail?: StringNullableFilter<"ResBooking"> | string | null
    pax?: IntFilter<"ResBooking"> | number
    date?: DateTimeFilter<"ResBooking"> | Date | string
    duration?: IntFilter<"ResBooking"> | number
    status?: StringFilter<"ResBooking"> | string
    tags?: StringNullableFilter<"ResBooking"> | string | null
    notes?: StringNullableFilter<"ResBooking"> | string | null
    origin?: StringFilter<"ResBooking"> | string
    stripeCustomerId?: StringNullableFilter<"ResBooking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"ResBooking"> | string | null
    smsSent?: BoolFilter<"ResBooking"> | boolean
    emailSent?: BoolFilter<"ResBooking"> | boolean
    createdAt?: DateTimeFilter<"ResBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ResBooking"> | Date | string
    channelId?: StringNullableFilter<"ResBooking"> | string | null
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    channel?: XOR<RestaurantChannelNullableRelationFilter, RestaurantChannelWhereInput> | null
  }, "id" | "idempotencyKey">

  export type ResBookingOrderByWithAggregationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestEmail?: SortOrderInput | SortOrder
    pax?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    tags?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    origin?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripePaymentMethodId?: SortOrderInput | SortOrder
    smsSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    _count?: ResBookingCountOrderByAggregateInput
    _avg?: ResBookingAvgOrderByAggregateInput
    _max?: ResBookingMaxOrderByAggregateInput
    _min?: ResBookingMinOrderByAggregateInput
    _sum?: ResBookingSumOrderByAggregateInput
  }

  export type ResBookingScalarWhereWithAggregatesInput = {
    AND?: ResBookingScalarWhereWithAggregatesInput | ResBookingScalarWhereWithAggregatesInput[]
    OR?: ResBookingScalarWhereWithAggregatesInput[]
    NOT?: ResBookingScalarWhereWithAggregatesInput | ResBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResBooking"> | string
    restaurantId?: StringWithAggregatesFilter<"ResBooking"> | string
    tableId?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    guestName?: StringWithAggregatesFilter<"ResBooking"> | string
    guestPhone?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    guestEmail?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    pax?: IntWithAggregatesFilter<"ResBooking"> | number
    date?: DateTimeWithAggregatesFilter<"ResBooking"> | Date | string
    duration?: IntWithAggregatesFilter<"ResBooking"> | number
    status?: StringWithAggregatesFilter<"ResBooking"> | string
    tags?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    origin?: StringWithAggregatesFilter<"ResBooking"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    stripePaymentMethodId?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    smsSent?: BoolWithAggregatesFilter<"ResBooking"> | boolean
    emailSent?: BoolWithAggregatesFilter<"ResBooking"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ResBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResBooking"> | Date | string
    idempotencyKey?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"ResBooking"> | string | null
  }

  export type RestaurantChannelWhereInput = {
    AND?: RestaurantChannelWhereInput | RestaurantChannelWhereInput[]
    OR?: RestaurantChannelWhereInput[]
    NOT?: RestaurantChannelWhereInput | RestaurantChannelWhereInput[]
    id?: StringFilter<"RestaurantChannel"> | string
    name?: StringFilter<"RestaurantChannel"> | string
    commission?: DecimalFilter<"RestaurantChannel"> | Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingListRelationFilter
  }

  export type RestaurantChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    commission?: SortOrder
    resBookings?: ResBookingOrderByRelationAggregateInput
  }

  export type RestaurantChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantChannelWhereInput | RestaurantChannelWhereInput[]
    OR?: RestaurantChannelWhereInput[]
    NOT?: RestaurantChannelWhereInput | RestaurantChannelWhereInput[]
    name?: StringFilter<"RestaurantChannel"> | string
    commission?: DecimalFilter<"RestaurantChannel"> | Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingListRelationFilter
  }, "id">

  export type RestaurantChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    commission?: SortOrder
    _count?: RestaurantChannelCountOrderByAggregateInput
    _avg?: RestaurantChannelAvgOrderByAggregateInput
    _max?: RestaurantChannelMaxOrderByAggregateInput
    _min?: RestaurantChannelMinOrderByAggregateInput
    _sum?: RestaurantChannelSumOrderByAggregateInput
  }

  export type RestaurantChannelScalarWhereWithAggregatesInput = {
    AND?: RestaurantChannelScalarWhereWithAggregatesInput | RestaurantChannelScalarWhereWithAggregatesInput[]
    OR?: RestaurantChannelScalarWhereWithAggregatesInput[]
    NOT?: RestaurantChannelScalarWhereWithAggregatesInput | RestaurantChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantChannel"> | string
    name?: StringWithAggregatesFilter<"RestaurantChannel"> | string
    commission?: DecimalWithAggregatesFilter<"RestaurantChannel"> | Decimal | DecimalJsLike | number | string
  }

  export type ResPolicyWhereInput = {
    AND?: ResPolicyWhereInput | ResPolicyWhereInput[]
    OR?: ResPolicyWhereInput[]
    NOT?: ResPolicyWhereInput | ResPolicyWhereInput[]
    id?: StringFilter<"ResPolicy"> | string
    name?: StringFilter<"ResPolicy"> | string
    cancelHours?: IntFilter<"ResPolicy"> | number
    noShowFee?: DecimalFilter<"ResPolicy"> | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFilter<"ResPolicy"> | boolean
    isActive?: BoolFilter<"ResPolicy"> | boolean
  }

  export type ResPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cancelHours?: SortOrder
    noShowFee?: SortOrder
    requireCreditCard?: SortOrder
    isActive?: SortOrder
  }

  export type ResPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResPolicyWhereInput | ResPolicyWhereInput[]
    OR?: ResPolicyWhereInput[]
    NOT?: ResPolicyWhereInput | ResPolicyWhereInput[]
    name?: StringFilter<"ResPolicy"> | string
    cancelHours?: IntFilter<"ResPolicy"> | number
    noShowFee?: DecimalFilter<"ResPolicy"> | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFilter<"ResPolicy"> | boolean
    isActive?: BoolFilter<"ResPolicy"> | boolean
  }, "id">

  export type ResPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cancelHours?: SortOrder
    noShowFee?: SortOrder
    requireCreditCard?: SortOrder
    isActive?: SortOrder
    _count?: ResPolicyCountOrderByAggregateInput
    _avg?: ResPolicyAvgOrderByAggregateInput
    _max?: ResPolicyMaxOrderByAggregateInput
    _min?: ResPolicyMinOrderByAggregateInput
    _sum?: ResPolicySumOrderByAggregateInput
  }

  export type ResPolicyScalarWhereWithAggregatesInput = {
    AND?: ResPolicyScalarWhereWithAggregatesInput | ResPolicyScalarWhereWithAggregatesInput[]
    OR?: ResPolicyScalarWhereWithAggregatesInput[]
    NOT?: ResPolicyScalarWhereWithAggregatesInput | ResPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResPolicy"> | string
    name?: StringWithAggregatesFilter<"ResPolicy"> | string
    cancelHours?: IntWithAggregatesFilter<"ResPolicy"> | number
    noShowFee?: DecimalWithAggregatesFilter<"ResPolicy"> | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolWithAggregatesFilter<"ResPolicy"> | boolean
    isActive?: BoolWithAggregatesFilter<"ResPolicy"> | boolean
  }

  export type TableHoldWhereInput = {
    AND?: TableHoldWhereInput | TableHoldWhereInput[]
    OR?: TableHoldWhereInput[]
    NOT?: TableHoldWhereInput | TableHoldWhereInput[]
    id?: StringFilter<"TableHold"> | string
    tableId?: StringFilter<"TableHold"> | string
    token?: StringFilter<"TableHold"> | string
    expiresAt?: DateTimeFilter<"TableHold"> | Date | string
    createdAt?: DateTimeFilter<"TableHold"> | Date | string
    table?: XOR<TableRelationFilter, TableWhereInput>
  }

  export type TableHoldOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    table?: TableOrderByWithRelationInput
  }

  export type TableHoldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TableHoldWhereInput | TableHoldWhereInput[]
    OR?: TableHoldWhereInput[]
    NOT?: TableHoldWhereInput | TableHoldWhereInput[]
    tableId?: StringFilter<"TableHold"> | string
    expiresAt?: DateTimeFilter<"TableHold"> | Date | string
    createdAt?: DateTimeFilter<"TableHold"> | Date | string
    table?: XOR<TableRelationFilter, TableWhereInput>
  }, "id" | "token">

  export type TableHoldOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: TableHoldCountOrderByAggregateInput
    _max?: TableHoldMaxOrderByAggregateInput
    _min?: TableHoldMinOrderByAggregateInput
  }

  export type TableHoldScalarWhereWithAggregatesInput = {
    AND?: TableHoldScalarWhereWithAggregatesInput | TableHoldScalarWhereWithAggregatesInput[]
    OR?: TableHoldScalarWhereWithAggregatesInput[]
    NOT?: TableHoldScalarWhereWithAggregatesInput | TableHoldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TableHold"> | string
    tableId?: StringWithAggregatesFilter<"TableHold"> | string
    token?: StringWithAggregatesFilter<"TableHold"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"TableHold"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TableHold"> | Date | string
  }

  export type RestaurantWaitlistWhereInput = {
    AND?: RestaurantWaitlistWhereInput | RestaurantWaitlistWhereInput[]
    OR?: RestaurantWaitlistWhereInput[]
    NOT?: RestaurantWaitlistWhereInput | RestaurantWaitlistWhereInput[]
    id?: StringFilter<"RestaurantWaitlist"> | string
    restaurantId?: StringFilter<"RestaurantWaitlist"> | string
    name?: StringFilter<"RestaurantWaitlist"> | string
    phone?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    pax?: IntFilter<"RestaurantWaitlist"> | number
    notes?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    status?: StringFilter<"RestaurantWaitlist"> | string
    createdAt?: DateTimeFilter<"RestaurantWaitlist"> | Date | string
    notifiedAt?: DateTimeNullableFilter<"RestaurantWaitlist"> | Date | string | null
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }

  export type RestaurantWaitlistOrderByWithRelationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    pax?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
  }

  export type RestaurantWaitlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWaitlistWhereInput | RestaurantWaitlistWhereInput[]
    OR?: RestaurantWaitlistWhereInput[]
    NOT?: RestaurantWaitlistWhereInput | RestaurantWaitlistWhereInput[]
    restaurantId?: StringFilter<"RestaurantWaitlist"> | string
    name?: StringFilter<"RestaurantWaitlist"> | string
    phone?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    pax?: IntFilter<"RestaurantWaitlist"> | number
    notes?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    status?: StringFilter<"RestaurantWaitlist"> | string
    createdAt?: DateTimeFilter<"RestaurantWaitlist"> | Date | string
    notifiedAt?: DateTimeNullableFilter<"RestaurantWaitlist"> | Date | string | null
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }, "id">

  export type RestaurantWaitlistOrderByWithAggregationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    pax?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    _count?: RestaurantWaitlistCountOrderByAggregateInput
    _avg?: RestaurantWaitlistAvgOrderByAggregateInput
    _max?: RestaurantWaitlistMaxOrderByAggregateInput
    _min?: RestaurantWaitlistMinOrderByAggregateInput
    _sum?: RestaurantWaitlistSumOrderByAggregateInput
  }

  export type RestaurantWaitlistScalarWhereWithAggregatesInput = {
    AND?: RestaurantWaitlistScalarWhereWithAggregatesInput | RestaurantWaitlistScalarWhereWithAggregatesInput[]
    OR?: RestaurantWaitlistScalarWhereWithAggregatesInput[]
    NOT?: RestaurantWaitlistScalarWhereWithAggregatesInput | RestaurantWaitlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RestaurantWaitlist"> | string
    restaurantId?: StringWithAggregatesFilter<"RestaurantWaitlist"> | string
    name?: StringWithAggregatesFilter<"RestaurantWaitlist"> | string
    phone?: StringNullableWithAggregatesFilter<"RestaurantWaitlist"> | string | null
    pax?: IntWithAggregatesFilter<"RestaurantWaitlist"> | number
    notes?: StringNullableWithAggregatesFilter<"RestaurantWaitlist"> | string | null
    status?: StringWithAggregatesFilter<"RestaurantWaitlist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RestaurantWaitlist"> | Date | string
    notifiedAt?: DateTimeNullableWithAggregatesFilter<"RestaurantWaitlist"> | Date | string | null
  }

  export type HotelWaitlistWhereInput = {
    AND?: HotelWaitlistWhereInput | HotelWaitlistWhereInput[]
    OR?: HotelWaitlistWhereInput[]
    NOT?: HotelWaitlistWhereInput | HotelWaitlistWhereInput[]
    id?: StringFilter<"HotelWaitlist"> | string
    hotelId?: StringFilter<"HotelWaitlist"> | string
    roomTypeId?: StringFilter<"HotelWaitlist"> | string
    email?: StringFilter<"HotelWaitlist"> | string
    dateFrom?: DateTimeFilter<"HotelWaitlist"> | Date | string
    dateTo?: DateTimeFilter<"HotelWaitlist"> | Date | string
    requestDate?: DateTimeFilter<"HotelWaitlist"> | Date | string
    fulfilled?: BoolFilter<"HotelWaitlist"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
  }

  export type HotelWaitlistOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    email?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    requestDate?: SortOrder
    fulfilled?: SortOrder
    hotel?: HotelOrderByWithRelationInput
    roomType?: RoomTypeOrderByWithRelationInput
  }

  export type HotelWaitlistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelWaitlistWhereInput | HotelWaitlistWhereInput[]
    OR?: HotelWaitlistWhereInput[]
    NOT?: HotelWaitlistWhereInput | HotelWaitlistWhereInput[]
    hotelId?: StringFilter<"HotelWaitlist"> | string
    roomTypeId?: StringFilter<"HotelWaitlist"> | string
    email?: StringFilter<"HotelWaitlist"> | string
    dateFrom?: DateTimeFilter<"HotelWaitlist"> | Date | string
    dateTo?: DateTimeFilter<"HotelWaitlist"> | Date | string
    requestDate?: DateTimeFilter<"HotelWaitlist"> | Date | string
    fulfilled?: BoolFilter<"HotelWaitlist"> | boolean
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
    roomType?: XOR<RoomTypeRelationFilter, RoomTypeWhereInput>
  }, "id">

  export type HotelWaitlistOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    email?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    requestDate?: SortOrder
    fulfilled?: SortOrder
    _count?: HotelWaitlistCountOrderByAggregateInput
    _max?: HotelWaitlistMaxOrderByAggregateInput
    _min?: HotelWaitlistMinOrderByAggregateInput
  }

  export type HotelWaitlistScalarWhereWithAggregatesInput = {
    AND?: HotelWaitlistScalarWhereWithAggregatesInput | HotelWaitlistScalarWhereWithAggregatesInput[]
    OR?: HotelWaitlistScalarWhereWithAggregatesInput[]
    NOT?: HotelWaitlistScalarWhereWithAggregatesInput | HotelWaitlistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HotelWaitlist"> | string
    hotelId?: StringWithAggregatesFilter<"HotelWaitlist"> | string
    roomTypeId?: StringWithAggregatesFilter<"HotelWaitlist"> | string
    email?: StringWithAggregatesFilter<"HotelWaitlist"> | string
    dateFrom?: DateTimeWithAggregatesFilter<"HotelWaitlist"> | Date | string
    dateTo?: DateTimeWithAggregatesFilter<"HotelWaitlist"> | Date | string
    requestDate?: DateTimeWithAggregatesFilter<"HotelWaitlist"> | Date | string
    fulfilled?: BoolWithAggregatesFilter<"HotelWaitlist"> | boolean
  }

  export type CustomerProfileWhereInput = {
    AND?: CustomerProfileWhereInput | CustomerProfileWhereInput[]
    OR?: CustomerProfileWhereInput[]
    NOT?: CustomerProfileWhereInput | CustomerProfileWhereInput[]
    id?: StringFilter<"CustomerProfile"> | string
    email?: StringNullableFilter<"CustomerProfile"> | string | null
    phone?: StringNullableFilter<"CustomerProfile"> | string | null
    firstName?: StringNullableFilter<"CustomerProfile"> | string | null
    lastName?: StringNullableFilter<"CustomerProfile"> | string | null
    lifecycleStage?: StringFilter<"CustomerProfile"> | string
    totalSpend?: DecimalFilter<"CustomerProfile"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntFilter<"CustomerProfile"> | number
    lastInteraction?: DateTimeNullableFilter<"CustomerProfile"> | Date | string | null
    tags?: StringNullableFilter<"CustomerProfile"> | string | null
    consentEmail?: BoolFilter<"CustomerProfile"> | boolean
    consentWhatsApp?: BoolFilter<"CustomerProfile"> | boolean
    createdAt?: DateTimeFilter<"CustomerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProfile"> | Date | string
    identityLinks?: IdentityLinkListRelationFilter
    webVisits?: WebVisitListRelationFilter
  }

  export type CustomerProfileOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    lifecycleStage?: SortOrder
    totalSpend?: SortOrder
    visitCount?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    consentEmail?: SortOrder
    consentWhatsApp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identityLinks?: IdentityLinkOrderByRelationAggregateInput
    webVisits?: WebVisitOrderByRelationAggregateInput
  }

  export type CustomerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerProfileWhereInput | CustomerProfileWhereInput[]
    OR?: CustomerProfileWhereInput[]
    NOT?: CustomerProfileWhereInput | CustomerProfileWhereInput[]
    phone?: StringNullableFilter<"CustomerProfile"> | string | null
    firstName?: StringNullableFilter<"CustomerProfile"> | string | null
    lastName?: StringNullableFilter<"CustomerProfile"> | string | null
    lifecycleStage?: StringFilter<"CustomerProfile"> | string
    totalSpend?: DecimalFilter<"CustomerProfile"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntFilter<"CustomerProfile"> | number
    lastInteraction?: DateTimeNullableFilter<"CustomerProfile"> | Date | string | null
    tags?: StringNullableFilter<"CustomerProfile"> | string | null
    consentEmail?: BoolFilter<"CustomerProfile"> | boolean
    consentWhatsApp?: BoolFilter<"CustomerProfile"> | boolean
    createdAt?: DateTimeFilter<"CustomerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProfile"> | Date | string
    identityLinks?: IdentityLinkListRelationFilter
    webVisits?: WebVisitListRelationFilter
  }, "id" | "email">

  export type CustomerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    lifecycleStage?: SortOrder
    totalSpend?: SortOrder
    visitCount?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    consentEmail?: SortOrder
    consentWhatsApp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerProfileCountOrderByAggregateInput
    _avg?: CustomerProfileAvgOrderByAggregateInput
    _max?: CustomerProfileMaxOrderByAggregateInput
    _min?: CustomerProfileMinOrderByAggregateInput
    _sum?: CustomerProfileSumOrderByAggregateInput
  }

  export type CustomerProfileScalarWhereWithAggregatesInput = {
    AND?: CustomerProfileScalarWhereWithAggregatesInput | CustomerProfileScalarWhereWithAggregatesInput[]
    OR?: CustomerProfileScalarWhereWithAggregatesInput[]
    NOT?: CustomerProfileScalarWhereWithAggregatesInput | CustomerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerProfile"> | string
    email?: StringNullableWithAggregatesFilter<"CustomerProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CustomerProfile"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"CustomerProfile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"CustomerProfile"> | string | null
    lifecycleStage?: StringWithAggregatesFilter<"CustomerProfile"> | string
    totalSpend?: DecimalWithAggregatesFilter<"CustomerProfile"> | Decimal | DecimalJsLike | number | string
    visitCount?: IntWithAggregatesFilter<"CustomerProfile"> | number
    lastInteraction?: DateTimeNullableWithAggregatesFilter<"CustomerProfile"> | Date | string | null
    tags?: StringNullableWithAggregatesFilter<"CustomerProfile"> | string | null
    consentEmail?: BoolWithAggregatesFilter<"CustomerProfile"> | boolean
    consentWhatsApp?: BoolWithAggregatesFilter<"CustomerProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerProfile"> | Date | string
  }

  export type IdentityLinkWhereInput = {
    AND?: IdentityLinkWhereInput | IdentityLinkWhereInput[]
    OR?: IdentityLinkWhereInput[]
    NOT?: IdentityLinkWhereInput | IdentityLinkWhereInput[]
    id?: StringFilter<"IdentityLink"> | string
    customerProfileId?: StringFilter<"IdentityLink"> | string
    sourceType?: StringFilter<"IdentityLink"> | string
    sourceId?: StringFilter<"IdentityLink"> | string
    mergedAt?: DateTimeFilter<"IdentityLink"> | Date | string
    customerProfile?: XOR<CustomerProfileRelationFilter, CustomerProfileWhereInput>
  }

  export type IdentityLinkOrderByWithRelationInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    mergedAt?: SortOrder
    customerProfile?: CustomerProfileOrderByWithRelationInput
  }

  export type IdentityLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IdentityLinkWhereInput | IdentityLinkWhereInput[]
    OR?: IdentityLinkWhereInput[]
    NOT?: IdentityLinkWhereInput | IdentityLinkWhereInput[]
    customerProfileId?: StringFilter<"IdentityLink"> | string
    sourceType?: StringFilter<"IdentityLink"> | string
    sourceId?: StringFilter<"IdentityLink"> | string
    mergedAt?: DateTimeFilter<"IdentityLink"> | Date | string
    customerProfile?: XOR<CustomerProfileRelationFilter, CustomerProfileWhereInput>
  }, "id">

  export type IdentityLinkOrderByWithAggregationInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    mergedAt?: SortOrder
    _count?: IdentityLinkCountOrderByAggregateInput
    _max?: IdentityLinkMaxOrderByAggregateInput
    _min?: IdentityLinkMinOrderByAggregateInput
  }

  export type IdentityLinkScalarWhereWithAggregatesInput = {
    AND?: IdentityLinkScalarWhereWithAggregatesInput | IdentityLinkScalarWhereWithAggregatesInput[]
    OR?: IdentityLinkScalarWhereWithAggregatesInput[]
    NOT?: IdentityLinkScalarWhereWithAggregatesInput | IdentityLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IdentityLink"> | string
    customerProfileId?: StringWithAggregatesFilter<"IdentityLink"> | string
    sourceType?: StringWithAggregatesFilter<"IdentityLink"> | string
    sourceId?: StringWithAggregatesFilter<"IdentityLink"> | string
    mergedAt?: DateTimeWithAggregatesFilter<"IdentityLink"> | Date | string
  }

  export type WebVisitWhereInput = {
    AND?: WebVisitWhereInput | WebVisitWhereInput[]
    OR?: WebVisitWhereInput[]
    NOT?: WebVisitWhereInput | WebVisitWhereInput[]
    id?: StringFilter<"WebVisit"> | string
    sessionId?: StringFilter<"WebVisit"> | string
    visitorId?: StringNullableFilter<"WebVisit"> | string | null
    customerProfileId?: StringNullableFilter<"WebVisit"> | string | null
    url?: StringFilter<"WebVisit"> | string
    referrer?: StringNullableFilter<"WebVisit"> | string | null
    userAgent?: StringNullableFilter<"WebVisit"> | string | null
    duration?: IntFilter<"WebVisit"> | number
    timestamp?: DateTimeFilter<"WebVisit"> | Date | string
    customerProfile?: XOR<CustomerProfileNullableRelationFilter, CustomerProfileWhereInput> | null
  }

  export type WebVisitOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    customerProfileId?: SortOrderInput | SortOrder
    url?: SortOrder
    referrer?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
    customerProfile?: CustomerProfileOrderByWithRelationInput
  }

  export type WebVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebVisitWhereInput | WebVisitWhereInput[]
    OR?: WebVisitWhereInput[]
    NOT?: WebVisitWhereInput | WebVisitWhereInput[]
    sessionId?: StringFilter<"WebVisit"> | string
    visitorId?: StringNullableFilter<"WebVisit"> | string | null
    customerProfileId?: StringNullableFilter<"WebVisit"> | string | null
    url?: StringFilter<"WebVisit"> | string
    referrer?: StringNullableFilter<"WebVisit"> | string | null
    userAgent?: StringNullableFilter<"WebVisit"> | string | null
    duration?: IntFilter<"WebVisit"> | number
    timestamp?: DateTimeFilter<"WebVisit"> | Date | string
    customerProfile?: XOR<CustomerProfileNullableRelationFilter, CustomerProfileWhereInput> | null
  }, "id">

  export type WebVisitOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    visitorId?: SortOrderInput | SortOrder
    customerProfileId?: SortOrderInput | SortOrder
    url?: SortOrder
    referrer?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
    _count?: WebVisitCountOrderByAggregateInput
    _avg?: WebVisitAvgOrderByAggregateInput
    _max?: WebVisitMaxOrderByAggregateInput
    _min?: WebVisitMinOrderByAggregateInput
    _sum?: WebVisitSumOrderByAggregateInput
  }

  export type WebVisitScalarWhereWithAggregatesInput = {
    AND?: WebVisitScalarWhereWithAggregatesInput | WebVisitScalarWhereWithAggregatesInput[]
    OR?: WebVisitScalarWhereWithAggregatesInput[]
    NOT?: WebVisitScalarWhereWithAggregatesInput | WebVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebVisit"> | string
    sessionId?: StringWithAggregatesFilter<"WebVisit"> | string
    visitorId?: StringNullableWithAggregatesFilter<"WebVisit"> | string | null
    customerProfileId?: StringNullableWithAggregatesFilter<"WebVisit"> | string | null
    url?: StringWithAggregatesFilter<"WebVisit"> | string
    referrer?: StringNullableWithAggregatesFilter<"WebVisit"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"WebVisit"> | string | null
    duration?: IntWithAggregatesFilter<"WebVisit"> | number
    timestamp?: DateTimeWithAggregatesFilter<"WebVisit"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    content?: StringFilter<"Campaign"> | string
    segmentConfig?: StringNullableFilter<"Campaign"> | string | null
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    segmentConfig?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    subject?: StringNullableFilter<"Campaign"> | string | null
    content?: StringFilter<"Campaign"> | string
    segmentConfig?: StringNullableFilter<"Campaign"> | string | null
    sentCount?: IntFilter<"Campaign"> | number
    openCount?: IntFilter<"Campaign"> | number
    clickCount?: IntFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    segmentConfig?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    subject?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    content?: StringWithAggregatesFilter<"Campaign"> | string
    segmentConfig?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    sentCount?: IntWithAggregatesFilter<"Campaign"> | number
    openCount?: IntWithAggregatesFilter<"Campaign"> | number
    clickCount?: IntWithAggregatesFilter<"Campaign"> | number
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    triggerType?: StringFilter<"Workflow"> | string
    triggerConfig?: StringFilter<"Workflow"> | string
    steps?: StringFilter<"Workflow"> | string
    isActive?: BoolFilter<"Workflow"> | boolean
    runCount?: IntFilter<"Workflow"> | number
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    name?: StringFilter<"Workflow"> | string
    triggerType?: StringFilter<"Workflow"> | string
    triggerConfig?: StringFilter<"Workflow"> | string
    steps?: StringFilter<"Workflow"> | string
    isActive?: BoolFilter<"Workflow"> | boolean
    runCount?: IntFilter<"Workflow"> | number
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _avg?: WorkflowAvgOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
    _sum?: WorkflowSumOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    name?: StringWithAggregatesFilter<"Workflow"> | string
    triggerType?: StringWithAggregatesFilter<"Workflow"> | string
    triggerConfig?: StringWithAggregatesFilter<"Workflow"> | string
    steps?: StringWithAggregatesFilter<"Workflow"> | string
    isActive?: BoolWithAggregatesFilter<"Workflow"> | boolean
    runCount?: IntWithAggregatesFilter<"Workflow"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
  }

  export type HotelCreateInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetConfigCreateInput = {
    id?: string
    primaryColor?: string
    secondaryColor?: string
    customCss?: string | null
    showLogo?: boolean
    title?: string | null
    hotel: HotelCreateNestedOneWithoutWidgetConfigInput
  }

  export type WidgetConfigUncheckedCreateInput = {
    id?: string
    hotelId: string
    primaryColor?: string
    secondaryColor?: string
    customCss?: string | null
    showLogo?: boolean
    title?: string | null
  }

  export type WidgetConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneRequiredWithoutWidgetConfigNestedInput
  }

  export type WidgetConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WidgetConfigCreateManyInput = {
    id?: string
    hotelId: string
    primaryColor?: string
    secondaryColor?: string
    customCss?: string | null
    showLogo?: boolean
    title?: string | null
  }

  export type WidgetConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WidgetConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeCreateManyInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    roomType: RoomTypeCreateNestedOneWithoutRoomsInput
    bookingRooms?: BookingRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    roomTypeId: string
    name: string
    isActive?: boolean
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneRequiredWithoutRoomsNestedInput
    bookingRooms?: BookingRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    roomTypeId: string
    name: string
    isActive?: boolean
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuestCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    docType?: string | null
    docNumber?: string | null
    country?: string | null
    notes?: string | null
    score?: number
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    docType?: string | null
    docNumber?: string | null
    country?: string | null
    notes?: string | null
    score?: number
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type GuestCreateManyInput = {
    id?: string
    firstName: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    docType?: string | null
    docNumber?: string | null
    country?: string | null
    notes?: string | null
    score?: number
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatePlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    hotel: HotelCreateNestedOneWithoutRatePlansInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUncheckedCreateInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hotel?: HotelUpdateOneRequiredWithoutRatePlansNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanCreateManyInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
  }

  export type RatePlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RatePlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
    hotel: HotelCreateNestedOneWithoutSeasonsInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: string
    hotelId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
  }

  export type SeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hotel?: HotelUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonCreateManyInput = {
    id?: string
    hotelId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
  }

  export type SeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceCreateInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    roomType: RoomTypeCreateNestedOneWithoutDailyPricesInput
    ratePlan: RatePlanCreateNestedOneWithoutDailyPricesInput
  }

  export type DailyPriceUncheckedCreateInput = {
    id?: string
    roomTypeId: string
    ratePlanId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roomType?: RoomTypeUpdateOneRequiredWithoutDailyPricesNestedInput
    ratePlan?: RatePlanUpdateOneRequiredWithoutDailyPricesNestedInput
  }

  export type DailyPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceCreateManyInput = {
    id?: string
    roomTypeId: string
    ratePlanId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RestrictionCreateInput = {
    id?: string
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    hotel: HotelCreateNestedOneWithoutRestrictionsInput
    roomType?: RoomTypeCreateNestedOneWithoutRestrictionsInput
    ratePlan?: RatePlanCreateNestedOneWithoutRestrictionsInput
  }

  export type RestrictionUncheckedCreateInput = {
    id?: string
    hotelId: string
    roomTypeId?: string | null
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRestrictionsNestedInput
    roomType?: RoomTypeUpdateOneWithoutRestrictionsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutRestrictionsNestedInput
  }

  export type RestrictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestrictionCreateManyInput = {
    id?: string
    hotelId: string
    roomTypeId?: string | null
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestrictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingCreateInput = {
    id?: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    hotel: HotelCreateNestedOneWithoutBookingsInput
    guest?: GuestCreateNestedOneWithoutBookingsInput
    bookingRooms?: BookingRoomCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    guest?: GuestUpdateOneWithoutBookingsNestedInput
    bookingRooms?: BookingRoomUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRoomCreateInput = {
    id?: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
    booking: BookingCreateNestedOneWithoutBookingRoomsInput
    room: RoomCreateNestedOneWithoutBookingRoomsInput
  }

  export type BookingRoomUncheckedCreateInput = {
    id?: string
    bookingId: string
    roomId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type BookingRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBookingRoomsNestedInput
    room?: RoomUpdateOneRequiredWithoutBookingRoomsNestedInput
  }

  export type BookingRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRoomCreateManyInput = {
    id?: string
    bookingId: string
    roomId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type BookingRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id?: string
    name: string
    type: string
    isEnabled?: boolean
    mappings?: ChannelMappingCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    isEnabled?: boolean
    mappings?: ChannelMappingUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    mappings?: ChannelMappingUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    mappings?: ChannelMappingUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    name: string
    type: string
    isEnabled?: boolean
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingCreateInput = {
    id?: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
    channel: ChannelCreateNestedOneWithoutMappingsInput
    roomType: RoomTypeCreateNestedOneWithoutChannelMappingsInput
    ratePlan?: RatePlanCreateNestedOneWithoutChannelMappingsInput
  }

  export type ChannelMappingUncheckedCreateInput = {
    id?: string
    channelId: string
    roomTypeId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    channel?: ChannelUpdateOneRequiredWithoutMappingsNestedInput
    roomType?: RoomTypeUpdateOneRequiredWithoutChannelMappingsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutChannelMappingsNestedInput
  }

  export type ChannelMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingCreateManyInput = {
    id?: string
    channelId: string
    roomTypeId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SyncLogCreateInput = {
    id?: string
    channel: string
    action: string
    status: string
    details?: string | null
    timestamp?: Date | string
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    channel: string
    action: string
    status: string
    details?: string | null
    timestamp?: Date | string
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateManyInput = {
    id?: string
    channel: string
    action: string
    status: string
    details?: string | null
    timestamp?: Date | string
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    domain: string
    entity: string
    entityId: string
    action: string
    actor: string
    metadata?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    domain: string
    entity: string
    entityId: string
    action: string
    actor: string
    metadata?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    domain: string
    entity: string
    entityId: string
    action: string
    actor: string
    metadata?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actor?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ICalFeedCreateInput = {
    id?: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
    roomType: RoomTypeCreateNestedOneWithoutIcalFeedsInput
  }

  export type ICalFeedUncheckedCreateInput = {
    id?: string
    roomTypeId: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
  }

  export type ICalFeedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneRequiredWithoutIcalFeedsNestedInput
  }

  export type ICalFeedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICalFeedCreateManyInput = {
    id?: string
    roomTypeId: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
  }

  export type ICalFeedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICalFeedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role?: string
    hotel?: HotelCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    hotelId?: string | null
    email: string
    password: string
    role?: string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    hotel?: HotelUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id?: string
    hotelId?: string | null
    email: string
    password: string
    role?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RestaurantCreateInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneCreateNestedManyWithoutRestaurantInput
    bookings?: ResBookingCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutRestaurantInput
    bookings?: ResBookingUncheckedCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUpdateManyWithoutRestaurantNestedInput
    bookings?: ResBookingUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutRestaurantNestedInput
    bookings?: ResBookingUncheckedUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantCreateManyInput = {
    id?: string
    name: string
    currency?: string
  }

  export type RestaurantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type RestaurantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ZoneCreateInput = {
    id?: string
    name: string
    index?: number
    isActive?: boolean
    restaurant: RestaurantCreateNestedOneWithoutZonesInput
    tables?: TableCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    restaurantId: string
    name: string
    index?: number
    isActive?: boolean
    tables?: TableUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutZonesNestedInput
    tables?: TableUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tables?: TableUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    restaurantId: string
    name: string
    index?: number
    isActive?: boolean
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TableCreateInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    zone: ZoneCreateNestedOneWithoutTablesInput
    resBookings?: ResBookingCreateNestedManyWithoutTableInput
    tableHolds?: TableHoldCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: string
    zoneId: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    resBookings?: ResBookingUncheckedCreateNestedManyWithoutTableInput
    tableHolds?: TableHoldUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    zone?: ZoneUpdateOneRequiredWithoutTablesNestedInput
    resBookings?: ResBookingUpdateManyWithoutTableNestedInput
    tableHolds?: TableHoldUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    resBookings?: ResBookingUncheckedUpdateManyWithoutTableNestedInput
    tableHolds?: TableHoldUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: string
    zoneId: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
  }

  export type TableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
  }

  export type TableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
  }

  export type ResBookingCreateInput = {
    id?: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    restaurant: RestaurantCreateNestedOneWithoutBookingsInput
    table?: TableCreateNestedOneWithoutResBookingsInput
    channel?: RestaurantChannelCreateNestedOneWithoutResBookingsInput
  }

  export type ResBookingUncheckedCreateInput = {
    id?: string
    restaurantId: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type ResBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: RestaurantUpdateOneRequiredWithoutBookingsNestedInput
    table?: TableUpdateOneWithoutResBookingsNestedInput
    channel?: RestaurantChannelUpdateOneWithoutResBookingsNestedInput
  }

  export type ResBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResBookingCreateManyInput = {
    id?: string
    restaurantId: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type ResBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantChannelCreateInput = {
    id?: string
    name: string
    commission?: Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingCreateNestedManyWithoutChannelInput
  }

  export type RestaurantChannelUncheckedCreateInput = {
    id?: string
    name: string
    commission?: Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingUncheckedCreateNestedManyWithoutChannelInput
  }

  export type RestaurantChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingUpdateManyWithoutChannelNestedInput
  }

  export type RestaurantChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resBookings?: ResBookingUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type RestaurantChannelCreateManyInput = {
    id?: string
    name: string
    commission?: Decimal | DecimalJsLike | number | string
  }

  export type RestaurantChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RestaurantChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResPolicyCreateInput = {
    id?: string
    name: string
    cancelHours: number
    noShowFee?: Decimal | DecimalJsLike | number | string
    requireCreditCard?: boolean
    isActive?: boolean
  }

  export type ResPolicyUncheckedCreateInput = {
    id?: string
    name: string
    cancelHours: number
    noShowFee?: Decimal | DecimalJsLike | number | string
    requireCreditCard?: boolean
    isActive?: boolean
  }

  export type ResPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cancelHours?: IntFieldUpdateOperationsInput | number
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cancelHours?: IntFieldUpdateOperationsInput | number
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResPolicyCreateManyInput = {
    id?: string
    name: string
    cancelHours: number
    noShowFee?: Decimal | DecimalJsLike | number | string
    requireCreditCard?: boolean
    isActive?: boolean
  }

  export type ResPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cancelHours?: IntFieldUpdateOperationsInput | number
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cancelHours?: IntFieldUpdateOperationsInput | number
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TableHoldCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    table: TableCreateNestedOneWithoutTableHoldsInput
  }

  export type TableHoldUncheckedCreateInput = {
    id?: string
    tableId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type TableHoldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: TableUpdateOneRequiredWithoutTableHoldsNestedInput
  }

  export type TableHoldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableHoldCreateManyInput = {
    id?: string
    tableId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type TableHoldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableHoldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantWaitlistCreateInput = {
    id?: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
    restaurant: RestaurantCreateNestedOneWithoutWaitlistInput
  }

  export type RestaurantWaitlistUncheckedCreateInput = {
    id?: string
    restaurantId: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
  }

  export type RestaurantWaitlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restaurant?: RestaurantUpdateOneRequiredWithoutWaitlistNestedInput
  }

  export type RestaurantWaitlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantWaitlistCreateManyInput = {
    id?: string
    restaurantId: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
  }

  export type RestaurantWaitlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantWaitlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HotelWaitlistCreateInput = {
    id?: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
    hotel: HotelCreateNestedOneWithoutWaitlistEntriesInput
    roomType: RoomTypeCreateNestedOneWithoutWaitlistEntriesInput
  }

  export type HotelWaitlistUncheckedCreateInput = {
    id?: string
    hotelId: string
    roomTypeId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type HotelWaitlistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutWaitlistEntriesNestedInput
    roomType?: RoomTypeUpdateOneRequiredWithoutWaitlistEntriesNestedInput
  }

  export type HotelWaitlistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistCreateManyInput = {
    id?: string
    hotelId: string
    roomTypeId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type HotelWaitlistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerProfileCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    identityLinks?: IdentityLinkCreateNestedManyWithoutCustomerProfileInput
    webVisits?: WebVisitCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileUncheckedCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    identityLinks?: IdentityLinkUncheckedCreateNestedManyWithoutCustomerProfileInput
    webVisits?: WebVisitUncheckedCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identityLinks?: IdentityLinkUpdateManyWithoutCustomerProfileNestedInput
    webVisits?: WebVisitUpdateManyWithoutCustomerProfileNestedInput
  }

  export type CustomerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identityLinks?: IdentityLinkUncheckedUpdateManyWithoutCustomerProfileNestedInput
    webVisits?: WebVisitUncheckedUpdateManyWithoutCustomerProfileNestedInput
  }

  export type CustomerProfileCreateManyInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityLinkCreateInput = {
    id?: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
    customerProfile: CustomerProfileCreateNestedOneWithoutIdentityLinksInput
  }

  export type IdentityLinkUncheckedCreateInput = {
    id?: string
    customerProfileId: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
  }

  export type IdentityLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProfile?: CustomerProfileUpdateOneRequiredWithoutIdentityLinksNestedInput
  }

  export type IdentityLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityLinkCreateManyInput = {
    id?: string
    customerProfileId: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
  }

  export type IdentityLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProfileId?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitCreateInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
    customerProfile?: CustomerProfileCreateNestedOneWithoutWebVisitsInput
  }

  export type WebVisitUncheckedCreateInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    customerProfileId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
  }

  export type WebVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProfile?: CustomerProfileUpdateOneWithoutWebVisitsNestedInput
  }

  export type WebVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitCreateManyInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    customerProfileId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
  }

  export type WebVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    customerProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    type: string
    status: string
    subject?: string | null
    content: string
    segmentConfig?: string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    status: string
    subject?: string | null
    content: string
    segmentConfig?: string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    segmentConfig?: NullableStringFieldUpdateOperationsInput | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    segmentConfig?: NullableStringFieldUpdateOperationsInput | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    type: string
    status: string
    subject?: string | null
    content: string
    segmentConfig?: string | null
    sentCount?: number
    openCount?: number
    clickCount?: number
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    segmentConfig?: NullableStringFieldUpdateOperationsInput | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    segmentConfig?: NullableStringFieldUpdateOperationsInput | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig: string
    steps: string
    isActive?: boolean
    runCount?: number
    createdAt?: Date | string
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig: string
    steps: string
    isActive?: boolean
    runCount?: number
    createdAt?: Date | string
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: StringFieldUpdateOperationsInput | string
    steps?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: StringFieldUpdateOperationsInput | string
    steps?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowCreateManyInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig: string
    steps: string
    isActive?: boolean
    runCount?: number
    createdAt?: Date | string
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: StringFieldUpdateOperationsInput | string
    steps?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: StringFieldUpdateOperationsInput | string
    steps?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    runCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoomTypeListRelationFilter = {
    every?: RoomTypeWhereInput
    some?: RoomTypeWhereInput
    none?: RoomTypeWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type RatePlanListRelationFilter = {
    every?: RatePlanWhereInput
    some?: RatePlanWhereInput
    none?: RatePlanWhereInput
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type WidgetConfigNullableRelationFilter = {
    is?: WidgetConfigWhereInput | null
    isNot?: WidgetConfigWhereInput | null
  }

  export type RestrictionListRelationFilter = {
    every?: RestrictionWhereInput
    some?: RestrictionWhereInput
    none?: RestrictionWhereInput
  }

  export type HotelWaitlistListRelationFilter = {
    every?: HotelWaitlistWhereInput
    some?: HotelWaitlistWhereInput
    none?: HotelWaitlistWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoomTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatePlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestrictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelWaitlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    timezone?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    timezone?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    timezone?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type HotelRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type WidgetConfigCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    customCss?: SortOrder
    showLogo?: SortOrder
    title?: SortOrder
  }

  export type WidgetConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    customCss?: SortOrder
    showLogo?: SortOrder
    title?: SortOrder
  }

  export type WidgetConfigMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    customCss?: SortOrder
    showLogo?: SortOrder
    title?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type ICalFeedListRelationFilter = {
    every?: ICalFeedWhereInput
    some?: ICalFeedWhereInput
    none?: ICalFeedWhereInput
  }

  export type DailyPriceListRelationFilter = {
    every?: DailyPriceWhereInput
    some?: DailyPriceWhereInput
    none?: DailyPriceWhereInput
  }

  export type ChannelMappingListRelationFilter = {
    every?: ChannelMappingWhereInput
    some?: ChannelMappingWhereInput
    none?: ChannelMappingWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ICalFeedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomTypeCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    capacity?: SortOrder
  }

  export type RoomTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    basePrice?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeSumOrderByAggregateInput = {
    basePrice?: SortOrder
    capacity?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RoomTypeRelationFilter = {
    is?: RoomTypeWhereInput
    isNot?: RoomTypeWhereInput
  }

  export type BookingRoomListRelationFilter = {
    every?: BookingRoomWhereInput
    some?: BookingRoomWhereInput
    none?: BookingRoomWhereInput
  }

  export type BookingRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type GuestCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type GuestMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    docType?: SortOrder
    docNumber?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    score?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuestSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type RatePlanCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    cancellationPolicy?: SortOrder
    mealsIncluded?: SortOrder
    requireCreditCard?: SortOrder
    noShowFee?: SortOrder
  }

  export type RatePlanAvgOrderByAggregateInput = {
    noShowFee?: SortOrder
  }

  export type RatePlanMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    cancellationPolicy?: SortOrder
    mealsIncluded?: SortOrder
    requireCreditCard?: SortOrder
    noShowFee?: SortOrder
  }

  export type RatePlanMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    cancellationPolicy?: SortOrder
    mealsIncluded?: SortOrder
    requireCreditCard?: SortOrder
    noShowFee?: SortOrder
  }

  export type RatePlanSumOrderByAggregateInput = {
    noShowFee?: SortOrder
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priceMultiplier?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    priceMultiplier?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priceMultiplier?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priceMultiplier?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    priceMultiplier?: SortOrder
  }

  export type RatePlanRelationFilter = {
    is?: RatePlanWhereInput
    isNot?: RatePlanWhereInput
  }

  export type DailyPriceRoomTypeIdRatePlanIdDateCompoundUniqueInput = {
    roomTypeId: string
    ratePlanId: string
    date: Date | string
  }

  export type DailyPriceCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    price?: SortOrder
  }

  export type DailyPriceAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DailyPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    price?: SortOrder
  }

  export type DailyPriceMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    price?: SortOrder
  }

  export type DailyPriceSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RoomTypeNullableRelationFilter = {
    is?: RoomTypeWhereInput | null
    isNot?: RoomTypeWhereInput | null
  }

  export type RatePlanNullableRelationFilter = {
    is?: RatePlanWhereInput | null
    isNot?: RatePlanWhereInput | null
  }

  export type RestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    closedToArrival?: SortOrder
    closedToDeparture?: SortOrder
    stopSell?: SortOrder
  }

  export type RestrictionAvgOrderByAggregateInput = {
    minStay?: SortOrder
    maxStay?: SortOrder
  }

  export type RestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    closedToArrival?: SortOrder
    closedToDeparture?: SortOrder
    stopSell?: SortOrder
  }

  export type RestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    date?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    closedToArrival?: SortOrder
    closedToDeparture?: SortOrder
    stopSell?: SortOrder
  }

  export type RestrictionSumOrderByAggregateInput = {
    minStay?: SortOrder
    maxStay?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GuestNullableRelationFilter = {
    is?: GuestWhereInput | null
    isNot?: GuestWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    referenceCode?: SortOrder
    guestId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    stripePaymentIntentId?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    nights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otaId?: SortOrder
    otaRawData?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    nights?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    referenceCode?: SortOrder
    guestId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    stripePaymentIntentId?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    nights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otaId?: SortOrder
    otaRawData?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    referenceCode?: SortOrder
    guestId?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    status?: SortOrder
    source?: SortOrder
    totalPrice?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    stripePaymentIntentId?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    nights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otaId?: SortOrder
    otaRawData?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    nights?: SortOrder
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type BookingRoomCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    roomId?: SortOrder
    priceSnapshot?: SortOrder
    date?: SortOrder
  }

  export type BookingRoomAvgOrderByAggregateInput = {
    priceSnapshot?: SortOrder
  }

  export type BookingRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    roomId?: SortOrder
    priceSnapshot?: SortOrder
    date?: SortOrder
  }

  export type BookingRoomMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    roomId?: SortOrder
    priceSnapshot?: SortOrder
    date?: SortOrder
  }

  export type BookingRoomSumOrderByAggregateInput = {
    priceSnapshot?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isEnabled?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isEnabled?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isEnabled?: SortOrder
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type ChannelMappingCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    externalId?: SortOrder
    externalName?: SortOrder
    syncEnabled?: SortOrder
  }

  export type ChannelMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    externalId?: SortOrder
    externalName?: SortOrder
    syncEnabled?: SortOrder
  }

  export type ChannelMappingMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    roomTypeId?: SortOrder
    ratePlanId?: SortOrder
    externalId?: SortOrder
    externalName?: SortOrder
    syncEnabled?: SortOrder
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    channel?: SortOrder
    action?: SortOrder
    status?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actor?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ICalFeedCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    source?: SortOrder
    lastSync?: SortOrder
    isActive?: SortOrder
  }

  export type ICalFeedMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    source?: SortOrder
    lastSync?: SortOrder
    isActive?: SortOrder
  }

  export type ICalFeedMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    url?: SortOrder
    name?: SortOrder
    source?: SortOrder
    lastSync?: SortOrder
    isActive?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    gateway?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type HotelNullableRelationFilter = {
    is?: HotelWhereInput | null
    isNot?: HotelWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type ResBookingListRelationFilter = {
    every?: ResBookingWhereInput
    some?: ResBookingWhereInput
    none?: ResBookingWhereInput
  }

  export type RestaurantWaitlistListRelationFilter = {
    every?: RestaurantWaitlistWhereInput
    some?: RestaurantWaitlistWhereInput
    none?: RestaurantWaitlistWhereInput
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantWaitlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
  }

  export type RestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
  }

  export type RestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
  }

  export type RestaurantRelationFilter = {
    is?: RestaurantWhereInput
    isNot?: RestaurantWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    index?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    index?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    index?: SortOrder
    isActive?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type ZoneRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type TableHoldListRelationFilter = {
    every?: TableHoldWhereInput
    some?: TableHoldWhereInput
    none?: TableHoldWhereInput
  }

  export type TableHoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    shape?: SortOrder
    rotation?: SortOrder
    isActive?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
  }

  export type TableAvgOrderByAggregateInput = {
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    shape?: SortOrder
    rotation?: SortOrder
    isActive?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    shape?: SortOrder
    rotation?: SortOrder
    isActive?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
  }

  export type TableSumOrderByAggregateInput = {
    capacity?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    minPax?: SortOrder
    maxPax?: SortOrder
  }

  export type TableNullableRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type RestaurantChannelNullableRelationFilter = {
    is?: RestaurantChannelWhereInput | null
    isNot?: RestaurantChannelWhereInput | null
  }

  export type ResBookingCountOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    tableId?: SortOrder
    guestName?: SortOrder
    guestPhone?: SortOrder
    guestEmail?: SortOrder
    pax?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    origin?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    smsSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idempotencyKey?: SortOrder
    channelId?: SortOrder
  }

  export type ResBookingAvgOrderByAggregateInput = {
    pax?: SortOrder
    duration?: SortOrder
  }

  export type ResBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    tableId?: SortOrder
    guestName?: SortOrder
    guestPhone?: SortOrder
    guestEmail?: SortOrder
    pax?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    origin?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    smsSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idempotencyKey?: SortOrder
    channelId?: SortOrder
  }

  export type ResBookingMinOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    tableId?: SortOrder
    guestName?: SortOrder
    guestPhone?: SortOrder
    guestEmail?: SortOrder
    pax?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    origin?: SortOrder
    stripeCustomerId?: SortOrder
    stripePaymentMethodId?: SortOrder
    smsSent?: SortOrder
    emailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idempotencyKey?: SortOrder
    channelId?: SortOrder
  }

  export type ResBookingSumOrderByAggregateInput = {
    pax?: SortOrder
    duration?: SortOrder
  }

  export type RestaurantChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    commission?: SortOrder
  }

  export type RestaurantChannelAvgOrderByAggregateInput = {
    commission?: SortOrder
  }

  export type RestaurantChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    commission?: SortOrder
  }

  export type RestaurantChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    commission?: SortOrder
  }

  export type RestaurantChannelSumOrderByAggregateInput = {
    commission?: SortOrder
  }

  export type ResPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cancelHours?: SortOrder
    noShowFee?: SortOrder
    requireCreditCard?: SortOrder
    isActive?: SortOrder
  }

  export type ResPolicyAvgOrderByAggregateInput = {
    cancelHours?: SortOrder
    noShowFee?: SortOrder
  }

  export type ResPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cancelHours?: SortOrder
    noShowFee?: SortOrder
    requireCreditCard?: SortOrder
    isActive?: SortOrder
  }

  export type ResPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cancelHours?: SortOrder
    noShowFee?: SortOrder
    requireCreditCard?: SortOrder
    isActive?: SortOrder
  }

  export type ResPolicySumOrderByAggregateInput = {
    cancelHours?: SortOrder
    noShowFee?: SortOrder
  }

  export type TableRelationFilter = {
    is?: TableWhereInput
    isNot?: TableWhereInput
  }

  export type TableHoldCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TableHoldMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TableHoldMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RestaurantWaitlistCountOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pax?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RestaurantWaitlistAvgOrderByAggregateInput = {
    pax?: SortOrder
  }

  export type RestaurantWaitlistMaxOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pax?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RestaurantWaitlistMinOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    pax?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    notifiedAt?: SortOrder
  }

  export type RestaurantWaitlistSumOrderByAggregateInput = {
    pax?: SortOrder
  }

  export type HotelWaitlistCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    email?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    requestDate?: SortOrder
    fulfilled?: SortOrder
  }

  export type HotelWaitlistMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    email?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    requestDate?: SortOrder
    fulfilled?: SortOrder
  }

  export type HotelWaitlistMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    email?: SortOrder
    dateFrom?: SortOrder
    dateTo?: SortOrder
    requestDate?: SortOrder
    fulfilled?: SortOrder
  }

  export type IdentityLinkListRelationFilter = {
    every?: IdentityLinkWhereInput
    some?: IdentityLinkWhereInput
    none?: IdentityLinkWhereInput
  }

  export type WebVisitListRelationFilter = {
    every?: WebVisitWhereInput
    some?: WebVisitWhereInput
    none?: WebVisitWhereInput
  }

  export type IdentityLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lifecycleStage?: SortOrder
    totalSpend?: SortOrder
    visitCount?: SortOrder
    lastInteraction?: SortOrder
    tags?: SortOrder
    consentEmail?: SortOrder
    consentWhatsApp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProfileAvgOrderByAggregateInput = {
    totalSpend?: SortOrder
    visitCount?: SortOrder
  }

  export type CustomerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lifecycleStage?: SortOrder
    totalSpend?: SortOrder
    visitCount?: SortOrder
    lastInteraction?: SortOrder
    tags?: SortOrder
    consentEmail?: SortOrder
    consentWhatsApp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lifecycleStage?: SortOrder
    totalSpend?: SortOrder
    visitCount?: SortOrder
    lastInteraction?: SortOrder
    tags?: SortOrder
    consentEmail?: SortOrder
    consentWhatsApp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProfileSumOrderByAggregateInput = {
    totalSpend?: SortOrder
    visitCount?: SortOrder
  }

  export type CustomerProfileRelationFilter = {
    is?: CustomerProfileWhereInput
    isNot?: CustomerProfileWhereInput
  }

  export type IdentityLinkCountOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    mergedAt?: SortOrder
  }

  export type IdentityLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    mergedAt?: SortOrder
  }

  export type IdentityLinkMinOrderByAggregateInput = {
    id?: SortOrder
    customerProfileId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    mergedAt?: SortOrder
  }

  export type CustomerProfileNullableRelationFilter = {
    is?: CustomerProfileWhereInput | null
    isNot?: CustomerProfileWhereInput | null
  }

  export type WebVisitCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    visitorId?: SortOrder
    customerProfileId?: SortOrder
    url?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type WebVisitAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type WebVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    visitorId?: SortOrder
    customerProfileId?: SortOrder
    url?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type WebVisitMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    visitorId?: SortOrder
    customerProfileId?: SortOrder
    url?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    duration?: SortOrder
    timestamp?: SortOrder
  }

  export type WebVisitSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    segmentConfig?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    segmentConfig?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    segmentConfig?: SortOrder
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    sentCount?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowAvgOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    steps?: SortOrder
    isActive?: SortOrder
    runCount?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkflowSumOrderByAggregateInput = {
    runCount?: SortOrder
  }

  export type RoomTypeCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutHotelInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type RatePlanCreateNestedManyWithoutHotelInput = {
    create?: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput> | RatePlanCreateWithoutHotelInput[] | RatePlanUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RatePlanCreateOrConnectWithoutHotelInput | RatePlanCreateOrConnectWithoutHotelInput[]
    createMany?: RatePlanCreateManyHotelInputEnvelope
    connect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
  }

  export type SeasonCreateNestedManyWithoutHotelInput = {
    create?: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput> | SeasonCreateWithoutHotelInput[] | SeasonUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutHotelInput | SeasonCreateOrConnectWithoutHotelInput[]
    createMany?: SeasonCreateManyHotelInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutHotelInput = {
    create?: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput> | UserCreateWithoutHotelInput[] | UserUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHotelInput | UserCreateOrConnectWithoutHotelInput[]
    createMany?: UserCreateManyHotelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WidgetConfigCreateNestedOneWithoutHotelInput = {
    create?: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
    connectOrCreate?: WidgetConfigCreateOrConnectWithoutHotelInput
    connect?: WidgetConfigWhereUniqueInput
  }

  export type RestrictionCreateNestedManyWithoutHotelInput = {
    create?: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput> | RestrictionCreateWithoutHotelInput[] | RestrictionUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutHotelInput | RestrictionCreateOrConnectWithoutHotelInput[]
    createMany?: RestrictionCreateManyHotelInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type HotelWaitlistCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput> | HotelWaitlistCreateWithoutHotelInput[] | HotelWaitlistUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutHotelInput | HotelWaitlistCreateOrConnectWithoutHotelInput[]
    createMany?: HotelWaitlistCreateManyHotelInputEnvelope
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
  }

  export type RoomTypeUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type RatePlanUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput> | RatePlanCreateWithoutHotelInput[] | RatePlanUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RatePlanCreateOrConnectWithoutHotelInput | RatePlanCreateOrConnectWithoutHotelInput[]
    createMany?: RatePlanCreateManyHotelInputEnvelope
    connect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput> | SeasonCreateWithoutHotelInput[] | SeasonUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutHotelInput | SeasonCreateOrConnectWithoutHotelInput[]
    createMany?: SeasonCreateManyHotelInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput> | UserCreateWithoutHotelInput[] | UserUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHotelInput | UserCreateOrConnectWithoutHotelInput[]
    createMany?: UserCreateManyHotelInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WidgetConfigUncheckedCreateNestedOneWithoutHotelInput = {
    create?: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
    connectOrCreate?: WidgetConfigCreateOrConnectWithoutHotelInput
    connect?: WidgetConfigWhereUniqueInput
  }

  export type RestrictionUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput> | RestrictionCreateWithoutHotelInput[] | RestrictionUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutHotelInput | RestrictionCreateOrConnectWithoutHotelInput[]
    createMany?: RestrictionCreateManyHotelInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput> | HotelWaitlistCreateWithoutHotelInput[] | HotelWaitlistUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutHotelInput | HotelWaitlistCreateOrConnectWithoutHotelInput[]
    createMany?: HotelWaitlistCreateManyHotelInputEnvelope
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoomTypeUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    upsert?: RoomTypeUpsertWithWhereUniqueWithoutHotelInput | RoomTypeUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    set?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    disconnect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    delete?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    update?: RoomTypeUpdateWithWhereUniqueWithoutHotelInput | RoomTypeUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomTypeUpdateManyWithWhereWithoutHotelInput | RoomTypeUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutHotelNestedInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutHotelInput | BookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutHotelInput | BookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutHotelInput | BookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RatePlanUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput> | RatePlanCreateWithoutHotelInput[] | RatePlanUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RatePlanCreateOrConnectWithoutHotelInput | RatePlanCreateOrConnectWithoutHotelInput[]
    upsert?: RatePlanUpsertWithWhereUniqueWithoutHotelInput | RatePlanUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RatePlanCreateManyHotelInputEnvelope
    set?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    disconnect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    delete?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    connect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    update?: RatePlanUpdateWithWhereUniqueWithoutHotelInput | RatePlanUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RatePlanUpdateManyWithWhereWithoutHotelInput | RatePlanUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RatePlanScalarWhereInput | RatePlanScalarWhereInput[]
  }

  export type SeasonUpdateManyWithoutHotelNestedInput = {
    create?: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput> | SeasonCreateWithoutHotelInput[] | SeasonUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutHotelInput | SeasonCreateOrConnectWithoutHotelInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutHotelInput | SeasonUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: SeasonCreateManyHotelInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutHotelInput | SeasonUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutHotelInput | SeasonUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type UserUpdateManyWithoutHotelNestedInput = {
    create?: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput> | UserCreateWithoutHotelInput[] | UserUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHotelInput | UserCreateOrConnectWithoutHotelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHotelInput | UserUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: UserCreateManyHotelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHotelInput | UserUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHotelInput | UserUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WidgetConfigUpdateOneWithoutHotelNestedInput = {
    create?: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
    connectOrCreate?: WidgetConfigCreateOrConnectWithoutHotelInput
    upsert?: WidgetConfigUpsertWithoutHotelInput
    disconnect?: WidgetConfigWhereInput | boolean
    delete?: WidgetConfigWhereInput | boolean
    connect?: WidgetConfigWhereUniqueInput
    update?: XOR<XOR<WidgetConfigUpdateToOneWithWhereWithoutHotelInput, WidgetConfigUpdateWithoutHotelInput>, WidgetConfigUncheckedUpdateWithoutHotelInput>
  }

  export type RestrictionUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput> | RestrictionCreateWithoutHotelInput[] | RestrictionUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutHotelInput | RestrictionCreateOrConnectWithoutHotelInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutHotelInput | RestrictionUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RestrictionCreateManyHotelInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutHotelInput | RestrictionUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutHotelInput | RestrictionUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type HotelWaitlistUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput> | HotelWaitlistCreateWithoutHotelInput[] | HotelWaitlistUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutHotelInput | HotelWaitlistCreateOrConnectWithoutHotelInput[]
    upsert?: HotelWaitlistUpsertWithWhereUniqueWithoutHotelInput | HotelWaitlistUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelWaitlistCreateManyHotelInputEnvelope
    set?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    disconnect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    delete?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    update?: HotelWaitlistUpdateWithWhereUniqueWithoutHotelInput | HotelWaitlistUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelWaitlistUpdateManyWithWhereWithoutHotelInput | HotelWaitlistUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
  }

  export type RoomTypeUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    upsert?: RoomTypeUpsertWithWhereUniqueWithoutHotelInput | RoomTypeUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    set?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    disconnect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    delete?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    update?: RoomTypeUpdateWithWhereUniqueWithoutHotelInput | RoomTypeUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomTypeUpdateManyWithWhereWithoutHotelInput | RoomTypeUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutHotelInput | BookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutHotelInput | BookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutHotelInput | BookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RatePlanUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput> | RatePlanCreateWithoutHotelInput[] | RatePlanUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RatePlanCreateOrConnectWithoutHotelInput | RatePlanCreateOrConnectWithoutHotelInput[]
    upsert?: RatePlanUpsertWithWhereUniqueWithoutHotelInput | RatePlanUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RatePlanCreateManyHotelInputEnvelope
    set?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    disconnect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    delete?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    connect?: RatePlanWhereUniqueInput | RatePlanWhereUniqueInput[]
    update?: RatePlanUpdateWithWhereUniqueWithoutHotelInput | RatePlanUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RatePlanUpdateManyWithWhereWithoutHotelInput | RatePlanUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RatePlanScalarWhereInput | RatePlanScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput> | SeasonCreateWithoutHotelInput[] | SeasonUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutHotelInput | SeasonCreateOrConnectWithoutHotelInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutHotelInput | SeasonUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: SeasonCreateManyHotelInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutHotelInput | SeasonUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutHotelInput | SeasonUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput> | UserCreateWithoutHotelInput[] | UserUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHotelInput | UserCreateOrConnectWithoutHotelInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHotelInput | UserUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: UserCreateManyHotelInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHotelInput | UserUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHotelInput | UserUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput = {
    create?: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
    connectOrCreate?: WidgetConfigCreateOrConnectWithoutHotelInput
    upsert?: WidgetConfigUpsertWithoutHotelInput
    disconnect?: WidgetConfigWhereInput | boolean
    delete?: WidgetConfigWhereInput | boolean
    connect?: WidgetConfigWhereUniqueInput
    update?: XOR<XOR<WidgetConfigUpdateToOneWithWhereWithoutHotelInput, WidgetConfigUpdateWithoutHotelInput>, WidgetConfigUncheckedUpdateWithoutHotelInput>
  }

  export type RestrictionUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput> | RestrictionCreateWithoutHotelInput[] | RestrictionUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutHotelInput | RestrictionCreateOrConnectWithoutHotelInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutHotelInput | RestrictionUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RestrictionCreateManyHotelInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutHotelInput | RestrictionUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutHotelInput | RestrictionUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput> | HotelWaitlistCreateWithoutHotelInput[] | HotelWaitlistUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutHotelInput | HotelWaitlistCreateOrConnectWithoutHotelInput[]
    upsert?: HotelWaitlistUpsertWithWhereUniqueWithoutHotelInput | HotelWaitlistUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelWaitlistCreateManyHotelInputEnvelope
    set?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    disconnect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    delete?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    update?: HotelWaitlistUpdateWithWhereUniqueWithoutHotelInput | HotelWaitlistUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelWaitlistUpdateManyWithWhereWithoutHotelInput | HotelWaitlistUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutWidgetConfigInput = {
    create?: XOR<HotelCreateWithoutWidgetConfigInput, HotelUncheckedCreateWithoutWidgetConfigInput>
    connectOrCreate?: HotelCreateOrConnectWithoutWidgetConfigInput
    connect?: HotelWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type HotelUpdateOneRequiredWithoutWidgetConfigNestedInput = {
    create?: XOR<HotelCreateWithoutWidgetConfigInput, HotelUncheckedCreateWithoutWidgetConfigInput>
    connectOrCreate?: HotelCreateOrConnectWithoutWidgetConfigInput
    upsert?: HotelUpsertWithoutWidgetConfigInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutWidgetConfigInput, HotelUpdateWithoutWidgetConfigInput>, HotelUncheckedUpdateWithoutWidgetConfigInput>
  }

  export type HotelCreateNestedOneWithoutRoomTypesInput = {
    create?: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomTypesInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ICalFeedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput> | ICalFeedCreateWithoutRoomTypeInput[] | ICalFeedUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ICalFeedCreateOrConnectWithoutRoomTypeInput | ICalFeedCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ICalFeedCreateManyRoomTypeInputEnvelope
    connect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
  }

  export type DailyPriceCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput> | DailyPriceCreateWithoutRoomTypeInput[] | DailyPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRoomTypeInput | DailyPriceCreateOrConnectWithoutRoomTypeInput[]
    createMany?: DailyPriceCreateManyRoomTypeInputEnvelope
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
  }

  export type RestrictionCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput> | RestrictionCreateWithoutRoomTypeInput[] | RestrictionUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRoomTypeInput | RestrictionCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RestrictionCreateManyRoomTypeInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type ChannelMappingCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput> | ChannelMappingCreateWithoutRoomTypeInput[] | ChannelMappingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRoomTypeInput | ChannelMappingCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ChannelMappingCreateManyRoomTypeInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type HotelWaitlistCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput> | HotelWaitlistCreateWithoutRoomTypeInput[] | HotelWaitlistUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutRoomTypeInput | HotelWaitlistCreateOrConnectWithoutRoomTypeInput[]
    createMany?: HotelWaitlistCreateManyRoomTypeInputEnvelope
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput> | ICalFeedCreateWithoutRoomTypeInput[] | ICalFeedUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ICalFeedCreateOrConnectWithoutRoomTypeInput | ICalFeedCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ICalFeedCreateManyRoomTypeInputEnvelope
    connect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
  }

  export type DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput> | DailyPriceCreateWithoutRoomTypeInput[] | DailyPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRoomTypeInput | DailyPriceCreateOrConnectWithoutRoomTypeInput[]
    createMany?: DailyPriceCreateManyRoomTypeInputEnvelope
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
  }

  export type RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput> | RestrictionCreateWithoutRoomTypeInput[] | RestrictionUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRoomTypeInput | RestrictionCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RestrictionCreateManyRoomTypeInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput> | ChannelMappingCreateWithoutRoomTypeInput[] | ChannelMappingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRoomTypeInput | ChannelMappingCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ChannelMappingCreateManyRoomTypeInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput> | HotelWaitlistCreateWithoutRoomTypeInput[] | HotelWaitlistUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutRoomTypeInput | HotelWaitlistCreateOrConnectWithoutRoomTypeInput[]
    createMany?: HotelWaitlistCreateManyRoomTypeInputEnvelope
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotelUpdateOneRequiredWithoutRoomTypesNestedInput = {
    create?: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomTypesInput
    upsert?: HotelUpsertWithoutRoomTypesInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomTypesInput, HotelUpdateWithoutRoomTypesInput>, HotelUncheckedUpdateWithoutRoomTypesInput>
  }

  export type RoomUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ICalFeedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput> | ICalFeedCreateWithoutRoomTypeInput[] | ICalFeedUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ICalFeedCreateOrConnectWithoutRoomTypeInput | ICalFeedCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ICalFeedUpsertWithWhereUniqueWithoutRoomTypeInput | ICalFeedUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ICalFeedCreateManyRoomTypeInputEnvelope
    set?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    disconnect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    delete?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    connect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    update?: ICalFeedUpdateWithWhereUniqueWithoutRoomTypeInput | ICalFeedUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ICalFeedUpdateManyWithWhereWithoutRoomTypeInput | ICalFeedUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ICalFeedScalarWhereInput | ICalFeedScalarWhereInput[]
  }

  export type DailyPriceUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput> | DailyPriceCreateWithoutRoomTypeInput[] | DailyPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRoomTypeInput | DailyPriceCreateOrConnectWithoutRoomTypeInput[]
    upsert?: DailyPriceUpsertWithWhereUniqueWithoutRoomTypeInput | DailyPriceUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: DailyPriceCreateManyRoomTypeInputEnvelope
    set?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    disconnect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    delete?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    update?: DailyPriceUpdateWithWhereUniqueWithoutRoomTypeInput | DailyPriceUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: DailyPriceUpdateManyWithWhereWithoutRoomTypeInput | DailyPriceUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
  }

  export type RestrictionUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput> | RestrictionCreateWithoutRoomTypeInput[] | RestrictionUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRoomTypeInput | RestrictionCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutRoomTypeInput | RestrictionUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RestrictionCreateManyRoomTypeInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutRoomTypeInput | RestrictionUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutRoomTypeInput | RestrictionUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type ChannelMappingUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput> | ChannelMappingCreateWithoutRoomTypeInput[] | ChannelMappingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRoomTypeInput | ChannelMappingCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutRoomTypeInput | ChannelMappingUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ChannelMappingCreateManyRoomTypeInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutRoomTypeInput | ChannelMappingUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutRoomTypeInput | ChannelMappingUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type HotelWaitlistUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput> | HotelWaitlistCreateWithoutRoomTypeInput[] | HotelWaitlistUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutRoomTypeInput | HotelWaitlistCreateOrConnectWithoutRoomTypeInput[]
    upsert?: HotelWaitlistUpsertWithWhereUniqueWithoutRoomTypeInput | HotelWaitlistUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: HotelWaitlistCreateManyRoomTypeInputEnvelope
    set?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    disconnect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    delete?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    update?: HotelWaitlistUpdateWithWhereUniqueWithoutRoomTypeInput | HotelWaitlistUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: HotelWaitlistUpdateManyWithWhereWithoutRoomTypeInput | HotelWaitlistUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput> | ICalFeedCreateWithoutRoomTypeInput[] | ICalFeedUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ICalFeedCreateOrConnectWithoutRoomTypeInput | ICalFeedCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ICalFeedUpsertWithWhereUniqueWithoutRoomTypeInput | ICalFeedUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ICalFeedCreateManyRoomTypeInputEnvelope
    set?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    disconnect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    delete?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    connect?: ICalFeedWhereUniqueInput | ICalFeedWhereUniqueInput[]
    update?: ICalFeedUpdateWithWhereUniqueWithoutRoomTypeInput | ICalFeedUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ICalFeedUpdateManyWithWhereWithoutRoomTypeInput | ICalFeedUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ICalFeedScalarWhereInput | ICalFeedScalarWhereInput[]
  }

  export type DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput> | DailyPriceCreateWithoutRoomTypeInput[] | DailyPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRoomTypeInput | DailyPriceCreateOrConnectWithoutRoomTypeInput[]
    upsert?: DailyPriceUpsertWithWhereUniqueWithoutRoomTypeInput | DailyPriceUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: DailyPriceCreateManyRoomTypeInputEnvelope
    set?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    disconnect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    delete?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    update?: DailyPriceUpdateWithWhereUniqueWithoutRoomTypeInput | DailyPriceUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: DailyPriceUpdateManyWithWhereWithoutRoomTypeInput | DailyPriceUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
  }

  export type RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput> | RestrictionCreateWithoutRoomTypeInput[] | RestrictionUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRoomTypeInput | RestrictionCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutRoomTypeInput | RestrictionUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RestrictionCreateManyRoomTypeInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutRoomTypeInput | RestrictionUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutRoomTypeInput | RestrictionUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput> | ChannelMappingCreateWithoutRoomTypeInput[] | ChannelMappingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRoomTypeInput | ChannelMappingCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutRoomTypeInput | ChannelMappingUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ChannelMappingCreateManyRoomTypeInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutRoomTypeInput | ChannelMappingUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutRoomTypeInput | ChannelMappingUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput> | HotelWaitlistCreateWithoutRoomTypeInput[] | HotelWaitlistUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: HotelWaitlistCreateOrConnectWithoutRoomTypeInput | HotelWaitlistCreateOrConnectWithoutRoomTypeInput[]
    upsert?: HotelWaitlistUpsertWithWhereUniqueWithoutRoomTypeInput | HotelWaitlistUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: HotelWaitlistCreateManyRoomTypeInputEnvelope
    set?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    disconnect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    delete?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    connect?: HotelWaitlistWhereUniqueInput | HotelWaitlistWhereUniqueInput[]
    update?: HotelWaitlistUpdateWithWhereUniqueWithoutRoomTypeInput | HotelWaitlistUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: HotelWaitlistUpdateManyWithWhereWithoutRoomTypeInput | HotelWaitlistUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
  }

  export type RoomTypeCreateNestedOneWithoutRoomsInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type BookingRoomCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput> | BookingRoomCreateWithoutRoomInput[] | BookingRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutRoomInput | BookingRoomCreateOrConnectWithoutRoomInput[]
    createMany?: BookingRoomCreateManyRoomInputEnvelope
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
  }

  export type BookingRoomUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput> | BookingRoomCreateWithoutRoomInput[] | BookingRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutRoomInput | BookingRoomCreateOrConnectWithoutRoomInput[]
    createMany?: BookingRoomCreateManyRoomInputEnvelope
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
  }

  export type RoomTypeUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    upsert?: RoomTypeUpsertWithoutRoomsInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutRoomsInput, RoomTypeUpdateWithoutRoomsInput>, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type BookingRoomUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput> | BookingRoomCreateWithoutRoomInput[] | BookingRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutRoomInput | BookingRoomCreateOrConnectWithoutRoomInput[]
    upsert?: BookingRoomUpsertWithWhereUniqueWithoutRoomInput | BookingRoomUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingRoomCreateManyRoomInputEnvelope
    set?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    disconnect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    delete?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    update?: BookingRoomUpdateWithWhereUniqueWithoutRoomInput | BookingRoomUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingRoomUpdateManyWithWhereWithoutRoomInput | BookingRoomUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
  }

  export type BookingRoomUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput> | BookingRoomCreateWithoutRoomInput[] | BookingRoomUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutRoomInput | BookingRoomCreateOrConnectWithoutRoomInput[]
    upsert?: BookingRoomUpsertWithWhereUniqueWithoutRoomInput | BookingRoomUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingRoomCreateManyRoomInputEnvelope
    set?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    disconnect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    delete?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    update?: BookingRoomUpdateWithWhereUniqueWithoutRoomInput | BookingRoomUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingRoomUpdateManyWithWhereWithoutRoomInput | BookingRoomUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutGuestInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutGuestNestedInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGuestInput | BookingUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGuestInput | BookingUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGuestInput | BookingUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGuestInput | BookingUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGuestInput | BookingUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGuestInput | BookingUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutRatePlansInput = {
    create?: XOR<HotelCreateWithoutRatePlansInput, HotelUncheckedCreateWithoutRatePlansInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRatePlansInput
    connect?: HotelWhereUniqueInput
  }

  export type DailyPriceCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput> | DailyPriceCreateWithoutRatePlanInput[] | DailyPriceUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRatePlanInput | DailyPriceCreateOrConnectWithoutRatePlanInput[]
    createMany?: DailyPriceCreateManyRatePlanInputEnvelope
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
  }

  export type RestrictionCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput> | RestrictionCreateWithoutRatePlanInput[] | RestrictionUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRatePlanInput | RestrictionCreateOrConnectWithoutRatePlanInput[]
    createMany?: RestrictionCreateManyRatePlanInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type ChannelMappingCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput> | ChannelMappingCreateWithoutRatePlanInput[] | ChannelMappingUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRatePlanInput | ChannelMappingCreateOrConnectWithoutRatePlanInput[]
    createMany?: ChannelMappingCreateManyRatePlanInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type DailyPriceUncheckedCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput> | DailyPriceCreateWithoutRatePlanInput[] | DailyPriceUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRatePlanInput | DailyPriceCreateOrConnectWithoutRatePlanInput[]
    createMany?: DailyPriceCreateManyRatePlanInputEnvelope
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
  }

  export type RestrictionUncheckedCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput> | RestrictionCreateWithoutRatePlanInput[] | RestrictionUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRatePlanInput | RestrictionCreateOrConnectWithoutRatePlanInput[]
    createMany?: RestrictionCreateManyRatePlanInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type ChannelMappingUncheckedCreateNestedManyWithoutRatePlanInput = {
    create?: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput> | ChannelMappingCreateWithoutRatePlanInput[] | ChannelMappingUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRatePlanInput | ChannelMappingCreateOrConnectWithoutRatePlanInput[]
    createMany?: ChannelMappingCreateManyRatePlanInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type HotelUpdateOneRequiredWithoutRatePlansNestedInput = {
    create?: XOR<HotelCreateWithoutRatePlansInput, HotelUncheckedCreateWithoutRatePlansInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRatePlansInput
    upsert?: HotelUpsertWithoutRatePlansInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRatePlansInput, HotelUpdateWithoutRatePlansInput>, HotelUncheckedUpdateWithoutRatePlansInput>
  }

  export type DailyPriceUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput> | DailyPriceCreateWithoutRatePlanInput[] | DailyPriceUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRatePlanInput | DailyPriceCreateOrConnectWithoutRatePlanInput[]
    upsert?: DailyPriceUpsertWithWhereUniqueWithoutRatePlanInput | DailyPriceUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: DailyPriceCreateManyRatePlanInputEnvelope
    set?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    disconnect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    delete?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    update?: DailyPriceUpdateWithWhereUniqueWithoutRatePlanInput | DailyPriceUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: DailyPriceUpdateManyWithWhereWithoutRatePlanInput | DailyPriceUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
  }

  export type RestrictionUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput> | RestrictionCreateWithoutRatePlanInput[] | RestrictionUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRatePlanInput | RestrictionCreateOrConnectWithoutRatePlanInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutRatePlanInput | RestrictionUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: RestrictionCreateManyRatePlanInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutRatePlanInput | RestrictionUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutRatePlanInput | RestrictionUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type ChannelMappingUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput> | ChannelMappingCreateWithoutRatePlanInput[] | ChannelMappingUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRatePlanInput | ChannelMappingCreateOrConnectWithoutRatePlanInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutRatePlanInput | ChannelMappingUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: ChannelMappingCreateManyRatePlanInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutRatePlanInput | ChannelMappingUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutRatePlanInput | ChannelMappingUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type DailyPriceUncheckedUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput> | DailyPriceCreateWithoutRatePlanInput[] | DailyPriceUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: DailyPriceCreateOrConnectWithoutRatePlanInput | DailyPriceCreateOrConnectWithoutRatePlanInput[]
    upsert?: DailyPriceUpsertWithWhereUniqueWithoutRatePlanInput | DailyPriceUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: DailyPriceCreateManyRatePlanInputEnvelope
    set?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    disconnect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    delete?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    connect?: DailyPriceWhereUniqueInput | DailyPriceWhereUniqueInput[]
    update?: DailyPriceUpdateWithWhereUniqueWithoutRatePlanInput | DailyPriceUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: DailyPriceUpdateManyWithWhereWithoutRatePlanInput | DailyPriceUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
  }

  export type RestrictionUncheckedUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput> | RestrictionCreateWithoutRatePlanInput[] | RestrictionUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutRatePlanInput | RestrictionCreateOrConnectWithoutRatePlanInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutRatePlanInput | RestrictionUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: RestrictionCreateManyRatePlanInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutRatePlanInput | RestrictionUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutRatePlanInput | RestrictionUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type ChannelMappingUncheckedUpdateManyWithoutRatePlanNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput> | ChannelMappingCreateWithoutRatePlanInput[] | ChannelMappingUncheckedCreateWithoutRatePlanInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutRatePlanInput | ChannelMappingCreateOrConnectWithoutRatePlanInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutRatePlanInput | ChannelMappingUpsertWithWhereUniqueWithoutRatePlanInput[]
    createMany?: ChannelMappingCreateManyRatePlanInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutRatePlanInput | ChannelMappingUpdateWithWhereUniqueWithoutRatePlanInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutRatePlanInput | ChannelMappingUpdateManyWithWhereWithoutRatePlanInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<HotelCreateWithoutSeasonsInput, HotelUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutSeasonsInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<HotelCreateWithoutSeasonsInput, HotelUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutSeasonsInput
    upsert?: HotelUpsertWithoutSeasonsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutSeasonsInput, HotelUpdateWithoutSeasonsInput>, HotelUncheckedUpdateWithoutSeasonsInput>
  }

  export type RoomTypeCreateNestedOneWithoutDailyPricesInput = {
    create?: XOR<RoomTypeCreateWithoutDailyPricesInput, RoomTypeUncheckedCreateWithoutDailyPricesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutDailyPricesInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type RatePlanCreateNestedOneWithoutDailyPricesInput = {
    create?: XOR<RatePlanCreateWithoutDailyPricesInput, RatePlanUncheckedCreateWithoutDailyPricesInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutDailyPricesInput
    connect?: RatePlanWhereUniqueInput
  }

  export type RoomTypeUpdateOneRequiredWithoutDailyPricesNestedInput = {
    create?: XOR<RoomTypeCreateWithoutDailyPricesInput, RoomTypeUncheckedCreateWithoutDailyPricesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutDailyPricesInput
    upsert?: RoomTypeUpsertWithoutDailyPricesInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutDailyPricesInput, RoomTypeUpdateWithoutDailyPricesInput>, RoomTypeUncheckedUpdateWithoutDailyPricesInput>
  }

  export type RatePlanUpdateOneRequiredWithoutDailyPricesNestedInput = {
    create?: XOR<RatePlanCreateWithoutDailyPricesInput, RatePlanUncheckedCreateWithoutDailyPricesInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutDailyPricesInput
    upsert?: RatePlanUpsertWithoutDailyPricesInput
    connect?: RatePlanWhereUniqueInput
    update?: XOR<XOR<RatePlanUpdateToOneWithWhereWithoutDailyPricesInput, RatePlanUpdateWithoutDailyPricesInput>, RatePlanUncheckedUpdateWithoutDailyPricesInput>
  }

  export type HotelCreateNestedOneWithoutRestrictionsInput = {
    create?: XOR<HotelCreateWithoutRestrictionsInput, HotelUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRestrictionsInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutRestrictionsInput = {
    create?: XOR<RoomTypeCreateWithoutRestrictionsInput, RoomTypeUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRestrictionsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type RatePlanCreateNestedOneWithoutRestrictionsInput = {
    create?: XOR<RatePlanCreateWithoutRestrictionsInput, RatePlanUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutRestrictionsInput
    connect?: RatePlanWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotelUpdateOneRequiredWithoutRestrictionsNestedInput = {
    create?: XOR<HotelCreateWithoutRestrictionsInput, HotelUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRestrictionsInput
    upsert?: HotelUpsertWithoutRestrictionsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRestrictionsInput, HotelUpdateWithoutRestrictionsInput>, HotelUncheckedUpdateWithoutRestrictionsInput>
  }

  export type RoomTypeUpdateOneWithoutRestrictionsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutRestrictionsInput, RoomTypeUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRestrictionsInput
    upsert?: RoomTypeUpsertWithoutRestrictionsInput
    disconnect?: RoomTypeWhereInput | boolean
    delete?: RoomTypeWhereInput | boolean
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutRestrictionsInput, RoomTypeUpdateWithoutRestrictionsInput>, RoomTypeUncheckedUpdateWithoutRestrictionsInput>
  }

  export type RatePlanUpdateOneWithoutRestrictionsNestedInput = {
    create?: XOR<RatePlanCreateWithoutRestrictionsInput, RatePlanUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutRestrictionsInput
    upsert?: RatePlanUpsertWithoutRestrictionsInput
    disconnect?: RatePlanWhereInput | boolean
    delete?: RatePlanWhereInput | boolean
    connect?: RatePlanWhereUniqueInput
    update?: XOR<XOR<RatePlanUpdateToOneWithWhereWithoutRestrictionsInput, RatePlanUpdateWithoutRestrictionsInput>, RatePlanUncheckedUpdateWithoutRestrictionsInput>
  }

  export type HotelCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    connect?: HotelWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutBookingsInput = {
    create?: XOR<GuestCreateWithoutBookingsInput, GuestUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutBookingsInput
    connect?: GuestWhereUniqueInput
  }

  export type BookingRoomCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput> | BookingRoomCreateWithoutBookingInput[] | BookingRoomUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutBookingInput | BookingRoomCreateOrConnectWithoutBookingInput[]
    createMany?: BookingRoomCreateManyBookingInputEnvelope
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BookingRoomUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput> | BookingRoomCreateWithoutBookingInput[] | BookingRoomUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutBookingInput | BookingRoomCreateOrConnectWithoutBookingInput[]
    createMany?: BookingRoomCreateManyBookingInputEnvelope
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type HotelUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    upsert?: HotelUpsertWithoutBookingsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutBookingsInput, HotelUpdateWithoutBookingsInput>, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type GuestUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<GuestCreateWithoutBookingsInput, GuestUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutBookingsInput
    upsert?: GuestUpsertWithoutBookingsInput
    disconnect?: GuestWhereInput | boolean
    delete?: GuestWhereInput | boolean
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutBookingsInput, GuestUpdateWithoutBookingsInput>, GuestUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingRoomUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput> | BookingRoomCreateWithoutBookingInput[] | BookingRoomUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutBookingInput | BookingRoomCreateOrConnectWithoutBookingInput[]
    upsert?: BookingRoomUpsertWithWhereUniqueWithoutBookingInput | BookingRoomUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingRoomCreateManyBookingInputEnvelope
    set?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    disconnect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    delete?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    update?: BookingRoomUpdateWithWhereUniqueWithoutBookingInput | BookingRoomUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingRoomUpdateManyWithWhereWithoutBookingInput | BookingRoomUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingRoomUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput> | BookingRoomCreateWithoutBookingInput[] | BookingRoomUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRoomCreateOrConnectWithoutBookingInput | BookingRoomCreateOrConnectWithoutBookingInput[]
    upsert?: BookingRoomUpsertWithWhereUniqueWithoutBookingInput | BookingRoomUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingRoomCreateManyBookingInputEnvelope
    set?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    disconnect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    delete?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    connect?: BookingRoomWhereUniqueInput | BookingRoomWhereUniqueInput[]
    update?: BookingRoomUpdateWithWhereUniqueWithoutBookingInput | BookingRoomUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingRoomUpdateManyWithWhereWithoutBookingInput | BookingRoomUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutBookingRoomsInput = {
    create?: XOR<BookingCreateWithoutBookingRoomsInput, BookingUncheckedCreateWithoutBookingRoomsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingRoomsInput
    connect?: BookingWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutBookingRoomsInput = {
    create?: XOR<RoomCreateWithoutBookingRoomsInput, RoomUncheckedCreateWithoutBookingRoomsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBookingRoomsInput
    connect?: RoomWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBookingRoomsNestedInput = {
    create?: XOR<BookingCreateWithoutBookingRoomsInput, BookingUncheckedCreateWithoutBookingRoomsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBookingRoomsInput
    upsert?: BookingUpsertWithoutBookingRoomsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBookingRoomsInput, BookingUpdateWithoutBookingRoomsInput>, BookingUncheckedUpdateWithoutBookingRoomsInput>
  }

  export type RoomUpdateOneRequiredWithoutBookingRoomsNestedInput = {
    create?: XOR<RoomCreateWithoutBookingRoomsInput, RoomUncheckedCreateWithoutBookingRoomsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBookingRoomsInput
    upsert?: RoomUpsertWithoutBookingRoomsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutBookingRoomsInput, RoomUpdateWithoutBookingRoomsInput>, RoomUncheckedUpdateWithoutBookingRoomsInput>
  }

  export type ChannelMappingCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput> | ChannelMappingCreateWithoutChannelInput[] | ChannelMappingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutChannelInput | ChannelMappingCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMappingCreateManyChannelInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type ChannelMappingUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput> | ChannelMappingCreateWithoutChannelInput[] | ChannelMappingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutChannelInput | ChannelMappingCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMappingCreateManyChannelInputEnvelope
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
  }

  export type ChannelMappingUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput> | ChannelMappingCreateWithoutChannelInput[] | ChannelMappingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutChannelInput | ChannelMappingCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutChannelInput | ChannelMappingUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMappingCreateManyChannelInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutChannelInput | ChannelMappingUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutChannelInput | ChannelMappingUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type ChannelMappingUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput> | ChannelMappingCreateWithoutChannelInput[] | ChannelMappingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMappingCreateOrConnectWithoutChannelInput | ChannelMappingCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMappingUpsertWithWhereUniqueWithoutChannelInput | ChannelMappingUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMappingCreateManyChannelInputEnvelope
    set?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    disconnect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    delete?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    connect?: ChannelMappingWhereUniqueInput | ChannelMappingWhereUniqueInput[]
    update?: ChannelMappingUpdateWithWhereUniqueWithoutChannelInput | ChannelMappingUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMappingUpdateManyWithWhereWithoutChannelInput | ChannelMappingUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
  }

  export type ChannelCreateNestedOneWithoutMappingsInput = {
    create?: XOR<ChannelCreateWithoutMappingsInput, ChannelUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMappingsInput
    connect?: ChannelWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutChannelMappingsInput = {
    create?: XOR<RoomTypeCreateWithoutChannelMappingsInput, RoomTypeUncheckedCreateWithoutChannelMappingsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutChannelMappingsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type RatePlanCreateNestedOneWithoutChannelMappingsInput = {
    create?: XOR<RatePlanCreateWithoutChannelMappingsInput, RatePlanUncheckedCreateWithoutChannelMappingsInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutChannelMappingsInput
    connect?: RatePlanWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutMappingsNestedInput = {
    create?: XOR<ChannelCreateWithoutMappingsInput, ChannelUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMappingsInput
    upsert?: ChannelUpsertWithoutMappingsInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMappingsInput, ChannelUpdateWithoutMappingsInput>, ChannelUncheckedUpdateWithoutMappingsInput>
  }

  export type RoomTypeUpdateOneRequiredWithoutChannelMappingsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutChannelMappingsInput, RoomTypeUncheckedCreateWithoutChannelMappingsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutChannelMappingsInput
    upsert?: RoomTypeUpsertWithoutChannelMappingsInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutChannelMappingsInput, RoomTypeUpdateWithoutChannelMappingsInput>, RoomTypeUncheckedUpdateWithoutChannelMappingsInput>
  }

  export type RatePlanUpdateOneWithoutChannelMappingsNestedInput = {
    create?: XOR<RatePlanCreateWithoutChannelMappingsInput, RatePlanUncheckedCreateWithoutChannelMappingsInput>
    connectOrCreate?: RatePlanCreateOrConnectWithoutChannelMappingsInput
    upsert?: RatePlanUpsertWithoutChannelMappingsInput
    disconnect?: RatePlanWhereInput | boolean
    delete?: RatePlanWhereInput | boolean
    connect?: RatePlanWhereUniqueInput
    update?: XOR<XOR<RatePlanUpdateToOneWithWhereWithoutChannelMappingsInput, RatePlanUpdateWithoutChannelMappingsInput>, RatePlanUncheckedUpdateWithoutChannelMappingsInput>
  }

  export type RoomTypeCreateNestedOneWithoutIcalFeedsInput = {
    create?: XOR<RoomTypeCreateWithoutIcalFeedsInput, RoomTypeUncheckedCreateWithoutIcalFeedsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutIcalFeedsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoomTypeUpdateOneRequiredWithoutIcalFeedsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutIcalFeedsInput, RoomTypeUncheckedCreateWithoutIcalFeedsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutIcalFeedsInput
    upsert?: RoomTypeUpsertWithoutIcalFeedsInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutIcalFeedsInput, RoomTypeUpdateWithoutIcalFeedsInput>, RoomTypeUncheckedUpdateWithoutIcalFeedsInput>
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type HotelCreateNestedOneWithoutUsersInput = {
    create?: XOR<HotelCreateWithoutUsersInput, HotelUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HotelCreateOrConnectWithoutUsersInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelUpdateOneWithoutUsersNestedInput = {
    create?: XOR<HotelCreateWithoutUsersInput, HotelUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HotelCreateOrConnectWithoutUsersInput
    upsert?: HotelUpsertWithoutUsersInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutUsersInput, HotelUpdateWithoutUsersInput>, HotelUncheckedUpdateWithoutUsersInput>
  }

  export type ZoneCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput> | ZoneCreateWithoutRestaurantInput[] | ZoneUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutRestaurantInput | ZoneCreateOrConnectWithoutRestaurantInput[]
    createMany?: ZoneCreateManyRestaurantInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ResBookingCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput> | ResBookingCreateWithoutRestaurantInput[] | ResBookingUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutRestaurantInput | ResBookingCreateOrConnectWithoutRestaurantInput[]
    createMany?: ResBookingCreateManyRestaurantInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type RestaurantWaitlistCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput> | RestaurantWaitlistCreateWithoutRestaurantInput[] | RestaurantWaitlistUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: RestaurantWaitlistCreateOrConnectWithoutRestaurantInput | RestaurantWaitlistCreateOrConnectWithoutRestaurantInput[]
    createMany?: RestaurantWaitlistCreateManyRestaurantInputEnvelope
    connect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput> | ZoneCreateWithoutRestaurantInput[] | ZoneUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutRestaurantInput | ZoneCreateOrConnectWithoutRestaurantInput[]
    createMany?: ZoneCreateManyRestaurantInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ResBookingUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput> | ResBookingCreateWithoutRestaurantInput[] | ResBookingUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutRestaurantInput | ResBookingCreateOrConnectWithoutRestaurantInput[]
    createMany?: ResBookingCreateManyRestaurantInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type RestaurantWaitlistUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput> | RestaurantWaitlistCreateWithoutRestaurantInput[] | RestaurantWaitlistUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: RestaurantWaitlistCreateOrConnectWithoutRestaurantInput | RestaurantWaitlistCreateOrConnectWithoutRestaurantInput[]
    createMany?: RestaurantWaitlistCreateManyRestaurantInputEnvelope
    connect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
  }

  export type ZoneUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput> | ZoneCreateWithoutRestaurantInput[] | ZoneUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutRestaurantInput | ZoneCreateOrConnectWithoutRestaurantInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutRestaurantInput | ZoneUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ZoneCreateManyRestaurantInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutRestaurantInput | ZoneUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutRestaurantInput | ZoneUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ResBookingUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput> | ResBookingCreateWithoutRestaurantInput[] | ResBookingUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutRestaurantInput | ResBookingCreateOrConnectWithoutRestaurantInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutRestaurantInput | ResBookingUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ResBookingCreateManyRestaurantInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutRestaurantInput | ResBookingUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutRestaurantInput | ResBookingUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type RestaurantWaitlistUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput> | RestaurantWaitlistCreateWithoutRestaurantInput[] | RestaurantWaitlistUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: RestaurantWaitlistCreateOrConnectWithoutRestaurantInput | RestaurantWaitlistCreateOrConnectWithoutRestaurantInput[]
    upsert?: RestaurantWaitlistUpsertWithWhereUniqueWithoutRestaurantInput | RestaurantWaitlistUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: RestaurantWaitlistCreateManyRestaurantInputEnvelope
    set?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    disconnect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    delete?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    connect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    update?: RestaurantWaitlistUpdateWithWhereUniqueWithoutRestaurantInput | RestaurantWaitlistUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: RestaurantWaitlistUpdateManyWithWhereWithoutRestaurantInput | RestaurantWaitlistUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: RestaurantWaitlistScalarWhereInput | RestaurantWaitlistScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput> | ZoneCreateWithoutRestaurantInput[] | ZoneUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutRestaurantInput | ZoneCreateOrConnectWithoutRestaurantInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutRestaurantInput | ZoneUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ZoneCreateManyRestaurantInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutRestaurantInput | ZoneUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutRestaurantInput | ZoneUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ResBookingUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput> | ResBookingCreateWithoutRestaurantInput[] | ResBookingUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutRestaurantInput | ResBookingCreateOrConnectWithoutRestaurantInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutRestaurantInput | ResBookingUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ResBookingCreateManyRestaurantInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutRestaurantInput | ResBookingUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutRestaurantInput | ResBookingUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput> | RestaurantWaitlistCreateWithoutRestaurantInput[] | RestaurantWaitlistUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: RestaurantWaitlistCreateOrConnectWithoutRestaurantInput | RestaurantWaitlistCreateOrConnectWithoutRestaurantInput[]
    upsert?: RestaurantWaitlistUpsertWithWhereUniqueWithoutRestaurantInput | RestaurantWaitlistUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: RestaurantWaitlistCreateManyRestaurantInputEnvelope
    set?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    disconnect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    delete?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    connect?: RestaurantWaitlistWhereUniqueInput | RestaurantWaitlistWhereUniqueInput[]
    update?: RestaurantWaitlistUpdateWithWhereUniqueWithoutRestaurantInput | RestaurantWaitlistUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: RestaurantWaitlistUpdateManyWithWhereWithoutRestaurantInput | RestaurantWaitlistUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: RestaurantWaitlistScalarWhereInput | RestaurantWaitlistScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutZonesInput = {
    create?: XOR<RestaurantCreateWithoutZonesInput, RestaurantUncheckedCreateWithoutZonesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutZonesInput
    connect?: RestaurantWhereUniqueInput
  }

  export type TableCreateNestedManyWithoutZoneInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type RestaurantUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<RestaurantCreateWithoutZonesInput, RestaurantUncheckedCreateWithoutZonesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutZonesInput
    upsert?: RestaurantUpsertWithoutZonesInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutZonesInput, RestaurantUpdateWithoutZonesInput>, RestaurantUncheckedUpdateWithoutZonesInput>
  }

  export type TableUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutZoneInput | TableUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutZoneInput | TableUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TableUpdateManyWithWhereWithoutZoneInput | TableUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutZoneInput | TableUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutZoneInput | TableUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TableUpdateManyWithWhereWithoutZoneInput | TableUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ZoneCreateNestedOneWithoutTablesInput = {
    create?: XOR<ZoneCreateWithoutTablesInput, ZoneUncheckedCreateWithoutTablesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutTablesInput
    connect?: ZoneWhereUniqueInput
  }

  export type ResBookingCreateNestedManyWithoutTableInput = {
    create?: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput> | ResBookingCreateWithoutTableInput[] | ResBookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutTableInput | ResBookingCreateOrConnectWithoutTableInput[]
    createMany?: ResBookingCreateManyTableInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type TableHoldCreateNestedManyWithoutTableInput = {
    create?: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput> | TableHoldCreateWithoutTableInput[] | TableHoldUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableHoldCreateOrConnectWithoutTableInput | TableHoldCreateOrConnectWithoutTableInput[]
    createMany?: TableHoldCreateManyTableInputEnvelope
    connect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
  }

  export type ResBookingUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput> | ResBookingCreateWithoutTableInput[] | ResBookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutTableInput | ResBookingCreateOrConnectWithoutTableInput[]
    createMany?: ResBookingCreateManyTableInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type TableHoldUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput> | TableHoldCreateWithoutTableInput[] | TableHoldUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableHoldCreateOrConnectWithoutTableInput | TableHoldCreateOrConnectWithoutTableInput[]
    createMany?: TableHoldCreateManyTableInputEnvelope
    connect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
  }

  export type ZoneUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<ZoneCreateWithoutTablesInput, ZoneUncheckedCreateWithoutTablesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutTablesInput
    upsert?: ZoneUpsertWithoutTablesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutTablesInput, ZoneUpdateWithoutTablesInput>, ZoneUncheckedUpdateWithoutTablesInput>
  }

  export type ResBookingUpdateManyWithoutTableNestedInput = {
    create?: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput> | ResBookingCreateWithoutTableInput[] | ResBookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutTableInput | ResBookingCreateOrConnectWithoutTableInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutTableInput | ResBookingUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ResBookingCreateManyTableInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutTableInput | ResBookingUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutTableInput | ResBookingUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type TableHoldUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput> | TableHoldCreateWithoutTableInput[] | TableHoldUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableHoldCreateOrConnectWithoutTableInput | TableHoldCreateOrConnectWithoutTableInput[]
    upsert?: TableHoldUpsertWithWhereUniqueWithoutTableInput | TableHoldUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableHoldCreateManyTableInputEnvelope
    set?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    disconnect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    delete?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    connect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    update?: TableHoldUpdateWithWhereUniqueWithoutTableInput | TableHoldUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableHoldUpdateManyWithWhereWithoutTableInput | TableHoldUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableHoldScalarWhereInput | TableHoldScalarWhereInput[]
  }

  export type ResBookingUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput> | ResBookingCreateWithoutTableInput[] | ResBookingUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutTableInput | ResBookingCreateOrConnectWithoutTableInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutTableInput | ResBookingUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ResBookingCreateManyTableInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutTableInput | ResBookingUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutTableInput | ResBookingUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type TableHoldUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput> | TableHoldCreateWithoutTableInput[] | TableHoldUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableHoldCreateOrConnectWithoutTableInput | TableHoldCreateOrConnectWithoutTableInput[]
    upsert?: TableHoldUpsertWithWhereUniqueWithoutTableInput | TableHoldUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableHoldCreateManyTableInputEnvelope
    set?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    disconnect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    delete?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    connect?: TableHoldWhereUniqueInput | TableHoldWhereUniqueInput[]
    update?: TableHoldUpdateWithWhereUniqueWithoutTableInput | TableHoldUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableHoldUpdateManyWithWhereWithoutTableInput | TableHoldUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableHoldScalarWhereInput | TableHoldScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutBookingsInput = {
    create?: XOR<RestaurantCreateWithoutBookingsInput, RestaurantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutBookingsInput
    connect?: RestaurantWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutResBookingsInput = {
    create?: XOR<TableCreateWithoutResBookingsInput, TableUncheckedCreateWithoutResBookingsInput>
    connectOrCreate?: TableCreateOrConnectWithoutResBookingsInput
    connect?: TableWhereUniqueInput
  }

  export type RestaurantChannelCreateNestedOneWithoutResBookingsInput = {
    create?: XOR<RestaurantChannelCreateWithoutResBookingsInput, RestaurantChannelUncheckedCreateWithoutResBookingsInput>
    connectOrCreate?: RestaurantChannelCreateOrConnectWithoutResBookingsInput
    connect?: RestaurantChannelWhereUniqueInput
  }

  export type RestaurantUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<RestaurantCreateWithoutBookingsInput, RestaurantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutBookingsInput
    upsert?: RestaurantUpsertWithoutBookingsInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutBookingsInput, RestaurantUpdateWithoutBookingsInput>, RestaurantUncheckedUpdateWithoutBookingsInput>
  }

  export type TableUpdateOneWithoutResBookingsNestedInput = {
    create?: XOR<TableCreateWithoutResBookingsInput, TableUncheckedCreateWithoutResBookingsInput>
    connectOrCreate?: TableCreateOrConnectWithoutResBookingsInput
    upsert?: TableUpsertWithoutResBookingsInput
    disconnect?: TableWhereInput | boolean
    delete?: TableWhereInput | boolean
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutResBookingsInput, TableUpdateWithoutResBookingsInput>, TableUncheckedUpdateWithoutResBookingsInput>
  }

  export type RestaurantChannelUpdateOneWithoutResBookingsNestedInput = {
    create?: XOR<RestaurantChannelCreateWithoutResBookingsInput, RestaurantChannelUncheckedCreateWithoutResBookingsInput>
    connectOrCreate?: RestaurantChannelCreateOrConnectWithoutResBookingsInput
    upsert?: RestaurantChannelUpsertWithoutResBookingsInput
    disconnect?: RestaurantChannelWhereInput | boolean
    delete?: RestaurantChannelWhereInput | boolean
    connect?: RestaurantChannelWhereUniqueInput
    update?: XOR<XOR<RestaurantChannelUpdateToOneWithWhereWithoutResBookingsInput, RestaurantChannelUpdateWithoutResBookingsInput>, RestaurantChannelUncheckedUpdateWithoutResBookingsInput>
  }

  export type ResBookingCreateNestedManyWithoutChannelInput = {
    create?: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput> | ResBookingCreateWithoutChannelInput[] | ResBookingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutChannelInput | ResBookingCreateOrConnectWithoutChannelInput[]
    createMany?: ResBookingCreateManyChannelInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type ResBookingUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput> | ResBookingCreateWithoutChannelInput[] | ResBookingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutChannelInput | ResBookingCreateOrConnectWithoutChannelInput[]
    createMany?: ResBookingCreateManyChannelInputEnvelope
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
  }

  export type ResBookingUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput> | ResBookingCreateWithoutChannelInput[] | ResBookingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutChannelInput | ResBookingCreateOrConnectWithoutChannelInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutChannelInput | ResBookingUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ResBookingCreateManyChannelInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutChannelInput | ResBookingUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutChannelInput | ResBookingUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type ResBookingUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput> | ResBookingCreateWithoutChannelInput[] | ResBookingUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ResBookingCreateOrConnectWithoutChannelInput | ResBookingCreateOrConnectWithoutChannelInput[]
    upsert?: ResBookingUpsertWithWhereUniqueWithoutChannelInput | ResBookingUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ResBookingCreateManyChannelInputEnvelope
    set?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    disconnect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    delete?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    connect?: ResBookingWhereUniqueInput | ResBookingWhereUniqueInput[]
    update?: ResBookingUpdateWithWhereUniqueWithoutChannelInput | ResBookingUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ResBookingUpdateManyWithWhereWithoutChannelInput | ResBookingUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
  }

  export type TableCreateNestedOneWithoutTableHoldsInput = {
    create?: XOR<TableCreateWithoutTableHoldsInput, TableUncheckedCreateWithoutTableHoldsInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableHoldsInput
    connect?: TableWhereUniqueInput
  }

  export type TableUpdateOneRequiredWithoutTableHoldsNestedInput = {
    create?: XOR<TableCreateWithoutTableHoldsInput, TableUncheckedCreateWithoutTableHoldsInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableHoldsInput
    upsert?: TableUpsertWithoutTableHoldsInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutTableHoldsInput, TableUpdateWithoutTableHoldsInput>, TableUncheckedUpdateWithoutTableHoldsInput>
  }

  export type RestaurantCreateNestedOneWithoutWaitlistInput = {
    create?: XOR<RestaurantCreateWithoutWaitlistInput, RestaurantUncheckedCreateWithoutWaitlistInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutWaitlistInput
    connect?: RestaurantWhereUniqueInput
  }

  export type RestaurantUpdateOneRequiredWithoutWaitlistNestedInput = {
    create?: XOR<RestaurantCreateWithoutWaitlistInput, RestaurantUncheckedCreateWithoutWaitlistInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutWaitlistInput
    upsert?: RestaurantUpsertWithoutWaitlistInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutWaitlistInput, RestaurantUpdateWithoutWaitlistInput>, RestaurantUncheckedUpdateWithoutWaitlistInput>
  }

  export type HotelCreateNestedOneWithoutWaitlistEntriesInput = {
    create?: XOR<HotelCreateWithoutWaitlistEntriesInput, HotelUncheckedCreateWithoutWaitlistEntriesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutWaitlistEntriesInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutWaitlistEntriesInput = {
    create?: XOR<RoomTypeCreateWithoutWaitlistEntriesInput, RoomTypeUncheckedCreateWithoutWaitlistEntriesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutWaitlistEntriesInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutWaitlistEntriesNestedInput = {
    create?: XOR<HotelCreateWithoutWaitlistEntriesInput, HotelUncheckedCreateWithoutWaitlistEntriesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutWaitlistEntriesInput
    upsert?: HotelUpsertWithoutWaitlistEntriesInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutWaitlistEntriesInput, HotelUpdateWithoutWaitlistEntriesInput>, HotelUncheckedUpdateWithoutWaitlistEntriesInput>
  }

  export type RoomTypeUpdateOneRequiredWithoutWaitlistEntriesNestedInput = {
    create?: XOR<RoomTypeCreateWithoutWaitlistEntriesInput, RoomTypeUncheckedCreateWithoutWaitlistEntriesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutWaitlistEntriesInput
    upsert?: RoomTypeUpsertWithoutWaitlistEntriesInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutWaitlistEntriesInput, RoomTypeUpdateWithoutWaitlistEntriesInput>, RoomTypeUncheckedUpdateWithoutWaitlistEntriesInput>
  }

  export type IdentityLinkCreateNestedManyWithoutCustomerProfileInput = {
    create?: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput> | IdentityLinkCreateWithoutCustomerProfileInput[] | IdentityLinkUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: IdentityLinkCreateOrConnectWithoutCustomerProfileInput | IdentityLinkCreateOrConnectWithoutCustomerProfileInput[]
    createMany?: IdentityLinkCreateManyCustomerProfileInputEnvelope
    connect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
  }

  export type WebVisitCreateNestedManyWithoutCustomerProfileInput = {
    create?: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput> | WebVisitCreateWithoutCustomerProfileInput[] | WebVisitUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: WebVisitCreateOrConnectWithoutCustomerProfileInput | WebVisitCreateOrConnectWithoutCustomerProfileInput[]
    createMany?: WebVisitCreateManyCustomerProfileInputEnvelope
    connect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
  }

  export type IdentityLinkUncheckedCreateNestedManyWithoutCustomerProfileInput = {
    create?: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput> | IdentityLinkCreateWithoutCustomerProfileInput[] | IdentityLinkUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: IdentityLinkCreateOrConnectWithoutCustomerProfileInput | IdentityLinkCreateOrConnectWithoutCustomerProfileInput[]
    createMany?: IdentityLinkCreateManyCustomerProfileInputEnvelope
    connect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
  }

  export type WebVisitUncheckedCreateNestedManyWithoutCustomerProfileInput = {
    create?: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput> | WebVisitCreateWithoutCustomerProfileInput[] | WebVisitUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: WebVisitCreateOrConnectWithoutCustomerProfileInput | WebVisitCreateOrConnectWithoutCustomerProfileInput[]
    createMany?: WebVisitCreateManyCustomerProfileInputEnvelope
    connect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
  }

  export type IdentityLinkUpdateManyWithoutCustomerProfileNestedInput = {
    create?: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput> | IdentityLinkCreateWithoutCustomerProfileInput[] | IdentityLinkUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: IdentityLinkCreateOrConnectWithoutCustomerProfileInput | IdentityLinkCreateOrConnectWithoutCustomerProfileInput[]
    upsert?: IdentityLinkUpsertWithWhereUniqueWithoutCustomerProfileInput | IdentityLinkUpsertWithWhereUniqueWithoutCustomerProfileInput[]
    createMany?: IdentityLinkCreateManyCustomerProfileInputEnvelope
    set?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    disconnect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    delete?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    connect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    update?: IdentityLinkUpdateWithWhereUniqueWithoutCustomerProfileInput | IdentityLinkUpdateWithWhereUniqueWithoutCustomerProfileInput[]
    updateMany?: IdentityLinkUpdateManyWithWhereWithoutCustomerProfileInput | IdentityLinkUpdateManyWithWhereWithoutCustomerProfileInput[]
    deleteMany?: IdentityLinkScalarWhereInput | IdentityLinkScalarWhereInput[]
  }

  export type WebVisitUpdateManyWithoutCustomerProfileNestedInput = {
    create?: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput> | WebVisitCreateWithoutCustomerProfileInput[] | WebVisitUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: WebVisitCreateOrConnectWithoutCustomerProfileInput | WebVisitCreateOrConnectWithoutCustomerProfileInput[]
    upsert?: WebVisitUpsertWithWhereUniqueWithoutCustomerProfileInput | WebVisitUpsertWithWhereUniqueWithoutCustomerProfileInput[]
    createMany?: WebVisitCreateManyCustomerProfileInputEnvelope
    set?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    disconnect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    delete?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    connect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    update?: WebVisitUpdateWithWhereUniqueWithoutCustomerProfileInput | WebVisitUpdateWithWhereUniqueWithoutCustomerProfileInput[]
    updateMany?: WebVisitUpdateManyWithWhereWithoutCustomerProfileInput | WebVisitUpdateManyWithWhereWithoutCustomerProfileInput[]
    deleteMany?: WebVisitScalarWhereInput | WebVisitScalarWhereInput[]
  }

  export type IdentityLinkUncheckedUpdateManyWithoutCustomerProfileNestedInput = {
    create?: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput> | IdentityLinkCreateWithoutCustomerProfileInput[] | IdentityLinkUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: IdentityLinkCreateOrConnectWithoutCustomerProfileInput | IdentityLinkCreateOrConnectWithoutCustomerProfileInput[]
    upsert?: IdentityLinkUpsertWithWhereUniqueWithoutCustomerProfileInput | IdentityLinkUpsertWithWhereUniqueWithoutCustomerProfileInput[]
    createMany?: IdentityLinkCreateManyCustomerProfileInputEnvelope
    set?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    disconnect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    delete?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    connect?: IdentityLinkWhereUniqueInput | IdentityLinkWhereUniqueInput[]
    update?: IdentityLinkUpdateWithWhereUniqueWithoutCustomerProfileInput | IdentityLinkUpdateWithWhereUniqueWithoutCustomerProfileInput[]
    updateMany?: IdentityLinkUpdateManyWithWhereWithoutCustomerProfileInput | IdentityLinkUpdateManyWithWhereWithoutCustomerProfileInput[]
    deleteMany?: IdentityLinkScalarWhereInput | IdentityLinkScalarWhereInput[]
  }

  export type WebVisitUncheckedUpdateManyWithoutCustomerProfileNestedInput = {
    create?: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput> | WebVisitCreateWithoutCustomerProfileInput[] | WebVisitUncheckedCreateWithoutCustomerProfileInput[]
    connectOrCreate?: WebVisitCreateOrConnectWithoutCustomerProfileInput | WebVisitCreateOrConnectWithoutCustomerProfileInput[]
    upsert?: WebVisitUpsertWithWhereUniqueWithoutCustomerProfileInput | WebVisitUpsertWithWhereUniqueWithoutCustomerProfileInput[]
    createMany?: WebVisitCreateManyCustomerProfileInputEnvelope
    set?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    disconnect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    delete?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    connect?: WebVisitWhereUniqueInput | WebVisitWhereUniqueInput[]
    update?: WebVisitUpdateWithWhereUniqueWithoutCustomerProfileInput | WebVisitUpdateWithWhereUniqueWithoutCustomerProfileInput[]
    updateMany?: WebVisitUpdateManyWithWhereWithoutCustomerProfileInput | WebVisitUpdateManyWithWhereWithoutCustomerProfileInput[]
    deleteMany?: WebVisitScalarWhereInput | WebVisitScalarWhereInput[]
  }

  export type CustomerProfileCreateNestedOneWithoutIdentityLinksInput = {
    create?: XOR<CustomerProfileCreateWithoutIdentityLinksInput, CustomerProfileUncheckedCreateWithoutIdentityLinksInput>
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutIdentityLinksInput
    connect?: CustomerProfileWhereUniqueInput
  }

  export type CustomerProfileUpdateOneRequiredWithoutIdentityLinksNestedInput = {
    create?: XOR<CustomerProfileCreateWithoutIdentityLinksInput, CustomerProfileUncheckedCreateWithoutIdentityLinksInput>
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutIdentityLinksInput
    upsert?: CustomerProfileUpsertWithoutIdentityLinksInput
    connect?: CustomerProfileWhereUniqueInput
    update?: XOR<XOR<CustomerProfileUpdateToOneWithWhereWithoutIdentityLinksInput, CustomerProfileUpdateWithoutIdentityLinksInput>, CustomerProfileUncheckedUpdateWithoutIdentityLinksInput>
  }

  export type CustomerProfileCreateNestedOneWithoutWebVisitsInput = {
    create?: XOR<CustomerProfileCreateWithoutWebVisitsInput, CustomerProfileUncheckedCreateWithoutWebVisitsInput>
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutWebVisitsInput
    connect?: CustomerProfileWhereUniqueInput
  }

  export type CustomerProfileUpdateOneWithoutWebVisitsNestedInput = {
    create?: XOR<CustomerProfileCreateWithoutWebVisitsInput, CustomerProfileUncheckedCreateWithoutWebVisitsInput>
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutWebVisitsInput
    upsert?: CustomerProfileUpsertWithoutWebVisitsInput
    disconnect?: CustomerProfileWhereInput | boolean
    delete?: CustomerProfileWhereInput | boolean
    connect?: CustomerProfileWhereUniqueInput
    update?: XOR<XOR<CustomerProfileUpdateToOneWithWhereWithoutWebVisitsInput, CustomerProfileUpdateWithoutWebVisitsInput>, CustomerProfileUncheckedUpdateWithoutWebVisitsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RoomTypeCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput>
  }

  export type RoomTypeCreateManyHotelInputEnvelope = {
    data: RoomTypeCreateManyHotelInput | RoomTypeCreateManyHotelInput[]
  }

  export type BookingCreateWithoutHotelInput = {
    id?: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    guest?: GuestCreateNestedOneWithoutBookingsInput
    bookingRooms?: BookingRoomCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutHotelInput = {
    id?: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutHotelInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput>
  }

  export type BookingCreateManyHotelInputEnvelope = {
    data: BookingCreateManyHotelInput | BookingCreateManyHotelInput[]
  }

  export type RatePlanCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUncheckedCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanCreateOrConnectWithoutHotelInput = {
    where: RatePlanWhereUniqueInput
    create: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput>
  }

  export type RatePlanCreateManyHotelInputEnvelope = {
    data: RatePlanCreateManyHotelInput | RatePlanCreateManyHotelInput[]
  }

  export type SeasonCreateWithoutHotelInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
  }

  export type SeasonUncheckedCreateWithoutHotelInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
  }

  export type SeasonCreateOrConnectWithoutHotelInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput>
  }

  export type SeasonCreateManyHotelInputEnvelope = {
    data: SeasonCreateManyHotelInput | SeasonCreateManyHotelInput[]
  }

  export type UserCreateWithoutHotelInput = {
    id?: string
    email: string
    password: string
    role?: string
  }

  export type UserUncheckedCreateWithoutHotelInput = {
    id?: string
    email: string
    password: string
    role?: string
  }

  export type UserCreateOrConnectWithoutHotelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput>
  }

  export type UserCreateManyHotelInputEnvelope = {
    data: UserCreateManyHotelInput | UserCreateManyHotelInput[]
  }

  export type WidgetConfigCreateWithoutHotelInput = {
    id?: string
    primaryColor?: string
    secondaryColor?: string
    customCss?: string | null
    showLogo?: boolean
    title?: string | null
  }

  export type WidgetConfigUncheckedCreateWithoutHotelInput = {
    id?: string
    primaryColor?: string
    secondaryColor?: string
    customCss?: string | null
    showLogo?: boolean
    title?: string | null
  }

  export type WidgetConfigCreateOrConnectWithoutHotelInput = {
    where: WidgetConfigWhereUniqueInput
    create: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
  }

  export type RestrictionCreateWithoutHotelInput = {
    id?: string
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    roomType?: RoomTypeCreateNestedOneWithoutRestrictionsInput
    ratePlan?: RatePlanCreateNestedOneWithoutRestrictionsInput
  }

  export type RestrictionUncheckedCreateWithoutHotelInput = {
    id?: string
    roomTypeId?: string | null
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionCreateOrConnectWithoutHotelInput = {
    where: RestrictionWhereUniqueInput
    create: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput>
  }

  export type RestrictionCreateManyHotelInputEnvelope = {
    data: RestrictionCreateManyHotelInput | RestrictionCreateManyHotelInput[]
  }

  export type HotelWaitlistCreateWithoutHotelInput = {
    id?: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
    roomType: RoomTypeCreateNestedOneWithoutWaitlistEntriesInput
  }

  export type HotelWaitlistUncheckedCreateWithoutHotelInput = {
    id?: string
    roomTypeId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type HotelWaitlistCreateOrConnectWithoutHotelInput = {
    where: HotelWaitlistWhereUniqueInput
    create: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput>
  }

  export type HotelWaitlistCreateManyHotelInputEnvelope = {
    data: HotelWaitlistCreateManyHotelInput | HotelWaitlistCreateManyHotelInput[]
  }

  export type RoomTypeUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    update: XOR<RoomTypeUpdateWithoutHotelInput, RoomTypeUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput>
  }

  export type RoomTypeUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    data: XOR<RoomTypeUpdateWithoutHotelInput, RoomTypeUncheckedUpdateWithoutHotelInput>
  }

  export type RoomTypeUpdateManyWithWhereWithoutHotelInput = {
    where: RoomTypeScalarWhereInput
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomTypeScalarWhereInput = {
    AND?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
    OR?: RoomTypeScalarWhereInput[]
    NOT?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
    id?: StringFilter<"RoomType"> | string
    hotelId?: StringFilter<"RoomType"> | string
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    basePrice?: DecimalFilter<"RoomType"> | Decimal | DecimalJsLike | number | string
    capacity?: IntFilter<"RoomType"> | number
    amenities?: StringNullableFilter<"RoomType"> | string | null
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutHotelInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutHotelInput, BookingUncheckedUpdateWithoutHotelInput>
    create: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutHotelInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutHotelInput, BookingUncheckedUpdateWithoutHotelInput>
  }

  export type BookingUpdateManyWithWhereWithoutHotelInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutHotelInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    hotelId?: StringFilter<"Booking"> | string
    referenceCode?: StringFilter<"Booking"> | string
    guestId?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    status?: StringFilter<"Booking"> | string
    source?: StringFilter<"Booking"> | string
    totalPrice?: DecimalFilter<"Booking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Booking"> | string
    isPaid?: BoolFilter<"Booking"> | boolean
    stripeCustomerId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"Booking"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Booking"> | string | null
    checkInDate?: DateTimeFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeFilter<"Booking"> | Date | string
    nights?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    otaId?: StringNullableFilter<"Booking"> | string | null
    otaRawData?: StringNullableFilter<"Booking"> | string | null
  }

  export type RatePlanUpsertWithWhereUniqueWithoutHotelInput = {
    where: RatePlanWhereUniqueInput
    update: XOR<RatePlanUpdateWithoutHotelInput, RatePlanUncheckedUpdateWithoutHotelInput>
    create: XOR<RatePlanCreateWithoutHotelInput, RatePlanUncheckedCreateWithoutHotelInput>
  }

  export type RatePlanUpdateWithWhereUniqueWithoutHotelInput = {
    where: RatePlanWhereUniqueInput
    data: XOR<RatePlanUpdateWithoutHotelInput, RatePlanUncheckedUpdateWithoutHotelInput>
  }

  export type RatePlanUpdateManyWithWhereWithoutHotelInput = {
    where: RatePlanScalarWhereInput
    data: XOR<RatePlanUpdateManyMutationInput, RatePlanUncheckedUpdateManyWithoutHotelInput>
  }

  export type RatePlanScalarWhereInput = {
    AND?: RatePlanScalarWhereInput | RatePlanScalarWhereInput[]
    OR?: RatePlanScalarWhereInput[]
    NOT?: RatePlanScalarWhereInput | RatePlanScalarWhereInput[]
    id?: StringFilter<"RatePlan"> | string
    hotelId?: StringFilter<"RatePlan"> | string
    name?: StringFilter<"RatePlan"> | string
    description?: StringNullableFilter<"RatePlan"> | string | null
    isDefault?: BoolFilter<"RatePlan"> | boolean
    cancellationPolicy?: StringNullableFilter<"RatePlan"> | string | null
    mealsIncluded?: StringNullableFilter<"RatePlan"> | string | null
    requireCreditCard?: BoolFilter<"RatePlan"> | boolean
    noShowFee?: DecimalFilter<"RatePlan"> | Decimal | DecimalJsLike | number | string
  }

  export type SeasonUpsertWithWhereUniqueWithoutHotelInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutHotelInput, SeasonUncheckedUpdateWithoutHotelInput>
    create: XOR<SeasonCreateWithoutHotelInput, SeasonUncheckedCreateWithoutHotelInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutHotelInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutHotelInput, SeasonUncheckedUpdateWithoutHotelInput>
  }

  export type SeasonUpdateManyWithWhereWithoutHotelInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutHotelInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: StringFilter<"Season"> | string
    hotelId?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    priceMultiplier?: DecimalFilter<"Season"> | Decimal | DecimalJsLike | number | string
  }

  export type UserUpsertWithWhereUniqueWithoutHotelInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutHotelInput, UserUncheckedUpdateWithoutHotelInput>
    create: XOR<UserCreateWithoutHotelInput, UserUncheckedCreateWithoutHotelInput>
  }

  export type UserUpdateWithWhereUniqueWithoutHotelInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutHotelInput, UserUncheckedUpdateWithoutHotelInput>
  }

  export type UserUpdateManyWithWhereWithoutHotelInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutHotelInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    hotelId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
  }

  export type WidgetConfigUpsertWithoutHotelInput = {
    update: XOR<WidgetConfigUpdateWithoutHotelInput, WidgetConfigUncheckedUpdateWithoutHotelInput>
    create: XOR<WidgetConfigCreateWithoutHotelInput, WidgetConfigUncheckedCreateWithoutHotelInput>
    where?: WidgetConfigWhereInput
  }

  export type WidgetConfigUpdateToOneWithWhereWithoutHotelInput = {
    where?: WidgetConfigWhereInput
    data: XOR<WidgetConfigUpdateWithoutHotelInput, WidgetConfigUncheckedUpdateWithoutHotelInput>
  }

  export type WidgetConfigUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WidgetConfigUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    customCss?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestrictionUpsertWithWhereUniqueWithoutHotelInput = {
    where: RestrictionWhereUniqueInput
    update: XOR<RestrictionUpdateWithoutHotelInput, RestrictionUncheckedUpdateWithoutHotelInput>
    create: XOR<RestrictionCreateWithoutHotelInput, RestrictionUncheckedCreateWithoutHotelInput>
  }

  export type RestrictionUpdateWithWhereUniqueWithoutHotelInput = {
    where: RestrictionWhereUniqueInput
    data: XOR<RestrictionUpdateWithoutHotelInput, RestrictionUncheckedUpdateWithoutHotelInput>
  }

  export type RestrictionUpdateManyWithWhereWithoutHotelInput = {
    where: RestrictionScalarWhereInput
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyWithoutHotelInput>
  }

  export type RestrictionScalarWhereInput = {
    AND?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
    OR?: RestrictionScalarWhereInput[]
    NOT?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
    id?: StringFilter<"Restriction"> | string
    hotelId?: StringFilter<"Restriction"> | string
    roomTypeId?: StringNullableFilter<"Restriction"> | string | null
    ratePlanId?: StringNullableFilter<"Restriction"> | string | null
    date?: DateTimeFilter<"Restriction"> | Date | string
    minStay?: IntNullableFilter<"Restriction"> | number | null
    maxStay?: IntNullableFilter<"Restriction"> | number | null
    closedToArrival?: BoolFilter<"Restriction"> | boolean
    closedToDeparture?: BoolFilter<"Restriction"> | boolean
    stopSell?: BoolFilter<"Restriction"> | boolean
  }

  export type HotelWaitlistUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelWaitlistWhereUniqueInput
    update: XOR<HotelWaitlistUpdateWithoutHotelInput, HotelWaitlistUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelWaitlistCreateWithoutHotelInput, HotelWaitlistUncheckedCreateWithoutHotelInput>
  }

  export type HotelWaitlistUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelWaitlistWhereUniqueInput
    data: XOR<HotelWaitlistUpdateWithoutHotelInput, HotelWaitlistUncheckedUpdateWithoutHotelInput>
  }

  export type HotelWaitlistUpdateManyWithWhereWithoutHotelInput = {
    where: HotelWaitlistScalarWhereInput
    data: XOR<HotelWaitlistUpdateManyMutationInput, HotelWaitlistUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelWaitlistScalarWhereInput = {
    AND?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
    OR?: HotelWaitlistScalarWhereInput[]
    NOT?: HotelWaitlistScalarWhereInput | HotelWaitlistScalarWhereInput[]
    id?: StringFilter<"HotelWaitlist"> | string
    hotelId?: StringFilter<"HotelWaitlist"> | string
    roomTypeId?: StringFilter<"HotelWaitlist"> | string
    email?: StringFilter<"HotelWaitlist"> | string
    dateFrom?: DateTimeFilter<"HotelWaitlist"> | Date | string
    dateTo?: DateTimeFilter<"HotelWaitlist"> | Date | string
    requestDate?: DateTimeFilter<"HotelWaitlist"> | Date | string
    fulfilled?: BoolFilter<"HotelWaitlist"> | boolean
  }

  export type HotelCreateWithoutWidgetConfigInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutWidgetConfigInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutWidgetConfigInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutWidgetConfigInput, HotelUncheckedCreateWithoutWidgetConfigInput>
  }

  export type HotelUpsertWithoutWidgetConfigInput = {
    update: XOR<HotelUpdateWithoutWidgetConfigInput, HotelUncheckedUpdateWithoutWidgetConfigInput>
    create: XOR<HotelCreateWithoutWidgetConfigInput, HotelUncheckedCreateWithoutWidgetConfigInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutWidgetConfigInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutWidgetConfigInput, HotelUncheckedUpdateWithoutWidgetConfigInput>
  }

  export type HotelUpdateWithoutWidgetConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutWidgetConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateWithoutRoomTypesInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomTypesInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomTypesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
  }

  export type RoomCreateWithoutRoomTypeInput = {
    id?: string
    name: string
    isActive?: boolean
    bookingRooms?: BookingRoomCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    name: string
    isActive?: boolean
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomCreateManyRoomTypeInputEnvelope = {
    data: RoomCreateManyRoomTypeInput | RoomCreateManyRoomTypeInput[]
  }

  export type ICalFeedCreateWithoutRoomTypeInput = {
    id?: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
  }

  export type ICalFeedUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
  }

  export type ICalFeedCreateOrConnectWithoutRoomTypeInput = {
    where: ICalFeedWhereUniqueInput
    create: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput>
  }

  export type ICalFeedCreateManyRoomTypeInputEnvelope = {
    data: ICalFeedCreateManyRoomTypeInput | ICalFeedCreateManyRoomTypeInput[]
  }

  export type DailyPriceCreateWithoutRoomTypeInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    ratePlan: RatePlanCreateNestedOneWithoutDailyPricesInput
  }

  export type DailyPriceUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    ratePlanId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceCreateOrConnectWithoutRoomTypeInput = {
    where: DailyPriceWhereUniqueInput
    create: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput>
  }

  export type DailyPriceCreateManyRoomTypeInputEnvelope = {
    data: DailyPriceCreateManyRoomTypeInput | DailyPriceCreateManyRoomTypeInput[]
  }

  export type RestrictionCreateWithoutRoomTypeInput = {
    id?: string
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    hotel: HotelCreateNestedOneWithoutRestrictionsInput
    ratePlan?: RatePlanCreateNestedOneWithoutRestrictionsInput
  }

  export type RestrictionUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    hotelId: string
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionCreateOrConnectWithoutRoomTypeInput = {
    where: RestrictionWhereUniqueInput
    create: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput>
  }

  export type RestrictionCreateManyRoomTypeInputEnvelope = {
    data: RestrictionCreateManyRoomTypeInput | RestrictionCreateManyRoomTypeInput[]
  }

  export type ChannelMappingCreateWithoutRoomTypeInput = {
    id?: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
    channel: ChannelCreateNestedOneWithoutMappingsInput
    ratePlan?: RatePlanCreateNestedOneWithoutChannelMappingsInput
  }

  export type ChannelMappingUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    channelId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingCreateOrConnectWithoutRoomTypeInput = {
    where: ChannelMappingWhereUniqueInput
    create: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput>
  }

  export type ChannelMappingCreateManyRoomTypeInputEnvelope = {
    data: ChannelMappingCreateManyRoomTypeInput | ChannelMappingCreateManyRoomTypeInput[]
  }

  export type HotelWaitlistCreateWithoutRoomTypeInput = {
    id?: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
    hotel: HotelCreateNestedOneWithoutWaitlistEntriesInput
  }

  export type HotelWaitlistUncheckedCreateWithoutRoomTypeInput = {
    id?: string
    hotelId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type HotelWaitlistCreateOrConnectWithoutRoomTypeInput = {
    where: HotelWaitlistWhereUniqueInput
    create: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput>
  }

  export type HotelWaitlistCreateManyRoomTypeInputEnvelope = {
    data: HotelWaitlistCreateManyRoomTypeInput | HotelWaitlistCreateManyRoomTypeInput[]
  }

  export type HotelUpsertWithoutRoomTypesInput = {
    update: XOR<HotelUpdateWithoutRoomTypesInput, HotelUncheckedUpdateWithoutRoomTypesInput>
    create: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomTypesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomTypesInput, HotelUncheckedUpdateWithoutRoomTypesInput>
  }

  export type HotelUpdateWithoutRoomTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    roomTypeId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    isActive?: BoolFilter<"Room"> | boolean
  }

  export type ICalFeedUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: ICalFeedWhereUniqueInput
    update: XOR<ICalFeedUpdateWithoutRoomTypeInput, ICalFeedUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<ICalFeedCreateWithoutRoomTypeInput, ICalFeedUncheckedCreateWithoutRoomTypeInput>
  }

  export type ICalFeedUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: ICalFeedWhereUniqueInput
    data: XOR<ICalFeedUpdateWithoutRoomTypeInput, ICalFeedUncheckedUpdateWithoutRoomTypeInput>
  }

  export type ICalFeedUpdateManyWithWhereWithoutRoomTypeInput = {
    where: ICalFeedScalarWhereInput
    data: XOR<ICalFeedUpdateManyMutationInput, ICalFeedUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type ICalFeedScalarWhereInput = {
    AND?: ICalFeedScalarWhereInput | ICalFeedScalarWhereInput[]
    OR?: ICalFeedScalarWhereInput[]
    NOT?: ICalFeedScalarWhereInput | ICalFeedScalarWhereInput[]
    id?: StringFilter<"ICalFeed"> | string
    roomTypeId?: StringFilter<"ICalFeed"> | string
    url?: StringFilter<"ICalFeed"> | string
    name?: StringNullableFilter<"ICalFeed"> | string | null
    source?: StringFilter<"ICalFeed"> | string
    lastSync?: DateTimeNullableFilter<"ICalFeed"> | Date | string | null
    isActive?: BoolFilter<"ICalFeed"> | boolean
  }

  export type DailyPriceUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: DailyPriceWhereUniqueInput
    update: XOR<DailyPriceUpdateWithoutRoomTypeInput, DailyPriceUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<DailyPriceCreateWithoutRoomTypeInput, DailyPriceUncheckedCreateWithoutRoomTypeInput>
  }

  export type DailyPriceUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: DailyPriceWhereUniqueInput
    data: XOR<DailyPriceUpdateWithoutRoomTypeInput, DailyPriceUncheckedUpdateWithoutRoomTypeInput>
  }

  export type DailyPriceUpdateManyWithWhereWithoutRoomTypeInput = {
    where: DailyPriceScalarWhereInput
    data: XOR<DailyPriceUpdateManyMutationInput, DailyPriceUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type DailyPriceScalarWhereInput = {
    AND?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
    OR?: DailyPriceScalarWhereInput[]
    NOT?: DailyPriceScalarWhereInput | DailyPriceScalarWhereInput[]
    id?: StringFilter<"DailyPrice"> | string
    roomTypeId?: StringFilter<"DailyPrice"> | string
    ratePlanId?: StringFilter<"DailyPrice"> | string
    date?: DateTimeFilter<"DailyPrice"> | Date | string
    price?: DecimalFilter<"DailyPrice"> | Decimal | DecimalJsLike | number | string
  }

  export type RestrictionUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RestrictionWhereUniqueInput
    update: XOR<RestrictionUpdateWithoutRoomTypeInput, RestrictionUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RestrictionCreateWithoutRoomTypeInput, RestrictionUncheckedCreateWithoutRoomTypeInput>
  }

  export type RestrictionUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RestrictionWhereUniqueInput
    data: XOR<RestrictionUpdateWithoutRoomTypeInput, RestrictionUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RestrictionUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RestrictionScalarWhereInput
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type ChannelMappingUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: ChannelMappingWhereUniqueInput
    update: XOR<ChannelMappingUpdateWithoutRoomTypeInput, ChannelMappingUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<ChannelMappingCreateWithoutRoomTypeInput, ChannelMappingUncheckedCreateWithoutRoomTypeInput>
  }

  export type ChannelMappingUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: ChannelMappingWhereUniqueInput
    data: XOR<ChannelMappingUpdateWithoutRoomTypeInput, ChannelMappingUncheckedUpdateWithoutRoomTypeInput>
  }

  export type ChannelMappingUpdateManyWithWhereWithoutRoomTypeInput = {
    where: ChannelMappingScalarWhereInput
    data: XOR<ChannelMappingUpdateManyMutationInput, ChannelMappingUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type ChannelMappingScalarWhereInput = {
    AND?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
    OR?: ChannelMappingScalarWhereInput[]
    NOT?: ChannelMappingScalarWhereInput | ChannelMappingScalarWhereInput[]
    id?: StringFilter<"ChannelMapping"> | string
    channelId?: StringFilter<"ChannelMapping"> | string
    roomTypeId?: StringFilter<"ChannelMapping"> | string
    ratePlanId?: StringNullableFilter<"ChannelMapping"> | string | null
    externalId?: StringFilter<"ChannelMapping"> | string
    externalName?: StringNullableFilter<"ChannelMapping"> | string | null
    syncEnabled?: BoolFilter<"ChannelMapping"> | boolean
  }

  export type HotelWaitlistUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: HotelWaitlistWhereUniqueInput
    update: XOR<HotelWaitlistUpdateWithoutRoomTypeInput, HotelWaitlistUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<HotelWaitlistCreateWithoutRoomTypeInput, HotelWaitlistUncheckedCreateWithoutRoomTypeInput>
  }

  export type HotelWaitlistUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: HotelWaitlistWhereUniqueInput
    data: XOR<HotelWaitlistUpdateWithoutRoomTypeInput, HotelWaitlistUncheckedUpdateWithoutRoomTypeInput>
  }

  export type HotelWaitlistUpdateManyWithWhereWithoutRoomTypeInput = {
    where: HotelWaitlistScalarWhereInput
    data: XOR<HotelWaitlistUpdateManyMutationInput, HotelWaitlistUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomTypeCreateWithoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutRoomsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutRoomsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
  }

  export type BookingRoomCreateWithoutRoomInput = {
    id?: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
    booking: BookingCreateNestedOneWithoutBookingRoomsInput
  }

  export type BookingRoomUncheckedCreateWithoutRoomInput = {
    id?: string
    bookingId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type BookingRoomCreateOrConnectWithoutRoomInput = {
    where: BookingRoomWhereUniqueInput
    create: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput>
  }

  export type BookingRoomCreateManyRoomInputEnvelope = {
    data: BookingRoomCreateManyRoomInput | BookingRoomCreateManyRoomInput[]
  }

  export type RoomTypeUpsertWithoutRoomsInput = {
    update: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutRoomsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomTypeUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type BookingRoomUpsertWithWhereUniqueWithoutRoomInput = {
    where: BookingRoomWhereUniqueInput
    update: XOR<BookingRoomUpdateWithoutRoomInput, BookingRoomUncheckedUpdateWithoutRoomInput>
    create: XOR<BookingRoomCreateWithoutRoomInput, BookingRoomUncheckedCreateWithoutRoomInput>
  }

  export type BookingRoomUpdateWithWhereUniqueWithoutRoomInput = {
    where: BookingRoomWhereUniqueInput
    data: XOR<BookingRoomUpdateWithoutRoomInput, BookingRoomUncheckedUpdateWithoutRoomInput>
  }

  export type BookingRoomUpdateManyWithWhereWithoutRoomInput = {
    where: BookingRoomScalarWhereInput
    data: XOR<BookingRoomUpdateManyMutationInput, BookingRoomUncheckedUpdateManyWithoutRoomInput>
  }

  export type BookingRoomScalarWhereInput = {
    AND?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
    OR?: BookingRoomScalarWhereInput[]
    NOT?: BookingRoomScalarWhereInput | BookingRoomScalarWhereInput[]
    id?: StringFilter<"BookingRoom"> | string
    bookingId?: StringFilter<"BookingRoom"> | string
    roomId?: StringFilter<"BookingRoom"> | string
    priceSnapshot?: DecimalFilter<"BookingRoom"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"BookingRoom"> | Date | string
  }

  export type BookingCreateWithoutGuestInput = {
    id?: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    hotel: HotelCreateNestedOneWithoutBookingsInput
    bookingRooms?: BookingRoomCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutGuestInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutGuestInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput>
  }

  export type BookingCreateManyGuestInputEnvelope = {
    data: BookingCreateManyGuestInput | BookingCreateManyGuestInput[]
  }

  export type BookingUpsertWithWhereUniqueWithoutGuestInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutGuestInput, BookingUncheckedUpdateWithoutGuestInput>
    create: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutGuestInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutGuestInput, BookingUncheckedUpdateWithoutGuestInput>
  }

  export type BookingUpdateManyWithWhereWithoutGuestInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutGuestInput>
  }

  export type HotelCreateWithoutRatePlansInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRatePlansInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRatePlansInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRatePlansInput, HotelUncheckedCreateWithoutRatePlansInput>
  }

  export type DailyPriceCreateWithoutRatePlanInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    roomType: RoomTypeCreateNestedOneWithoutDailyPricesInput
  }

  export type DailyPriceUncheckedCreateWithoutRatePlanInput = {
    id?: string
    roomTypeId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceCreateOrConnectWithoutRatePlanInput = {
    where: DailyPriceWhereUniqueInput
    create: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput>
  }

  export type DailyPriceCreateManyRatePlanInputEnvelope = {
    data: DailyPriceCreateManyRatePlanInput | DailyPriceCreateManyRatePlanInput[]
  }

  export type RestrictionCreateWithoutRatePlanInput = {
    id?: string
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
    hotel: HotelCreateNestedOneWithoutRestrictionsInput
    roomType?: RoomTypeCreateNestedOneWithoutRestrictionsInput
  }

  export type RestrictionUncheckedCreateWithoutRatePlanInput = {
    id?: string
    hotelId: string
    roomTypeId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type RestrictionCreateOrConnectWithoutRatePlanInput = {
    where: RestrictionWhereUniqueInput
    create: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput>
  }

  export type RestrictionCreateManyRatePlanInputEnvelope = {
    data: RestrictionCreateManyRatePlanInput | RestrictionCreateManyRatePlanInput[]
  }

  export type ChannelMappingCreateWithoutRatePlanInput = {
    id?: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
    channel: ChannelCreateNestedOneWithoutMappingsInput
    roomType: RoomTypeCreateNestedOneWithoutChannelMappingsInput
  }

  export type ChannelMappingUncheckedCreateWithoutRatePlanInput = {
    id?: string
    channelId: string
    roomTypeId: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingCreateOrConnectWithoutRatePlanInput = {
    where: ChannelMappingWhereUniqueInput
    create: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput>
  }

  export type ChannelMappingCreateManyRatePlanInputEnvelope = {
    data: ChannelMappingCreateManyRatePlanInput | ChannelMappingCreateManyRatePlanInput[]
  }

  export type HotelUpsertWithoutRatePlansInput = {
    update: XOR<HotelUpdateWithoutRatePlansInput, HotelUncheckedUpdateWithoutRatePlansInput>
    create: XOR<HotelCreateWithoutRatePlansInput, HotelUncheckedCreateWithoutRatePlansInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRatePlansInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRatePlansInput, HotelUncheckedUpdateWithoutRatePlansInput>
  }

  export type HotelUpdateWithoutRatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type DailyPriceUpsertWithWhereUniqueWithoutRatePlanInput = {
    where: DailyPriceWhereUniqueInput
    update: XOR<DailyPriceUpdateWithoutRatePlanInput, DailyPriceUncheckedUpdateWithoutRatePlanInput>
    create: XOR<DailyPriceCreateWithoutRatePlanInput, DailyPriceUncheckedCreateWithoutRatePlanInput>
  }

  export type DailyPriceUpdateWithWhereUniqueWithoutRatePlanInput = {
    where: DailyPriceWhereUniqueInput
    data: XOR<DailyPriceUpdateWithoutRatePlanInput, DailyPriceUncheckedUpdateWithoutRatePlanInput>
  }

  export type DailyPriceUpdateManyWithWhereWithoutRatePlanInput = {
    where: DailyPriceScalarWhereInput
    data: XOR<DailyPriceUpdateManyMutationInput, DailyPriceUncheckedUpdateManyWithoutRatePlanInput>
  }

  export type RestrictionUpsertWithWhereUniqueWithoutRatePlanInput = {
    where: RestrictionWhereUniqueInput
    update: XOR<RestrictionUpdateWithoutRatePlanInput, RestrictionUncheckedUpdateWithoutRatePlanInput>
    create: XOR<RestrictionCreateWithoutRatePlanInput, RestrictionUncheckedCreateWithoutRatePlanInput>
  }

  export type RestrictionUpdateWithWhereUniqueWithoutRatePlanInput = {
    where: RestrictionWhereUniqueInput
    data: XOR<RestrictionUpdateWithoutRatePlanInput, RestrictionUncheckedUpdateWithoutRatePlanInput>
  }

  export type RestrictionUpdateManyWithWhereWithoutRatePlanInput = {
    where: RestrictionScalarWhereInput
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyWithoutRatePlanInput>
  }

  export type ChannelMappingUpsertWithWhereUniqueWithoutRatePlanInput = {
    where: ChannelMappingWhereUniqueInput
    update: XOR<ChannelMappingUpdateWithoutRatePlanInput, ChannelMappingUncheckedUpdateWithoutRatePlanInput>
    create: XOR<ChannelMappingCreateWithoutRatePlanInput, ChannelMappingUncheckedCreateWithoutRatePlanInput>
  }

  export type ChannelMappingUpdateWithWhereUniqueWithoutRatePlanInput = {
    where: ChannelMappingWhereUniqueInput
    data: XOR<ChannelMappingUpdateWithoutRatePlanInput, ChannelMappingUncheckedUpdateWithoutRatePlanInput>
  }

  export type ChannelMappingUpdateManyWithWhereWithoutRatePlanInput = {
    where: ChannelMappingScalarWhereInput
    data: XOR<ChannelMappingUpdateManyMutationInput, ChannelMappingUncheckedUpdateManyWithoutRatePlanInput>
  }

  export type HotelCreateWithoutSeasonsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutSeasonsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutSeasonsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutSeasonsInput, HotelUncheckedCreateWithoutSeasonsInput>
  }

  export type HotelUpsertWithoutSeasonsInput = {
    update: XOR<HotelUpdateWithoutSeasonsInput, HotelUncheckedUpdateWithoutSeasonsInput>
    create: XOR<HotelCreateWithoutSeasonsInput, HotelUncheckedCreateWithoutSeasonsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutSeasonsInput, HotelUncheckedUpdateWithoutSeasonsInput>
  }

  export type HotelUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeCreateWithoutDailyPricesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutDailyPricesInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutDailyPricesInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutDailyPricesInput, RoomTypeUncheckedCreateWithoutDailyPricesInput>
  }

  export type RatePlanCreateWithoutDailyPricesInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    hotel: HotelCreateNestedOneWithoutRatePlansInput
    restrictions?: RestrictionCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUncheckedCreateWithoutDailyPricesInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanCreateOrConnectWithoutDailyPricesInput = {
    where: RatePlanWhereUniqueInput
    create: XOR<RatePlanCreateWithoutDailyPricesInput, RatePlanUncheckedCreateWithoutDailyPricesInput>
  }

  export type RoomTypeUpsertWithoutDailyPricesInput = {
    update: XOR<RoomTypeUpdateWithoutDailyPricesInput, RoomTypeUncheckedUpdateWithoutDailyPricesInput>
    create: XOR<RoomTypeCreateWithoutDailyPricesInput, RoomTypeUncheckedCreateWithoutDailyPricesInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutDailyPricesInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutDailyPricesInput, RoomTypeUncheckedUpdateWithoutDailyPricesInput>
  }

  export type RoomTypeUpdateWithoutDailyPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutDailyPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RatePlanUpsertWithoutDailyPricesInput = {
    update: XOR<RatePlanUpdateWithoutDailyPricesInput, RatePlanUncheckedUpdateWithoutDailyPricesInput>
    create: XOR<RatePlanCreateWithoutDailyPricesInput, RatePlanUncheckedCreateWithoutDailyPricesInput>
    where?: RatePlanWhereInput
  }

  export type RatePlanUpdateToOneWithWhereWithoutDailyPricesInput = {
    where?: RatePlanWhereInput
    data: XOR<RatePlanUpdateWithoutDailyPricesInput, RatePlanUncheckedUpdateWithoutDailyPricesInput>
  }

  export type RatePlanUpdateWithoutDailyPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hotel?: HotelUpdateOneRequiredWithoutRatePlansNestedInput
    restrictions?: RestrictionUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateWithoutDailyPricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    restrictions?: RestrictionUncheckedUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRatePlanNestedInput
  }

  export type HotelCreateWithoutRestrictionsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRestrictionsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRestrictionsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRestrictionsInput, HotelUncheckedCreateWithoutRestrictionsInput>
  }

  export type RoomTypeCreateWithoutRestrictionsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutRestrictionsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutRestrictionsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutRestrictionsInput, RoomTypeUncheckedCreateWithoutRestrictionsInput>
  }

  export type RatePlanCreateWithoutRestrictionsInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    hotel: HotelCreateNestedOneWithoutRatePlansInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUncheckedCreateWithoutRestrictionsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRatePlanInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanCreateOrConnectWithoutRestrictionsInput = {
    where: RatePlanWhereUniqueInput
    create: XOR<RatePlanCreateWithoutRestrictionsInput, RatePlanUncheckedCreateWithoutRestrictionsInput>
  }

  export type HotelUpsertWithoutRestrictionsInput = {
    update: XOR<HotelUpdateWithoutRestrictionsInput, HotelUncheckedUpdateWithoutRestrictionsInput>
    create: XOR<HotelCreateWithoutRestrictionsInput, HotelUncheckedCreateWithoutRestrictionsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRestrictionsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRestrictionsInput, HotelUncheckedUpdateWithoutRestrictionsInput>
  }

  export type HotelUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeUpsertWithoutRestrictionsInput = {
    update: XOR<RoomTypeUpdateWithoutRestrictionsInput, RoomTypeUncheckedUpdateWithoutRestrictionsInput>
    create: XOR<RoomTypeCreateWithoutRestrictionsInput, RoomTypeUncheckedCreateWithoutRestrictionsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutRestrictionsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutRestrictionsInput, RoomTypeUncheckedUpdateWithoutRestrictionsInput>
  }

  export type RoomTypeUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RatePlanUpsertWithoutRestrictionsInput = {
    update: XOR<RatePlanUpdateWithoutRestrictionsInput, RatePlanUncheckedUpdateWithoutRestrictionsInput>
    create: XOR<RatePlanCreateWithoutRestrictionsInput, RatePlanUncheckedCreateWithoutRestrictionsInput>
    where?: RatePlanWhereInput
  }

  export type RatePlanUpdateToOneWithWhereWithoutRestrictionsInput = {
    where?: RatePlanWhereInput
    data: XOR<RatePlanUpdateWithoutRestrictionsInput, RatePlanUncheckedUpdateWithoutRestrictionsInput>
  }

  export type RatePlanUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hotel?: HotelUpdateOneRequiredWithoutRatePlansNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRatePlanNestedInput
  }

  export type HotelCreateWithoutBookingsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutBookingsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
  }

  export type GuestCreateWithoutBookingsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    docType?: string | null
    docNumber?: string | null
    country?: string | null
    notes?: string | null
    score?: number
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestUncheckedCreateWithoutBookingsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    email?: string | null
    phone?: string | null
    docType?: string | null
    docNumber?: string | null
    country?: string | null
    notes?: string | null
    score?: number
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuestCreateOrConnectWithoutBookingsInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutBookingsInput, GuestUncheckedCreateWithoutBookingsInput>
  }

  export type BookingRoomCreateWithoutBookingInput = {
    id?: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
    room: RoomCreateNestedOneWithoutBookingRoomsInput
  }

  export type BookingRoomUncheckedCreateWithoutBookingInput = {
    id?: string
    roomId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type BookingRoomCreateOrConnectWithoutBookingInput = {
    where: BookingRoomWhereUniqueInput
    create: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput>
  }

  export type BookingRoomCreateManyBookingInputEnvelope = {
    data: BookingRoomCreateManyBookingInput | BookingRoomCreateManyBookingInput[]
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
  }

  export type HotelUpsertWithoutBookingsInput = {
    update: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type GuestUpsertWithoutBookingsInput = {
    update: XOR<GuestUpdateWithoutBookingsInput, GuestUncheckedUpdateWithoutBookingsInput>
    create: XOR<GuestCreateWithoutBookingsInput, GuestUncheckedCreateWithoutBookingsInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutBookingsInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutBookingsInput, GuestUncheckedUpdateWithoutBookingsInput>
  }

  export type GuestUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    docType?: NullableStringFieldUpdateOperationsInput | string | null
    docNumber?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRoomUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingRoomWhereUniqueInput
    update: XOR<BookingRoomUpdateWithoutBookingInput, BookingRoomUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingRoomCreateWithoutBookingInput, BookingRoomUncheckedCreateWithoutBookingInput>
  }

  export type BookingRoomUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingRoomWhereUniqueInput
    data: XOR<BookingRoomUpdateWithoutBookingInput, BookingRoomUncheckedUpdateWithoutBookingInput>
  }

  export type BookingRoomUpdateManyWithWhereWithoutBookingInput = {
    where: BookingRoomScalarWhereInput
    data: XOR<BookingRoomUpdateManyMutationInput, BookingRoomUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    gateway?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type BookingCreateWithoutBookingRoomsInput = {
    id?: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    hotel: HotelCreateNestedOneWithoutBookingsInput
    guest?: GuestCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBookingRoomsInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBookingRoomsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookingRoomsInput, BookingUncheckedCreateWithoutBookingRoomsInput>
  }

  export type RoomCreateWithoutBookingRoomsInput = {
    id?: string
    name: string
    isActive?: boolean
    roomType: RoomTypeCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutBookingRoomsInput = {
    id?: string
    roomTypeId: string
    name: string
    isActive?: boolean
  }

  export type RoomCreateOrConnectWithoutBookingRoomsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBookingRoomsInput, RoomUncheckedCreateWithoutBookingRoomsInput>
  }

  export type BookingUpsertWithoutBookingRoomsInput = {
    update: XOR<BookingUpdateWithoutBookingRoomsInput, BookingUncheckedUpdateWithoutBookingRoomsInput>
    create: XOR<BookingCreateWithoutBookingRoomsInput, BookingUncheckedCreateWithoutBookingRoomsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBookingRoomsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBookingRoomsInput, BookingUncheckedUpdateWithoutBookingRoomsInput>
  }

  export type BookingUpdateWithoutBookingRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    guest?: GuestUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookingRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RoomUpsertWithoutBookingRoomsInput = {
    update: XOR<RoomUpdateWithoutBookingRoomsInput, RoomUncheckedUpdateWithoutBookingRoomsInput>
    create: XOR<RoomCreateWithoutBookingRoomsInput, RoomUncheckedCreateWithoutBookingRoomsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutBookingRoomsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutBookingRoomsInput, RoomUncheckedUpdateWithoutBookingRoomsInput>
  }

  export type RoomUpdateWithoutBookingRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutBookingRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingCreateWithoutChannelInput = {
    id?: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
    roomType: RoomTypeCreateNestedOneWithoutChannelMappingsInput
    ratePlan?: RatePlanCreateNestedOneWithoutChannelMappingsInput
  }

  export type ChannelMappingUncheckedCreateWithoutChannelInput = {
    id?: string
    roomTypeId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingCreateOrConnectWithoutChannelInput = {
    where: ChannelMappingWhereUniqueInput
    create: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMappingCreateManyChannelInputEnvelope = {
    data: ChannelMappingCreateManyChannelInput | ChannelMappingCreateManyChannelInput[]
  }

  export type ChannelMappingUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelMappingWhereUniqueInput
    update: XOR<ChannelMappingUpdateWithoutChannelInput, ChannelMappingUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelMappingCreateWithoutChannelInput, ChannelMappingUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMappingUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelMappingWhereUniqueInput
    data: XOR<ChannelMappingUpdateWithoutChannelInput, ChannelMappingUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelMappingUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelMappingScalarWhereInput
    data: XOR<ChannelMappingUpdateManyMutationInput, ChannelMappingUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelCreateWithoutMappingsInput = {
    id?: string
    name: string
    type: string
    isEnabled?: boolean
  }

  export type ChannelUncheckedCreateWithoutMappingsInput = {
    id?: string
    name: string
    type: string
    isEnabled?: boolean
  }

  export type ChannelCreateOrConnectWithoutMappingsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMappingsInput, ChannelUncheckedCreateWithoutMappingsInput>
  }

  export type RoomTypeCreateWithoutChannelMappingsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutChannelMappingsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutChannelMappingsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutChannelMappingsInput, RoomTypeUncheckedCreateWithoutChannelMappingsInput>
  }

  export type RatePlanCreateWithoutChannelMappingsInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    hotel: HotelCreateNestedOneWithoutRatePlansInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanUncheckedCreateWithoutChannelMappingsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRatePlanInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRatePlanInput
  }

  export type RatePlanCreateOrConnectWithoutChannelMappingsInput = {
    where: RatePlanWhereUniqueInput
    create: XOR<RatePlanCreateWithoutChannelMappingsInput, RatePlanUncheckedCreateWithoutChannelMappingsInput>
  }

  export type ChannelUpsertWithoutMappingsInput = {
    update: XOR<ChannelUpdateWithoutMappingsInput, ChannelUncheckedUpdateWithoutMappingsInput>
    create: XOR<ChannelCreateWithoutMappingsInput, ChannelUncheckedCreateWithoutMappingsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMappingsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMappingsInput, ChannelUncheckedUpdateWithoutMappingsInput>
  }

  export type ChannelUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelUncheckedUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomTypeUpsertWithoutChannelMappingsInput = {
    update: XOR<RoomTypeUpdateWithoutChannelMappingsInput, RoomTypeUncheckedUpdateWithoutChannelMappingsInput>
    create: XOR<RoomTypeCreateWithoutChannelMappingsInput, RoomTypeUncheckedCreateWithoutChannelMappingsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutChannelMappingsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutChannelMappingsInput, RoomTypeUncheckedUpdateWithoutChannelMappingsInput>
  }

  export type RoomTypeUpdateWithoutChannelMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutChannelMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RatePlanUpsertWithoutChannelMappingsInput = {
    update: XOR<RatePlanUpdateWithoutChannelMappingsInput, RatePlanUncheckedUpdateWithoutChannelMappingsInput>
    create: XOR<RatePlanCreateWithoutChannelMappingsInput, RatePlanUncheckedCreateWithoutChannelMappingsInput>
    where?: RatePlanWhereInput
  }

  export type RatePlanUpdateToOneWithWhereWithoutChannelMappingsInput = {
    where?: RatePlanWhereInput
    data: XOR<RatePlanUpdateWithoutChannelMappingsInput, RatePlanUncheckedUpdateWithoutChannelMappingsInput>
  }

  export type RatePlanUpdateWithoutChannelMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hotel?: HotelUpdateOneRequiredWithoutRatePlansNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateWithoutChannelMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRatePlanNestedInput
  }

  export type RoomTypeCreateWithoutIcalFeedsInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutIcalFeedsInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutIcalFeedsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutIcalFeedsInput, RoomTypeUncheckedCreateWithoutIcalFeedsInput>
  }

  export type RoomTypeUpsertWithoutIcalFeedsInput = {
    update: XOR<RoomTypeUpdateWithoutIcalFeedsInput, RoomTypeUncheckedUpdateWithoutIcalFeedsInput>
    create: XOR<RoomTypeCreateWithoutIcalFeedsInput, RoomTypeUncheckedCreateWithoutIcalFeedsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutIcalFeedsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutIcalFeedsInput, RoomTypeUncheckedUpdateWithoutIcalFeedsInput>
  }

  export type RoomTypeUpdateWithoutIcalFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutIcalFeedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    hotel: HotelCreateNestedOneWithoutBookingsInput
    guest?: GuestCreateNestedOneWithoutBookingsInput
    bookingRooms?: BookingRoomCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
    bookingRooms?: BookingRoomUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    guest?: GuestUpdateOneWithoutBookingsNestedInput
    bookingRooms?: BookingRoomUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type HotelCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
    waitlistEntries?: HotelWaitlistUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutUsersInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutUsersInput, HotelUncheckedCreateWithoutUsersInput>
  }

  export type HotelUpsertWithoutUsersInput = {
    update: XOR<HotelUpdateWithoutUsersInput, HotelUncheckedUpdateWithoutUsersInput>
    create: XOR<HotelCreateWithoutUsersInput, HotelUncheckedCreateWithoutUsersInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutUsersInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutUsersInput, HotelUncheckedUpdateWithoutUsersInput>
  }

  export type HotelUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type ZoneCreateWithoutRestaurantInput = {
    id?: string
    name: string
    index?: number
    isActive?: boolean
    tables?: TableCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutRestaurantInput = {
    id?: string
    name: string
    index?: number
    isActive?: boolean
    tables?: TableUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutRestaurantInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput>
  }

  export type ZoneCreateManyRestaurantInputEnvelope = {
    data: ZoneCreateManyRestaurantInput | ZoneCreateManyRestaurantInput[]
  }

  export type ResBookingCreateWithoutRestaurantInput = {
    id?: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    table?: TableCreateNestedOneWithoutResBookingsInput
    channel?: RestaurantChannelCreateNestedOneWithoutResBookingsInput
  }

  export type ResBookingUncheckedCreateWithoutRestaurantInput = {
    id?: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type ResBookingCreateOrConnectWithoutRestaurantInput = {
    where: ResBookingWhereUniqueInput
    create: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput>
  }

  export type ResBookingCreateManyRestaurantInputEnvelope = {
    data: ResBookingCreateManyRestaurantInput | ResBookingCreateManyRestaurantInput[]
  }

  export type RestaurantWaitlistCreateWithoutRestaurantInput = {
    id?: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
  }

  export type RestaurantWaitlistUncheckedCreateWithoutRestaurantInput = {
    id?: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
  }

  export type RestaurantWaitlistCreateOrConnectWithoutRestaurantInput = {
    where: RestaurantWaitlistWhereUniqueInput
    create: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput>
  }

  export type RestaurantWaitlistCreateManyRestaurantInputEnvelope = {
    data: RestaurantWaitlistCreateManyRestaurantInput | RestaurantWaitlistCreateManyRestaurantInput[]
  }

  export type ZoneUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutRestaurantInput, ZoneUncheckedUpdateWithoutRestaurantInput>
    create: XOR<ZoneCreateWithoutRestaurantInput, ZoneUncheckedCreateWithoutRestaurantInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutRestaurantInput, ZoneUncheckedUpdateWithoutRestaurantInput>
  }

  export type ZoneUpdateManyWithWhereWithoutRestaurantInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    restaurantId?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    index?: IntFilter<"Zone"> | number
    isActive?: BoolFilter<"Zone"> | boolean
  }

  export type ResBookingUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ResBookingWhereUniqueInput
    update: XOR<ResBookingUpdateWithoutRestaurantInput, ResBookingUncheckedUpdateWithoutRestaurantInput>
    create: XOR<ResBookingCreateWithoutRestaurantInput, ResBookingUncheckedCreateWithoutRestaurantInput>
  }

  export type ResBookingUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ResBookingWhereUniqueInput
    data: XOR<ResBookingUpdateWithoutRestaurantInput, ResBookingUncheckedUpdateWithoutRestaurantInput>
  }

  export type ResBookingUpdateManyWithWhereWithoutRestaurantInput = {
    where: ResBookingScalarWhereInput
    data: XOR<ResBookingUpdateManyMutationInput, ResBookingUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ResBookingScalarWhereInput = {
    AND?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
    OR?: ResBookingScalarWhereInput[]
    NOT?: ResBookingScalarWhereInput | ResBookingScalarWhereInput[]
    id?: StringFilter<"ResBooking"> | string
    restaurantId?: StringFilter<"ResBooking"> | string
    tableId?: StringNullableFilter<"ResBooking"> | string | null
    guestName?: StringFilter<"ResBooking"> | string
    guestPhone?: StringNullableFilter<"ResBooking"> | string | null
    guestEmail?: StringNullableFilter<"ResBooking"> | string | null
    pax?: IntFilter<"ResBooking"> | number
    date?: DateTimeFilter<"ResBooking"> | Date | string
    duration?: IntFilter<"ResBooking"> | number
    status?: StringFilter<"ResBooking"> | string
    tags?: StringNullableFilter<"ResBooking"> | string | null
    notes?: StringNullableFilter<"ResBooking"> | string | null
    origin?: StringFilter<"ResBooking"> | string
    stripeCustomerId?: StringNullableFilter<"ResBooking"> | string | null
    stripePaymentMethodId?: StringNullableFilter<"ResBooking"> | string | null
    smsSent?: BoolFilter<"ResBooking"> | boolean
    emailSent?: BoolFilter<"ResBooking"> | boolean
    createdAt?: DateTimeFilter<"ResBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ResBooking"> | Date | string
    idempotencyKey?: StringNullableFilter<"ResBooking"> | string | null
    channelId?: StringNullableFilter<"ResBooking"> | string | null
  }

  export type RestaurantWaitlistUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: RestaurantWaitlistWhereUniqueInput
    update: XOR<RestaurantWaitlistUpdateWithoutRestaurantInput, RestaurantWaitlistUncheckedUpdateWithoutRestaurantInput>
    create: XOR<RestaurantWaitlistCreateWithoutRestaurantInput, RestaurantWaitlistUncheckedCreateWithoutRestaurantInput>
  }

  export type RestaurantWaitlistUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: RestaurantWaitlistWhereUniqueInput
    data: XOR<RestaurantWaitlistUpdateWithoutRestaurantInput, RestaurantWaitlistUncheckedUpdateWithoutRestaurantInput>
  }

  export type RestaurantWaitlistUpdateManyWithWhereWithoutRestaurantInput = {
    where: RestaurantWaitlistScalarWhereInput
    data: XOR<RestaurantWaitlistUpdateManyMutationInput, RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type RestaurantWaitlistScalarWhereInput = {
    AND?: RestaurantWaitlistScalarWhereInput | RestaurantWaitlistScalarWhereInput[]
    OR?: RestaurantWaitlistScalarWhereInput[]
    NOT?: RestaurantWaitlistScalarWhereInput | RestaurantWaitlistScalarWhereInput[]
    id?: StringFilter<"RestaurantWaitlist"> | string
    restaurantId?: StringFilter<"RestaurantWaitlist"> | string
    name?: StringFilter<"RestaurantWaitlist"> | string
    phone?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    pax?: IntFilter<"RestaurantWaitlist"> | number
    notes?: StringNullableFilter<"RestaurantWaitlist"> | string | null
    status?: StringFilter<"RestaurantWaitlist"> | string
    createdAt?: DateTimeFilter<"RestaurantWaitlist"> | Date | string
    notifiedAt?: DateTimeNullableFilter<"RestaurantWaitlist"> | Date | string | null
  }

  export type RestaurantCreateWithoutZonesInput = {
    id?: string
    name: string
    currency?: string
    bookings?: ResBookingCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    currency?: string
    bookings?: ResBookingUncheckedCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutZonesInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutZonesInput, RestaurantUncheckedCreateWithoutZonesInput>
  }

  export type TableCreateWithoutZoneInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    resBookings?: ResBookingCreateNestedManyWithoutTableInput
    tableHolds?: TableHoldCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutZoneInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    resBookings?: ResBookingUncheckedCreateNestedManyWithoutTableInput
    tableHolds?: TableHoldUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutZoneInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput>
  }

  export type TableCreateManyZoneInputEnvelope = {
    data: TableCreateManyZoneInput | TableCreateManyZoneInput[]
  }

  export type RestaurantUpsertWithoutZonesInput = {
    update: XOR<RestaurantUpdateWithoutZonesInput, RestaurantUncheckedUpdateWithoutZonesInput>
    create: XOR<RestaurantCreateWithoutZonesInput, RestaurantUncheckedCreateWithoutZonesInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutZonesInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutZonesInput, RestaurantUncheckedUpdateWithoutZonesInput>
  }

  export type RestaurantUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    bookings?: ResBookingUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    bookings?: ResBookingUncheckedUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type TableUpsertWithWhereUniqueWithoutZoneInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutZoneInput, TableUncheckedUpdateWithoutZoneInput>
    create: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput>
  }

  export type TableUpdateWithWhereUniqueWithoutZoneInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutZoneInput, TableUncheckedUpdateWithoutZoneInput>
  }

  export type TableUpdateManyWithWhereWithoutZoneInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutZoneInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: StringFilter<"Table"> | string
    zoneId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    capacity?: IntFilter<"Table"> | number
    x?: IntFilter<"Table"> | number
    y?: IntFilter<"Table"> | number
    width?: IntFilter<"Table"> | number
    height?: IntFilter<"Table"> | number
    shape?: StringFilter<"Table"> | string
    rotation?: IntFilter<"Table"> | number
    isActive?: BoolFilter<"Table"> | boolean
    minPax?: IntFilter<"Table"> | number
    maxPax?: IntFilter<"Table"> | number
  }

  export type ZoneCreateWithoutTablesInput = {
    id?: string
    name: string
    index?: number
    isActive?: boolean
    restaurant: RestaurantCreateNestedOneWithoutZonesInput
  }

  export type ZoneUncheckedCreateWithoutTablesInput = {
    id?: string
    restaurantId: string
    name: string
    index?: number
    isActive?: boolean
  }

  export type ZoneCreateOrConnectWithoutTablesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutTablesInput, ZoneUncheckedCreateWithoutTablesInput>
  }

  export type ResBookingCreateWithoutTableInput = {
    id?: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    restaurant: RestaurantCreateNestedOneWithoutBookingsInput
    channel?: RestaurantChannelCreateNestedOneWithoutResBookingsInput
  }

  export type ResBookingUncheckedCreateWithoutTableInput = {
    id?: string
    restaurantId: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type ResBookingCreateOrConnectWithoutTableInput = {
    where: ResBookingWhereUniqueInput
    create: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput>
  }

  export type ResBookingCreateManyTableInputEnvelope = {
    data: ResBookingCreateManyTableInput | ResBookingCreateManyTableInput[]
  }

  export type TableHoldCreateWithoutTableInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type TableHoldUncheckedCreateWithoutTableInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type TableHoldCreateOrConnectWithoutTableInput = {
    where: TableHoldWhereUniqueInput
    create: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput>
  }

  export type TableHoldCreateManyTableInputEnvelope = {
    data: TableHoldCreateManyTableInput | TableHoldCreateManyTableInput[]
  }

  export type ZoneUpsertWithoutTablesInput = {
    update: XOR<ZoneUpdateWithoutTablesInput, ZoneUncheckedUpdateWithoutTablesInput>
    create: XOR<ZoneCreateWithoutTablesInput, ZoneUncheckedCreateWithoutTablesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutTablesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutTablesInput, ZoneUncheckedUpdateWithoutTablesInput>
  }

  export type ZoneUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutZonesNestedInput
  }

  export type ZoneUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResBookingUpsertWithWhereUniqueWithoutTableInput = {
    where: ResBookingWhereUniqueInput
    update: XOR<ResBookingUpdateWithoutTableInput, ResBookingUncheckedUpdateWithoutTableInput>
    create: XOR<ResBookingCreateWithoutTableInput, ResBookingUncheckedCreateWithoutTableInput>
  }

  export type ResBookingUpdateWithWhereUniqueWithoutTableInput = {
    where: ResBookingWhereUniqueInput
    data: XOR<ResBookingUpdateWithoutTableInput, ResBookingUncheckedUpdateWithoutTableInput>
  }

  export type ResBookingUpdateManyWithWhereWithoutTableInput = {
    where: ResBookingScalarWhereInput
    data: XOR<ResBookingUpdateManyMutationInput, ResBookingUncheckedUpdateManyWithoutTableInput>
  }

  export type TableHoldUpsertWithWhereUniqueWithoutTableInput = {
    where: TableHoldWhereUniqueInput
    update: XOR<TableHoldUpdateWithoutTableInput, TableHoldUncheckedUpdateWithoutTableInput>
    create: XOR<TableHoldCreateWithoutTableInput, TableHoldUncheckedCreateWithoutTableInput>
  }

  export type TableHoldUpdateWithWhereUniqueWithoutTableInput = {
    where: TableHoldWhereUniqueInput
    data: XOR<TableHoldUpdateWithoutTableInput, TableHoldUncheckedUpdateWithoutTableInput>
  }

  export type TableHoldUpdateManyWithWhereWithoutTableInput = {
    where: TableHoldScalarWhereInput
    data: XOR<TableHoldUpdateManyMutationInput, TableHoldUncheckedUpdateManyWithoutTableInput>
  }

  export type TableHoldScalarWhereInput = {
    AND?: TableHoldScalarWhereInput | TableHoldScalarWhereInput[]
    OR?: TableHoldScalarWhereInput[]
    NOT?: TableHoldScalarWhereInput | TableHoldScalarWhereInput[]
    id?: StringFilter<"TableHold"> | string
    tableId?: StringFilter<"TableHold"> | string
    token?: StringFilter<"TableHold"> | string
    expiresAt?: DateTimeFilter<"TableHold"> | Date | string
    createdAt?: DateTimeFilter<"TableHold"> | Date | string
  }

  export type RestaurantCreateWithoutBookingsInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutRestaurantInput
    waitlist?: RestaurantWaitlistUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutBookingsInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutBookingsInput, RestaurantUncheckedCreateWithoutBookingsInput>
  }

  export type TableCreateWithoutResBookingsInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    zone: ZoneCreateNestedOneWithoutTablesInput
    tableHolds?: TableHoldCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutResBookingsInput = {
    id?: string
    zoneId: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    tableHolds?: TableHoldUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutResBookingsInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutResBookingsInput, TableUncheckedCreateWithoutResBookingsInput>
  }

  export type RestaurantChannelCreateWithoutResBookingsInput = {
    id?: string
    name: string
    commission?: Decimal | DecimalJsLike | number | string
  }

  export type RestaurantChannelUncheckedCreateWithoutResBookingsInput = {
    id?: string
    name: string
    commission?: Decimal | DecimalJsLike | number | string
  }

  export type RestaurantChannelCreateOrConnectWithoutResBookingsInput = {
    where: RestaurantChannelWhereUniqueInput
    create: XOR<RestaurantChannelCreateWithoutResBookingsInput, RestaurantChannelUncheckedCreateWithoutResBookingsInput>
  }

  export type RestaurantUpsertWithoutBookingsInput = {
    update: XOR<RestaurantUpdateWithoutBookingsInput, RestaurantUncheckedUpdateWithoutBookingsInput>
    create: XOR<RestaurantCreateWithoutBookingsInput, RestaurantUncheckedCreateWithoutBookingsInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutBookingsInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutBookingsInput, RestaurantUncheckedUpdateWithoutBookingsInput>
  }

  export type RestaurantUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutRestaurantNestedInput
    waitlist?: RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type TableUpsertWithoutResBookingsInput = {
    update: XOR<TableUpdateWithoutResBookingsInput, TableUncheckedUpdateWithoutResBookingsInput>
    create: XOR<TableCreateWithoutResBookingsInput, TableUncheckedCreateWithoutResBookingsInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutResBookingsInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutResBookingsInput, TableUncheckedUpdateWithoutResBookingsInput>
  }

  export type TableUpdateWithoutResBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    zone?: ZoneUpdateOneRequiredWithoutTablesNestedInput
    tableHolds?: TableHoldUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutResBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    tableHolds?: TableHoldUncheckedUpdateManyWithoutTableNestedInput
  }

  export type RestaurantChannelUpsertWithoutResBookingsInput = {
    update: XOR<RestaurantChannelUpdateWithoutResBookingsInput, RestaurantChannelUncheckedUpdateWithoutResBookingsInput>
    create: XOR<RestaurantChannelCreateWithoutResBookingsInput, RestaurantChannelUncheckedCreateWithoutResBookingsInput>
    where?: RestaurantChannelWhereInput
  }

  export type RestaurantChannelUpdateToOneWithWhereWithoutResBookingsInput = {
    where?: RestaurantChannelWhereInput
    data: XOR<RestaurantChannelUpdateWithoutResBookingsInput, RestaurantChannelUncheckedUpdateWithoutResBookingsInput>
  }

  export type RestaurantChannelUpdateWithoutResBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RestaurantChannelUncheckedUpdateWithoutResBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ResBookingCreateWithoutChannelInput = {
    id?: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    restaurant: RestaurantCreateNestedOneWithoutBookingsInput
    table?: TableCreateNestedOneWithoutResBookingsInput
  }

  export type ResBookingUncheckedCreateWithoutChannelInput = {
    id?: string
    restaurantId: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
  }

  export type ResBookingCreateOrConnectWithoutChannelInput = {
    where: ResBookingWhereUniqueInput
    create: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput>
  }

  export type ResBookingCreateManyChannelInputEnvelope = {
    data: ResBookingCreateManyChannelInput | ResBookingCreateManyChannelInput[]
  }

  export type ResBookingUpsertWithWhereUniqueWithoutChannelInput = {
    where: ResBookingWhereUniqueInput
    update: XOR<ResBookingUpdateWithoutChannelInput, ResBookingUncheckedUpdateWithoutChannelInput>
    create: XOR<ResBookingCreateWithoutChannelInput, ResBookingUncheckedCreateWithoutChannelInput>
  }

  export type ResBookingUpdateWithWhereUniqueWithoutChannelInput = {
    where: ResBookingWhereUniqueInput
    data: XOR<ResBookingUpdateWithoutChannelInput, ResBookingUncheckedUpdateWithoutChannelInput>
  }

  export type ResBookingUpdateManyWithWhereWithoutChannelInput = {
    where: ResBookingScalarWhereInput
    data: XOR<ResBookingUpdateManyMutationInput, ResBookingUncheckedUpdateManyWithoutChannelInput>
  }

  export type TableCreateWithoutTableHoldsInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    zone: ZoneCreateNestedOneWithoutTablesInput
    resBookings?: ResBookingCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutTableHoldsInput = {
    id?: string
    zoneId: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
    resBookings?: ResBookingUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutTableHoldsInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutTableHoldsInput, TableUncheckedCreateWithoutTableHoldsInput>
  }

  export type TableUpsertWithoutTableHoldsInput = {
    update: XOR<TableUpdateWithoutTableHoldsInput, TableUncheckedUpdateWithoutTableHoldsInput>
    create: XOR<TableCreateWithoutTableHoldsInput, TableUncheckedCreateWithoutTableHoldsInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutTableHoldsInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutTableHoldsInput, TableUncheckedUpdateWithoutTableHoldsInput>
  }

  export type TableUpdateWithoutTableHoldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    zone?: ZoneUpdateOneRequiredWithoutTablesNestedInput
    resBookings?: ResBookingUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutTableHoldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    resBookings?: ResBookingUncheckedUpdateManyWithoutTableNestedInput
  }

  export type RestaurantCreateWithoutWaitlistInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneCreateNestedManyWithoutRestaurantInput
    bookings?: ResBookingCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutWaitlistInput = {
    id?: string
    name: string
    currency?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutRestaurantInput
    bookings?: ResBookingUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutWaitlistInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutWaitlistInput, RestaurantUncheckedCreateWithoutWaitlistInput>
  }

  export type RestaurantUpsertWithoutWaitlistInput = {
    update: XOR<RestaurantUpdateWithoutWaitlistInput, RestaurantUncheckedUpdateWithoutWaitlistInput>
    create: XOR<RestaurantCreateWithoutWaitlistInput, RestaurantUncheckedCreateWithoutWaitlistInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutWaitlistInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutWaitlistInput, RestaurantUncheckedUpdateWithoutWaitlistInput>
  }

  export type RestaurantUpdateWithoutWaitlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUpdateManyWithoutRestaurantNestedInput
    bookings?: ResBookingUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutWaitlistInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutRestaurantNestedInput
    bookings?: ResBookingUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type HotelCreateWithoutWaitlistEntriesInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanCreateNestedManyWithoutHotelInput
    seasons?: SeasonCreateNestedManyWithoutHotelInput
    users?: UserCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutWaitlistEntriesInput = {
    id?: string
    name: string
    domain?: string | null
    timezone?: string
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    ratePlans?: RatePlanUncheckedCreateNestedManyWithoutHotelInput
    seasons?: SeasonUncheckedCreateNestedManyWithoutHotelInput
    users?: UserUncheckedCreateNestedManyWithoutHotelInput
    widgetConfig?: WidgetConfigUncheckedCreateNestedOneWithoutHotelInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutWaitlistEntriesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutWaitlistEntriesInput, HotelUncheckedCreateWithoutWaitlistEntriesInput>
  }

  export type RoomTypeCreateWithoutWaitlistEntriesInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomTypesInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutWaitlistEntriesInput = {
    id?: string
    hotelId: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    icalFeeds?: ICalFeedUncheckedCreateNestedManyWithoutRoomTypeInput
    dailyPrices?: DailyPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutRoomTypeInput
    channelMappings?: ChannelMappingUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutWaitlistEntriesInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutWaitlistEntriesInput, RoomTypeUncheckedCreateWithoutWaitlistEntriesInput>
  }

  export type HotelUpsertWithoutWaitlistEntriesInput = {
    update: XOR<HotelUpdateWithoutWaitlistEntriesInput, HotelUncheckedUpdateWithoutWaitlistEntriesInput>
    create: XOR<HotelCreateWithoutWaitlistEntriesInput, HotelUncheckedCreateWithoutWaitlistEntriesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutWaitlistEntriesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutWaitlistEntriesInput, HotelUncheckedUpdateWithoutWaitlistEntriesInput>
  }

  export type HotelUpdateWithoutWaitlistEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUpdateManyWithoutHotelNestedInput
    users?: UserUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutWaitlistEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    ratePlans?: RatePlanUncheckedUpdateManyWithoutHotelNestedInput
    seasons?: SeasonUncheckedUpdateManyWithoutHotelNestedInput
    users?: UserUncheckedUpdateManyWithoutHotelNestedInput
    widgetConfig?: WidgetConfigUncheckedUpdateOneWithoutHotelNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeUpsertWithoutWaitlistEntriesInput = {
    update: XOR<RoomTypeUpdateWithoutWaitlistEntriesInput, RoomTypeUncheckedUpdateWithoutWaitlistEntriesInput>
    create: XOR<RoomTypeCreateWithoutWaitlistEntriesInput, RoomTypeUncheckedCreateWithoutWaitlistEntriesInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutWaitlistEntriesInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutWaitlistEntriesInput, RoomTypeUncheckedUpdateWithoutWaitlistEntriesInput>
  }

  export type RoomTypeUpdateWithoutWaitlistEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutWaitlistEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type IdentityLinkCreateWithoutCustomerProfileInput = {
    id?: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
  }

  export type IdentityLinkUncheckedCreateWithoutCustomerProfileInput = {
    id?: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
  }

  export type IdentityLinkCreateOrConnectWithoutCustomerProfileInput = {
    where: IdentityLinkWhereUniqueInput
    create: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput>
  }

  export type IdentityLinkCreateManyCustomerProfileInputEnvelope = {
    data: IdentityLinkCreateManyCustomerProfileInput | IdentityLinkCreateManyCustomerProfileInput[]
  }

  export type WebVisitCreateWithoutCustomerProfileInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
  }

  export type WebVisitUncheckedCreateWithoutCustomerProfileInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
  }

  export type WebVisitCreateOrConnectWithoutCustomerProfileInput = {
    where: WebVisitWhereUniqueInput
    create: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput>
  }

  export type WebVisitCreateManyCustomerProfileInputEnvelope = {
    data: WebVisitCreateManyCustomerProfileInput | WebVisitCreateManyCustomerProfileInput[]
  }

  export type IdentityLinkUpsertWithWhereUniqueWithoutCustomerProfileInput = {
    where: IdentityLinkWhereUniqueInput
    update: XOR<IdentityLinkUpdateWithoutCustomerProfileInput, IdentityLinkUncheckedUpdateWithoutCustomerProfileInput>
    create: XOR<IdentityLinkCreateWithoutCustomerProfileInput, IdentityLinkUncheckedCreateWithoutCustomerProfileInput>
  }

  export type IdentityLinkUpdateWithWhereUniqueWithoutCustomerProfileInput = {
    where: IdentityLinkWhereUniqueInput
    data: XOR<IdentityLinkUpdateWithoutCustomerProfileInput, IdentityLinkUncheckedUpdateWithoutCustomerProfileInput>
  }

  export type IdentityLinkUpdateManyWithWhereWithoutCustomerProfileInput = {
    where: IdentityLinkScalarWhereInput
    data: XOR<IdentityLinkUpdateManyMutationInput, IdentityLinkUncheckedUpdateManyWithoutCustomerProfileInput>
  }

  export type IdentityLinkScalarWhereInput = {
    AND?: IdentityLinkScalarWhereInput | IdentityLinkScalarWhereInput[]
    OR?: IdentityLinkScalarWhereInput[]
    NOT?: IdentityLinkScalarWhereInput | IdentityLinkScalarWhereInput[]
    id?: StringFilter<"IdentityLink"> | string
    customerProfileId?: StringFilter<"IdentityLink"> | string
    sourceType?: StringFilter<"IdentityLink"> | string
    sourceId?: StringFilter<"IdentityLink"> | string
    mergedAt?: DateTimeFilter<"IdentityLink"> | Date | string
  }

  export type WebVisitUpsertWithWhereUniqueWithoutCustomerProfileInput = {
    where: WebVisitWhereUniqueInput
    update: XOR<WebVisitUpdateWithoutCustomerProfileInput, WebVisitUncheckedUpdateWithoutCustomerProfileInput>
    create: XOR<WebVisitCreateWithoutCustomerProfileInput, WebVisitUncheckedCreateWithoutCustomerProfileInput>
  }

  export type WebVisitUpdateWithWhereUniqueWithoutCustomerProfileInput = {
    where: WebVisitWhereUniqueInput
    data: XOR<WebVisitUpdateWithoutCustomerProfileInput, WebVisitUncheckedUpdateWithoutCustomerProfileInput>
  }

  export type WebVisitUpdateManyWithWhereWithoutCustomerProfileInput = {
    where: WebVisitScalarWhereInput
    data: XOR<WebVisitUpdateManyMutationInput, WebVisitUncheckedUpdateManyWithoutCustomerProfileInput>
  }

  export type WebVisitScalarWhereInput = {
    AND?: WebVisitScalarWhereInput | WebVisitScalarWhereInput[]
    OR?: WebVisitScalarWhereInput[]
    NOT?: WebVisitScalarWhereInput | WebVisitScalarWhereInput[]
    id?: StringFilter<"WebVisit"> | string
    sessionId?: StringFilter<"WebVisit"> | string
    visitorId?: StringNullableFilter<"WebVisit"> | string | null
    customerProfileId?: StringNullableFilter<"WebVisit"> | string | null
    url?: StringFilter<"WebVisit"> | string
    referrer?: StringNullableFilter<"WebVisit"> | string | null
    userAgent?: StringNullableFilter<"WebVisit"> | string | null
    duration?: IntFilter<"WebVisit"> | number
    timestamp?: DateTimeFilter<"WebVisit"> | Date | string
  }

  export type CustomerProfileCreateWithoutIdentityLinksInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    webVisits?: WebVisitCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileUncheckedCreateWithoutIdentityLinksInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    webVisits?: WebVisitUncheckedCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileCreateOrConnectWithoutIdentityLinksInput = {
    where: CustomerProfileWhereUniqueInput
    create: XOR<CustomerProfileCreateWithoutIdentityLinksInput, CustomerProfileUncheckedCreateWithoutIdentityLinksInput>
  }

  export type CustomerProfileUpsertWithoutIdentityLinksInput = {
    update: XOR<CustomerProfileUpdateWithoutIdentityLinksInput, CustomerProfileUncheckedUpdateWithoutIdentityLinksInput>
    create: XOR<CustomerProfileCreateWithoutIdentityLinksInput, CustomerProfileUncheckedCreateWithoutIdentityLinksInput>
    where?: CustomerProfileWhereInput
  }

  export type CustomerProfileUpdateToOneWithWhereWithoutIdentityLinksInput = {
    where?: CustomerProfileWhereInput
    data: XOR<CustomerProfileUpdateWithoutIdentityLinksInput, CustomerProfileUncheckedUpdateWithoutIdentityLinksInput>
  }

  export type CustomerProfileUpdateWithoutIdentityLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webVisits?: WebVisitUpdateManyWithoutCustomerProfileNestedInput
  }

  export type CustomerProfileUncheckedUpdateWithoutIdentityLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webVisits?: WebVisitUncheckedUpdateManyWithoutCustomerProfileNestedInput
  }

  export type CustomerProfileCreateWithoutWebVisitsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    identityLinks?: IdentityLinkCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileUncheckedCreateWithoutWebVisitsInput = {
    id?: string
    email?: string | null
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    lifecycleStage?: string
    totalSpend?: Decimal | DecimalJsLike | number | string
    visitCount?: number
    lastInteraction?: Date | string | null
    tags?: string | null
    consentEmail?: boolean
    consentWhatsApp?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    identityLinks?: IdentityLinkUncheckedCreateNestedManyWithoutCustomerProfileInput
  }

  export type CustomerProfileCreateOrConnectWithoutWebVisitsInput = {
    where: CustomerProfileWhereUniqueInput
    create: XOR<CustomerProfileCreateWithoutWebVisitsInput, CustomerProfileUncheckedCreateWithoutWebVisitsInput>
  }

  export type CustomerProfileUpsertWithoutWebVisitsInput = {
    update: XOR<CustomerProfileUpdateWithoutWebVisitsInput, CustomerProfileUncheckedUpdateWithoutWebVisitsInput>
    create: XOR<CustomerProfileCreateWithoutWebVisitsInput, CustomerProfileUncheckedCreateWithoutWebVisitsInput>
    where?: CustomerProfileWhereInput
  }

  export type CustomerProfileUpdateToOneWithWhereWithoutWebVisitsInput = {
    where?: CustomerProfileWhereInput
    data: XOR<CustomerProfileUpdateWithoutWebVisitsInput, CustomerProfileUncheckedUpdateWithoutWebVisitsInput>
  }

  export type CustomerProfileUpdateWithoutWebVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identityLinks?: IdentityLinkUpdateManyWithoutCustomerProfileNestedInput
  }

  export type CustomerProfileUncheckedUpdateWithoutWebVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    lifecycleStage?: StringFieldUpdateOperationsInput | string
    totalSpend?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    visitCount?: IntFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    consentEmail?: BoolFieldUpdateOperationsInput | boolean
    consentWhatsApp?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identityLinks?: IdentityLinkUncheckedUpdateManyWithoutCustomerProfileNestedInput
  }

  export type RoomTypeCreateManyHotelInput = {
    id?: string
    name: string
    description?: string | null
    basePrice?: Decimal | DecimalJsLike | number | string
    capacity?: number
    amenities?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyHotelInput = {
    id?: string
    referenceCode: string
    guestId?: string | null
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
  }

  export type RatePlanCreateManyHotelInput = {
    id?: string
    name: string
    description?: string | null
    isDefault?: boolean
    cancellationPolicy?: string | null
    mealsIncluded?: string | null
    requireCreditCard?: boolean
    noShowFee?: Decimal | DecimalJsLike | number | string
  }

  export type SeasonCreateManyHotelInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    priceMultiplier?: Decimal | DecimalJsLike | number | string
  }

  export type UserCreateManyHotelInput = {
    id?: string
    email: string
    password: string
    role?: string
  }

  export type RestrictionCreateManyHotelInput = {
    id?: string
    roomTypeId?: string | null
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type HotelWaitlistCreateManyHotelInput = {
    id?: string
    roomTypeId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type RoomTypeUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    icalFeeds?: ICalFeedUncheckedUpdateManyWithoutRoomTypeNestedInput
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRoomTypeNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRoomTypeNestedInput
    waitlistEntries?: HotelWaitlistUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    guest?: GuestUpdateOneWithoutBookingsNestedInput
    bookingRooms?: BookingRoomUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatePlanUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dailyPrices?: DailyPriceUncheckedUpdateManyWithoutRatePlanNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutRatePlanNestedInput
    channelMappings?: ChannelMappingUncheckedUpdateManyWithoutRatePlanNestedInput
  }

  export type RatePlanUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    mealsIncluded?: NullableStringFieldUpdateOperationsInput | string | null
    requireCreditCard?: BoolFieldUpdateOperationsInput | boolean
    noShowFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SeasonUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priceMultiplier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type RestrictionUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneWithoutRestrictionsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutRestrictionsNestedInput
  }

  export type RestrictionUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestrictionUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneRequiredWithoutWaitlistEntriesNestedInput
  }

  export type HotelWaitlistUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomCreateManyRoomTypeInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type ICalFeedCreateManyRoomTypeInput = {
    id?: string
    url: string
    name?: string | null
    source: string
    lastSync?: Date | string | null
    isActive?: boolean
  }

  export type DailyPriceCreateManyRoomTypeInput = {
    id?: string
    ratePlanId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type RestrictionCreateManyRoomTypeInput = {
    id?: string
    hotelId: string
    ratePlanId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type ChannelMappingCreateManyRoomTypeInput = {
    id?: string
    channelId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type HotelWaitlistCreateManyRoomTypeInput = {
    id?: string
    hotelId: string
    email: string
    dateFrom: Date | string
    dateTo: Date | string
    requestDate?: Date | string
    fulfilled?: boolean
  }

  export type RoomUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookingRooms?: BookingRoomUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICalFeedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICalFeedUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICalFeedUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyPriceUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratePlan?: RatePlanUpdateOneRequiredWithoutDailyPricesNestedInput
  }

  export type DailyPriceUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratePlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratePlanId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RestrictionUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRestrictionsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutRestrictionsNestedInput
  }

  export type RestrictionUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestrictionUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    channel?: ChannelUpdateOneRequiredWithoutMappingsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutChannelMappingsNestedInput
  }

  export type ChannelMappingUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutWaitlistEntriesNestedInput
  }

  export type HotelWaitlistUncheckedUpdateWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HotelWaitlistUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    dateFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    dateTo?: DateTimeFieldUpdateOperationsInput | Date | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fulfilled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingRoomCreateManyRoomInput = {
    id?: string
    bookingId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type BookingRoomUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBookingRoomsNestedInput
  }

  export type BookingRoomUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRoomUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyGuestInput = {
    id?: string
    hotelId: string
    referenceCode: string
    guestName: string
    guestEmail?: string | null
    guestPhone?: string | null
    status?: string
    source?: string
    totalPrice: Decimal | DecimalJsLike | number | string
    currency?: string
    isPaid?: boolean
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    stripePaymentIntentId?: string | null
    checkInDate: Date | string
    checkOutDate: Date | string
    nights: number
    createdAt?: Date | string
    updatedAt?: Date | string
    otaId?: string | null
    otaRawData?: string | null
  }

  export type BookingUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    hotel?: HotelUpdateOneRequiredWithoutBookingsNestedInput
    bookingRooms?: BookingRoomUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
    bookingRooms?: BookingRoomUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    referenceCode?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otaId?: NullableStringFieldUpdateOperationsInput | string | null
    otaRawData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyPriceCreateManyRatePlanInput = {
    id?: string
    roomTypeId: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
  }

  export type RestrictionCreateManyRatePlanInput = {
    id?: string
    hotelId: string
    roomTypeId?: string | null
    date: Date | string
    minStay?: number | null
    maxStay?: number | null
    closedToArrival?: boolean
    closedToDeparture?: boolean
    stopSell?: boolean
  }

  export type ChannelMappingCreateManyRatePlanInput = {
    id?: string
    channelId: string
    roomTypeId: string
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type DailyPriceUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roomType?: RoomTypeUpdateOneRequiredWithoutDailyPricesNestedInput
  }

  export type DailyPriceUncheckedUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DailyPriceUncheckedUpdateManyWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type RestrictionUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
    hotel?: HotelUpdateOneRequiredWithoutRestrictionsNestedInput
    roomType?: RoomTypeUpdateOneWithoutRestrictionsNestedInput
  }

  export type RestrictionUncheckedUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestrictionUncheckedUpdateManyWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    closedToArrival?: BoolFieldUpdateOperationsInput | boolean
    closedToDeparture?: BoolFieldUpdateOperationsInput | boolean
    stopSell?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    channel?: ChannelUpdateOneRequiredWithoutMappingsNestedInput
    roomType?: RoomTypeUpdateOneRequiredWithoutChannelMappingsNestedInput
  }

  export type ChannelMappingUncheckedUpdateWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUncheckedUpdateManyWithoutRatePlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingRoomCreateManyBookingInput = {
    id?: string
    roomId: string
    priceSnapshot: Decimal | DecimalJsLike | number | string
    date: Date | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    gateway: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
  }

  export type BookingRoomUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutBookingRoomsNestedInput
  }

  export type BookingRoomUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRoomUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    priceSnapshot?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gateway?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelMappingCreateManyChannelInput = {
    id?: string
    roomTypeId: string
    ratePlanId?: string | null
    externalId: string
    externalName?: string | null
    syncEnabled?: boolean
  }

  export type ChannelMappingUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    roomType?: RoomTypeUpdateOneRequiredWithoutChannelMappingsNestedInput
    ratePlan?: RatePlanUpdateOneWithoutChannelMappingsNestedInput
  }

  export type ChannelMappingUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelMappingUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomTypeId?: StringFieldUpdateOperationsInput | string
    ratePlanId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: StringFieldUpdateOperationsInput | string
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoneCreateManyRestaurantInput = {
    id?: string
    name: string
    index?: number
    isActive?: boolean
  }

  export type ResBookingCreateManyRestaurantInput = {
    id?: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type RestaurantWaitlistCreateManyRestaurantInput = {
    id?: string
    name: string
    phone?: string | null
    pax: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    notifiedAt?: Date | string | null
  }

  export type ZoneUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tables?: TableUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tables?: TableUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResBookingUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutResBookingsNestedInput
    channel?: RestaurantChannelUpdateOneWithoutResBookingsNestedInput
  }

  export type ResBookingUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResBookingUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantWaitlistUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantWaitlistUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RestaurantWaitlistUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TableCreateManyZoneInput = {
    id?: string
    name: string
    capacity?: number
    x?: number
    y?: number
    width?: number
    height?: number
    shape?: string
    rotation?: number
    isActive?: boolean
    minPax?: number
    maxPax?: number
  }

  export type TableUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    resBookings?: ResBookingUpdateManyWithoutTableNestedInput
    tableHolds?: TableHoldUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
    resBookings?: ResBookingUncheckedUpdateManyWithoutTableNestedInput
    tableHolds?: TableHoldUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    x?: IntFieldUpdateOperationsInput | number
    y?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    shape?: StringFieldUpdateOperationsInput | string
    rotation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minPax?: IntFieldUpdateOperationsInput | number
    maxPax?: IntFieldUpdateOperationsInput | number
  }

  export type ResBookingCreateManyTableInput = {
    id?: string
    restaurantId: string
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
    channelId?: string | null
  }

  export type TableHoldCreateManyTableInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ResBookingUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: RestaurantUpdateOneRequiredWithoutBookingsNestedInput
    channel?: RestaurantChannelUpdateOneWithoutResBookingsNestedInput
  }

  export type ResBookingUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResBookingUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableHoldUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableHoldUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableHoldUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResBookingCreateManyChannelInput = {
    id?: string
    restaurantId: string
    tableId?: string | null
    guestName: string
    guestPhone?: string | null
    guestEmail?: string | null
    pax: number
    date: Date | string
    duration?: number
    status?: string
    tags?: string | null
    notes?: string | null
    origin?: string
    stripeCustomerId?: string | null
    stripePaymentMethodId?: string | null
    smsSent?: boolean
    emailSent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idempotencyKey?: string | null
  }

  export type ResBookingUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: RestaurantUpdateOneRequiredWithoutBookingsNestedInput
    table?: TableUpdateOneWithoutResBookingsNestedInput
  }

  export type ResBookingUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResBookingUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    pax?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentMethodId?: NullableStringFieldUpdateOperationsInput | string | null
    smsSent?: BoolFieldUpdateOperationsInput | boolean
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdentityLinkCreateManyCustomerProfileInput = {
    id?: string
    sourceType: string
    sourceId: string
    mergedAt?: Date | string
  }

  export type WebVisitCreateManyCustomerProfileInput = {
    id?: string
    sessionId: string
    visitorId?: string | null
    url: string
    referrer?: string | null
    userAgent?: string | null
    duration?: number
    timestamp?: Date | string
  }

  export type IdentityLinkUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityLinkUncheckedUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityLinkUncheckedUpdateManyWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    mergedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitUncheckedUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebVisitUncheckedUpdateManyWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use HotelCountOutputTypeDefaultArgs instead
     */
    export type HotelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypeCountOutputTypeDefaultArgs instead
     */
    export type RoomTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuestCountOutputTypeDefaultArgs instead
     */
    export type GuestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatePlanCountOutputTypeDefaultArgs instead
     */
    export type RatePlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RatePlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCountOutputTypeDefaultArgs instead
     */
    export type ChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantCountOutputTypeDefaultArgs instead
     */
    export type RestaurantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableCountOutputTypeDefaultArgs instead
     */
    export type TableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantChannelCountOutputTypeDefaultArgs instead
     */
    export type RestaurantChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerProfileCountOutputTypeDefaultArgs instead
     */
    export type CustomerProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelDefaultArgs instead
     */
    export type HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WidgetConfigDefaultArgs instead
     */
    export type WidgetConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WidgetConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomTypeDefaultArgs instead
     */
    export type RoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuestDefaultArgs instead
     */
    export type GuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatePlanDefaultArgs instead
     */
    export type RatePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RatePlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonDefaultArgs instead
     */
    export type SeasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyPriceDefaultArgs instead
     */
    export type DailyPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestrictionDefaultArgs instead
     */
    export type RestrictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestrictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingRoomDefaultArgs instead
     */
    export type BookingRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelDefaultArgs instead
     */
    export type ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelMappingDefaultArgs instead
     */
    export type ChannelMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncLogDefaultArgs instead
     */
    export type SyncLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ICalFeedDefaultArgs instead
     */
    export type ICalFeedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ICalFeedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantDefaultArgs instead
     */
    export type RestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableDefaultArgs instead
     */
    export type TableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResBookingDefaultArgs instead
     */
    export type ResBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantChannelDefaultArgs instead
     */
    export type RestaurantChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResPolicyDefaultArgs instead
     */
    export type ResPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableHoldDefaultArgs instead
     */
    export type TableHoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableHoldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantWaitlistDefaultArgs instead
     */
    export type RestaurantWaitlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantWaitlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelWaitlistDefaultArgs instead
     */
    export type HotelWaitlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelWaitlistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerProfileDefaultArgs instead
     */
    export type CustomerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IdentityLinkDefaultArgs instead
     */
    export type IdentityLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IdentityLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebVisitDefaultArgs instead
     */
    export type WebVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebVisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowDefaultArgs instead
     */
    export type WorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}